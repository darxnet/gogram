// Code generated by gogram/cmd/gen; DO NOT EDIT.

package gogram

import (
	"bytes"
	"encoding/json"
	"io"
	"mime/multipart"
	"strconv"
)

// AddStickerToSetParams contains parameters for Client.AddStickerToSet.
type AddStickerToSetParams struct {
	// User identifier of sticker set owner
	UserID int64 `json:"user_id"`

	// Sticker set name
	Name string `json:"name"`

	// A JSON-serialized object with information about the added sticker.
	// If exactly the same sticker had already been added to the set, then the set isn't changed.
	Sticker InputSticker `json:"sticker"`
}

// AddStickerToSetOption configures AddStickerToSetParams.
type AddStickerToSetOption func(params *AddStickerToSetParams) AddStickerToSetOption

// Option applies one or more AddStickerToSetOption values and returns the last rollback option.
func (r *AddStickerToSetParams) Option(opts ...AddStickerToSetOption) (previous AddStickerToSetOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithAddStickerToSetUserID sets the UserID field.
//
// User identifier of sticker set owner
func WithAddStickerToSetUserID(value int64) AddStickerToSetOption {
	return func(params *AddStickerToSetParams) AddStickerToSetOption {
		previous := params.UserID
		params.UserID = value

		return WithAddStickerToSetUserID(previous)
	}
}

// WithAddStickerToSetName sets the Name field.
//
// Sticker set name
func WithAddStickerToSetName(value string) AddStickerToSetOption {
	return func(params *AddStickerToSetParams) AddStickerToSetOption {
		previous := params.Name
		params.Name = value

		return WithAddStickerToSetName(previous)
	}
}

// WithAddStickerToSetSticker sets the Sticker field.
//
// A JSON-serialized object with information about the added sticker.
// If exactly the same sticker had already been added to the set, then the set isn't changed.
func WithAddStickerToSetSticker(value InputSticker) AddStickerToSetOption {
	return func(params *AddStickerToSetParams) AddStickerToSetOption {
		previous := params.Sticker
		params.Sticker = value

		return WithAddStickerToSetSticker(previous)
	}
}

// AddStickerToSet calls the addStickerToSet Telegram Bot API method.
//
// Use this method to add a new sticker to a set created by the bot.
// Emoji sticker sets can have up to 200 stickers.
// Other sticker sets can have up to 120 stickers.
// Returns True on success.
func (c *Client) AddStickerToSet(params *AddStickerToSetParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("addStickerToSet", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// AnswerCallbackQueryParams contains parameters for Client.AnswerCallbackQuery.
type AnswerCallbackQueryParams struct {
	// Unique identifier for the query to be answered
	CallbackQueryID string `json:"callback_query_id"`

	// Text of the notification.
	// If not specified, nothing will be shown to the user, 0-200 characters
	Text string `json:"text,omitempty"`

	// If True, an alert will be shown by the client instead of a notification at the top of the chat screen.
	// Defaults to false.
	ShowAlert bool `json:"show_alert,omitempty"`

	// URL that will be opened by the user's client.
	// If you have created a [Game] and accepted the conditions via [@BotFather], specify the URL that opens your game - note that this will only work if the query comes from a [callback_game] button.
	//
	// Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with a parameter.
	//
	// [Game]: https://core.telegram.org/bots/api#game
	// [@BotFather]: https://t.me/botfather
	// [callback_game]: https://core.telegram.org/bots/api#inlinekeyboardbutton
	URL string `json:"url,omitempty"`

	// The maximum amount of time in seconds that the result of the callback query may be cached client-side.
	// Telegram apps will support caching starting in version 3.14.
	// Defaults to 0.
	CacheTime int64 `json:"cache_time,omitempty"`
}

// AnswerCallbackQueryOption configures AnswerCallbackQueryParams.
type AnswerCallbackQueryOption func(params *AnswerCallbackQueryParams) AnswerCallbackQueryOption

// Option applies one or more AnswerCallbackQueryOption values and returns the last rollback option.
func (r *AnswerCallbackQueryParams) Option(opts ...AnswerCallbackQueryOption) (previous AnswerCallbackQueryOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithAnswerCallbackQueryCallbackQueryID sets the CallbackQueryID field.
//
// Unique identifier for the query to be answered
func WithAnswerCallbackQueryCallbackQueryID(value string) AnswerCallbackQueryOption {
	return func(params *AnswerCallbackQueryParams) AnswerCallbackQueryOption {
		previous := params.CallbackQueryID
		params.CallbackQueryID = value

		return WithAnswerCallbackQueryCallbackQueryID(previous)
	}
}

// WithAnswerCallbackQueryText sets the Text field.
//
// Text of the notification.
// If not specified, nothing will be shown to the user, 0-200 characters
func WithAnswerCallbackQueryText(value string) AnswerCallbackQueryOption {
	return func(params *AnswerCallbackQueryParams) AnswerCallbackQueryOption {
		previous := params.Text
		params.Text = value

		return WithAnswerCallbackQueryText(previous)
	}
}

// WithAnswerCallbackQueryShowAlert sets the ShowAlert field.
//
// If True, an alert will be shown by the client instead of a notification at the top of the chat screen.
// Defaults to false.
func WithAnswerCallbackQueryShowAlert(value bool) AnswerCallbackQueryOption {
	return func(params *AnswerCallbackQueryParams) AnswerCallbackQueryOption {
		previous := params.ShowAlert
		params.ShowAlert = value

		return WithAnswerCallbackQueryShowAlert(previous)
	}
}

// WithAnswerCallbackQueryURL sets the URL field.
//
// URL that will be opened by the user's client.
// If you have created a [Game] and accepted the conditions via [@BotFather], specify the URL that opens your game - note that this will only work if the query comes from a [callback_game] button.
//
// Otherwise, you may use links like t.me/your_bot?start=XXXX that open your bot with a parameter.
//
// [Game]: https://core.telegram.org/bots/api#game
// [@BotFather]: https://t.me/botfather
// [callback_game]: https://core.telegram.org/bots/api#inlinekeyboardbutton
func WithAnswerCallbackQueryURL(value string) AnswerCallbackQueryOption {
	return func(params *AnswerCallbackQueryParams) AnswerCallbackQueryOption {
		previous := params.URL
		params.URL = value

		return WithAnswerCallbackQueryURL(previous)
	}
}

// WithAnswerCallbackQueryCacheTime sets the CacheTime field.
//
// The maximum amount of time in seconds that the result of the callback query may be cached client-side.
// Telegram apps will support caching starting in version 3.14.
// Defaults to 0.
func WithAnswerCallbackQueryCacheTime(value int64) AnswerCallbackQueryOption {
	return func(params *AnswerCallbackQueryParams) AnswerCallbackQueryOption {
		previous := params.CacheTime
		params.CacheTime = value

		return WithAnswerCallbackQueryCacheTime(previous)
	}
}

// AnswerCallbackQuery calls the answerCallbackQuery Telegram Bot API method.
//
// Use this method to send answers to callback queries sent from [inline keyboards].
// The answer will be displayed to the user as a notification at the top of the chat screen or as an alert.
// On success, True is returned.
//
// [inline keyboards]: https://core.telegram.org/bots/features#inline-keyboards
func (c *Client) AnswerCallbackQuery(params *AnswerCallbackQueryParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("answerCallbackQuery", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// AnswerInlineQueryParams contains parameters for Client.AnswerInlineQuery.
type AnswerInlineQueryParams struct {
	// Unique identifier for the answered query
	InlineQueryID string `json:"inline_query_id"`

	// A JSON-serialized array of results for the inline query
	Results []InlineQueryResult `json:"results"`

	// The maximum amount of time in seconds that the result of the inline query may be cached on the server.
	// Defaults to 300.
	CacheTime int64 `json:"cache_time,omitempty"`

	// Pass True if results may be cached on the server side only for the user that sent the query.
	// By default, results may be returned to any user who sends the same query.
	IsPersonal bool `json:"is_personal,omitempty"`

	// Pass the offset that a client should send in the next query with the same text to receive more results.
	// Pass an empty string if there are no more results or if you don't support pagination.
	// Offset length can't exceed 64 bytes.
	NextOffset string `json:"next_offset,omitempty"`

	// A JSON-serialized object describing a button to be shown above inline query results
	Button *InlineQueryResultsButton `json:"button,omitempty"`
}

// AnswerInlineQueryOption configures AnswerInlineQueryParams.
type AnswerInlineQueryOption func(params *AnswerInlineQueryParams) AnswerInlineQueryOption

// Option applies one or more AnswerInlineQueryOption values and returns the last rollback option.
func (r *AnswerInlineQueryParams) Option(opts ...AnswerInlineQueryOption) (previous AnswerInlineQueryOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithAnswerInlineQueryInlineQueryID sets the InlineQueryID field.
//
// Unique identifier for the answered query
func WithAnswerInlineQueryInlineQueryID(value string) AnswerInlineQueryOption {
	return func(params *AnswerInlineQueryParams) AnswerInlineQueryOption {
		previous := params.InlineQueryID
		params.InlineQueryID = value

		return WithAnswerInlineQueryInlineQueryID(previous)
	}
}

// WithAnswerInlineQueryResults sets the Results field.
//
// A JSON-serialized array of results for the inline query
func WithAnswerInlineQueryResults(value []InlineQueryResult) AnswerInlineQueryOption {
	return func(params *AnswerInlineQueryParams) AnswerInlineQueryOption {
		previous := params.Results
		params.Results = value

		return WithAnswerInlineQueryResults(previous)
	}
}

// WithAnswerInlineQueryCacheTime sets the CacheTime field.
//
// The maximum amount of time in seconds that the result of the inline query may be cached on the server.
// Defaults to 300.
func WithAnswerInlineQueryCacheTime(value int64) AnswerInlineQueryOption {
	return func(params *AnswerInlineQueryParams) AnswerInlineQueryOption {
		previous := params.CacheTime
		params.CacheTime = value

		return WithAnswerInlineQueryCacheTime(previous)
	}
}

// WithAnswerInlineQueryIsPersonal sets the IsPersonal field.
//
// Pass True if results may be cached on the server side only for the user that sent the query.
// By default, results may be returned to any user who sends the same query.
func WithAnswerInlineQueryIsPersonal(value bool) AnswerInlineQueryOption {
	return func(params *AnswerInlineQueryParams) AnswerInlineQueryOption {
		previous := params.IsPersonal
		params.IsPersonal = value

		return WithAnswerInlineQueryIsPersonal(previous)
	}
}

// WithAnswerInlineQueryNextOffset sets the NextOffset field.
//
// Pass the offset that a client should send in the next query with the same text to receive more results.
// Pass an empty string if there are no more results or if you don't support pagination.
// Offset length can't exceed 64 bytes.
func WithAnswerInlineQueryNextOffset(value string) AnswerInlineQueryOption {
	return func(params *AnswerInlineQueryParams) AnswerInlineQueryOption {
		previous := params.NextOffset
		params.NextOffset = value

		return WithAnswerInlineQueryNextOffset(previous)
	}
}

// WithAnswerInlineQueryButton sets the Button field.
//
// A JSON-serialized object describing a button to be shown above inline query results
func WithAnswerInlineQueryButton(value *InlineQueryResultsButton) AnswerInlineQueryOption {
	return func(params *AnswerInlineQueryParams) AnswerInlineQueryOption {
		previous := params.Button
		params.Button = value

		return WithAnswerInlineQueryButton(previous)
	}
}

// AnswerInlineQuery calls the answerInlineQuery Telegram Bot API method.
//
// Use this method to send answers to an inline query.
// On success, True is returned.
// No more than 50 results per query are allowed.
func (c *Client) AnswerInlineQuery(params *AnswerInlineQueryParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("answerInlineQuery", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// AnswerPreCheckoutQueryParams contains parameters for Client.AnswerPreCheckoutQuery.
type AnswerPreCheckoutQueryParams struct {
	// Unique identifier for the query to be answered
	PreCheckoutQueryID string `json:"pre_checkout_query_id"`

	// Specify True if everything is alright (goods are available, etc.) and the bot is ready to proceed with the order.
	// Use False if there are any problems.
	Ok bool `json:"ok"`

	// Required if ok is False.
	// Error message in human readable form that explains the reason for failure to proceed with the checkout (e.g.
	// "Sorry, somebody just bought the last of our amazing black T-shirts while you were busy filling out your payment details.
	// Please choose a different color or garment!").
	// Telegram will display this message to the user.
	ErrorMessage string `json:"error_message,omitempty"`
}

// AnswerPreCheckoutQueryOption configures AnswerPreCheckoutQueryParams.
type AnswerPreCheckoutQueryOption func(params *AnswerPreCheckoutQueryParams) AnswerPreCheckoutQueryOption

// Option applies one or more AnswerPreCheckoutQueryOption values and returns the last rollback option.
func (r *AnswerPreCheckoutQueryParams) Option(opts ...AnswerPreCheckoutQueryOption) (previous AnswerPreCheckoutQueryOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithAnswerPreCheckoutQueryPreCheckoutQueryID sets the PreCheckoutQueryID field.
//
// Unique identifier for the query to be answered
func WithAnswerPreCheckoutQueryPreCheckoutQueryID(value string) AnswerPreCheckoutQueryOption {
	return func(params *AnswerPreCheckoutQueryParams) AnswerPreCheckoutQueryOption {
		previous := params.PreCheckoutQueryID
		params.PreCheckoutQueryID = value

		return WithAnswerPreCheckoutQueryPreCheckoutQueryID(previous)
	}
}

// WithAnswerPreCheckoutQueryOk sets the Ok field.
//
// Specify True if everything is alright (goods are available, etc.) and the bot is ready to proceed with the order.
// Use False if there are any problems.
func WithAnswerPreCheckoutQueryOk(value bool) AnswerPreCheckoutQueryOption {
	return func(params *AnswerPreCheckoutQueryParams) AnswerPreCheckoutQueryOption {
		previous := params.Ok
		params.Ok = value

		return WithAnswerPreCheckoutQueryOk(previous)
	}
}

// WithAnswerPreCheckoutQueryErrorMessage sets the ErrorMessage field.
//
// Required if ok is False.
// Error message in human readable form that explains the reason for failure to proceed with the checkout (e.g.
// "Sorry, somebody just bought the last of our amazing black T-shirts while you were busy filling out your payment details.
// Please choose a different color or garment!").
// Telegram will display this message to the user.
func WithAnswerPreCheckoutQueryErrorMessage(value string) AnswerPreCheckoutQueryOption {
	return func(params *AnswerPreCheckoutQueryParams) AnswerPreCheckoutQueryOption {
		previous := params.ErrorMessage
		params.ErrorMessage = value

		return WithAnswerPreCheckoutQueryErrorMessage(previous)
	}
}

// AnswerPreCheckoutQuery calls the answerPreCheckoutQuery Telegram Bot API method.
//
// Once the user has confirmed their payment and shipping details, the Bot API sends the final confirmation in the form of an [Update] with the field pre_checkout_query.
// Use this method to respond to such pre-checkout queries.
// On success, True is returned.
// Note: The Bot API must receive an answer within 10 seconds after the pre-checkout query was sent.
//
// [Update]: https://core.telegram.org/bots/api#update
func (c *Client) AnswerPreCheckoutQuery(params *AnswerPreCheckoutQueryParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("answerPreCheckoutQuery", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// AnswerShippingQueryParams contains parameters for Client.AnswerShippingQuery.
type AnswerShippingQueryParams struct {
	// Unique identifier for the query to be answered
	ShippingQueryID string `json:"shipping_query_id"`

	// Pass True if delivery to the specified address is possible and False if there are any problems (for example, if delivery to the specified address is not possible)
	Ok bool `json:"ok"`

	// Required if ok is True.
	// A JSON-serialized array of available shipping options.
	ShippingOptions []ShippingOption `json:"shipping_options,omitempty"`

	// Required if ok is False.
	// Error message in human readable form that explains why it is impossible to complete the order (e.g.
	// “Sorry, delivery to your desired address is unavailable”).
	// Telegram will display this message to the user.
	ErrorMessage string `json:"error_message,omitempty"`
}

// AnswerShippingQueryOption configures AnswerShippingQueryParams.
type AnswerShippingQueryOption func(params *AnswerShippingQueryParams) AnswerShippingQueryOption

// Option applies one or more AnswerShippingQueryOption values and returns the last rollback option.
func (r *AnswerShippingQueryParams) Option(opts ...AnswerShippingQueryOption) (previous AnswerShippingQueryOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithAnswerShippingQueryShippingQueryID sets the ShippingQueryID field.
//
// Unique identifier for the query to be answered
func WithAnswerShippingQueryShippingQueryID(value string) AnswerShippingQueryOption {
	return func(params *AnswerShippingQueryParams) AnswerShippingQueryOption {
		previous := params.ShippingQueryID
		params.ShippingQueryID = value

		return WithAnswerShippingQueryShippingQueryID(previous)
	}
}

// WithAnswerShippingQueryOk sets the Ok field.
//
// Pass True if delivery to the specified address is possible and False if there are any problems (for example, if delivery to the specified address is not possible)
func WithAnswerShippingQueryOk(value bool) AnswerShippingQueryOption {
	return func(params *AnswerShippingQueryParams) AnswerShippingQueryOption {
		previous := params.Ok
		params.Ok = value

		return WithAnswerShippingQueryOk(previous)
	}
}

// WithAnswerShippingQueryShippingOptions sets the ShippingOptions field.
//
// Required if ok is True.
// A JSON-serialized array of available shipping options.
func WithAnswerShippingQueryShippingOptions(value []ShippingOption) AnswerShippingQueryOption {
	return func(params *AnswerShippingQueryParams) AnswerShippingQueryOption {
		previous := params.ShippingOptions
		params.ShippingOptions = value

		return WithAnswerShippingQueryShippingOptions(previous)
	}
}

// WithAnswerShippingQueryErrorMessage sets the ErrorMessage field.
//
// Required if ok is False.
// Error message in human readable form that explains why it is impossible to complete the order (e.g.
// “Sorry, delivery to your desired address is unavailable”).
// Telegram will display this message to the user.
func WithAnswerShippingQueryErrorMessage(value string) AnswerShippingQueryOption {
	return func(params *AnswerShippingQueryParams) AnswerShippingQueryOption {
		previous := params.ErrorMessage
		params.ErrorMessage = value

		return WithAnswerShippingQueryErrorMessage(previous)
	}
}

// AnswerShippingQuery calls the answerShippingQuery Telegram Bot API method.
//
// If you sent an invoice requesting a shipping address and the parameter is_flexible was specified, the Bot API will send an [Update] with a shipping_query field to the bot.
// Use this method to reply to shipping queries.
// On success, True is returned.
//
// [Update]: https://core.telegram.org/bots/api#update
func (c *Client) AnswerShippingQuery(params *AnswerShippingQueryParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("answerShippingQuery", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// AnswerWebAppQueryParams contains parameters for Client.AnswerWebAppQuery.
type AnswerWebAppQueryParams struct {
	// Unique identifier for the query to be answered
	WebAppQueryID string `json:"web_app_query_id"`

	// A JSON-serialized object describing the message to be sent
	Result InlineQueryResult `json:"result"`
}

// AnswerWebAppQueryOption configures AnswerWebAppQueryParams.
type AnswerWebAppQueryOption func(params *AnswerWebAppQueryParams) AnswerWebAppQueryOption

// Option applies one or more AnswerWebAppQueryOption values and returns the last rollback option.
func (r *AnswerWebAppQueryParams) Option(opts ...AnswerWebAppQueryOption) (previous AnswerWebAppQueryOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithAnswerWebAppQueryWebAppQueryID sets the WebAppQueryID field.
//
// Unique identifier for the query to be answered
func WithAnswerWebAppQueryWebAppQueryID(value string) AnswerWebAppQueryOption {
	return func(params *AnswerWebAppQueryParams) AnswerWebAppQueryOption {
		previous := params.WebAppQueryID
		params.WebAppQueryID = value

		return WithAnswerWebAppQueryWebAppQueryID(previous)
	}
}

// WithAnswerWebAppQueryResult sets the Result field.
//
// A JSON-serialized object describing the message to be sent
func WithAnswerWebAppQueryResult(value InlineQueryResult) AnswerWebAppQueryOption {
	return func(params *AnswerWebAppQueryParams) AnswerWebAppQueryOption {
		previous := params.Result
		params.Result = value

		return WithAnswerWebAppQueryResult(previous)
	}
}

// AnswerWebAppQuery calls the answerWebAppQuery Telegram Bot API method.
//
// Use this method to set the result of an interaction with a [Web App] and send a corresponding message on behalf of the user to the chat from which the query originated.
// On success, a [SentWebAppMessage] object is returned.
//
// [Web App]: https://core.telegram.org/bots/webapps
// [SentWebAppMessage]: https://core.telegram.org/bots/api#sentwebappmessage
func (c *Client) AnswerWebAppQuery(params *AnswerWebAppQueryParams) (ret *SentWebAppMessage, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("answerWebAppQuery", reader, contentType)
	if err != nil {
		return
	}

	ret = new(SentWebAppMessage)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// ApproveChatJoinRequestParams contains parameters for Client.ApproveChatJoinRequest.
type ApproveChatJoinRequestParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
}

// ApproveChatJoinRequestOption configures ApproveChatJoinRequestParams.
type ApproveChatJoinRequestOption func(params *ApproveChatJoinRequestParams) ApproveChatJoinRequestOption

// Option applies one or more ApproveChatJoinRequestOption values and returns the last rollback option.
func (r *ApproveChatJoinRequestParams) Option(opts ...ApproveChatJoinRequestOption) (previous ApproveChatJoinRequestOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithApproveChatJoinRequestChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithApproveChatJoinRequestChatID(value string) ApproveChatJoinRequestOption {
	return func(params *ApproveChatJoinRequestParams) ApproveChatJoinRequestOption {
		previous := params.ChatID
		params.ChatID = value

		return WithApproveChatJoinRequestChatID(previous)
	}
}

// WithApproveChatJoinRequestUserID sets the UserID field.
//
// Unique identifier of the target user
func WithApproveChatJoinRequestUserID(value int64) ApproveChatJoinRequestOption {
	return func(params *ApproveChatJoinRequestParams) ApproveChatJoinRequestOption {
		previous := params.UserID
		params.UserID = value

		return WithApproveChatJoinRequestUserID(previous)
	}
}

// ApproveChatJoinRequest calls the approveChatJoinRequest Telegram Bot API method.
//
// Use this method to approve a chat join request.
// The bot must be an administrator in the chat for this to work and must have the can_invite_users administrator right.
// Returns True on success.
func (c *Client) ApproveChatJoinRequest(params *ApproveChatJoinRequestParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("approveChatJoinRequest", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// ApproveSuggestedPostParams contains parameters for Client.ApproveSuggestedPost.
type ApproveSuggestedPostParams struct {
	// Unique identifier for the target direct messages chat
	ChatID int64 `json:"chat_id"`

	// Identifier of a suggested post message to approve
	MessageID int64 `json:"message_id"`

	// Point in time (Unix timestamp) when the post is expected to be published; omit if the date has already been specified when the suggested post was created.
	// If specified, then the date must be not more than 2678400 seconds (30 days) in the future
	SendDate int64 `json:"send_date,omitempty"`
}

// ApproveSuggestedPostOption configures ApproveSuggestedPostParams.
type ApproveSuggestedPostOption func(params *ApproveSuggestedPostParams) ApproveSuggestedPostOption

// Option applies one or more ApproveSuggestedPostOption values and returns the last rollback option.
func (r *ApproveSuggestedPostParams) Option(opts ...ApproveSuggestedPostOption) (previous ApproveSuggestedPostOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithApproveSuggestedPostChatID sets the ChatID field.
//
// Unique identifier for the target direct messages chat
func WithApproveSuggestedPostChatID(value int64) ApproveSuggestedPostOption {
	return func(params *ApproveSuggestedPostParams) ApproveSuggestedPostOption {
		previous := params.ChatID
		params.ChatID = value

		return WithApproveSuggestedPostChatID(previous)
	}
}

// WithApproveSuggestedPostMessageID sets the MessageID field.
//
// Identifier of a suggested post message to approve
func WithApproveSuggestedPostMessageID(value int64) ApproveSuggestedPostOption {
	return func(params *ApproveSuggestedPostParams) ApproveSuggestedPostOption {
		previous := params.MessageID
		params.MessageID = value

		return WithApproveSuggestedPostMessageID(previous)
	}
}

// WithApproveSuggestedPostSendDate sets the SendDate field.
//
// Point in time (Unix timestamp) when the post is expected to be published; omit if the date has already been specified when the suggested post was created.
// If specified, then the date must be not more than 2678400 seconds (30 days) in the future
func WithApproveSuggestedPostSendDate(value int64) ApproveSuggestedPostOption {
	return func(params *ApproveSuggestedPostParams) ApproveSuggestedPostOption {
		previous := params.SendDate
		params.SendDate = value

		return WithApproveSuggestedPostSendDate(previous)
	}
}

// ApproveSuggestedPost calls the approveSuggestedPost Telegram Bot API method.
//
// Use this method to approve a suggested post in a direct messages chat.
// The bot must have the 'can_post_messages' administrator right in the corresponding channel chat.
// Returns True on success.
func (c *Client) ApproveSuggestedPost(params *ApproveSuggestedPostParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("approveSuggestedPost", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// BanChatMemberParams contains parameters for Client.BanChatMember.
type BanChatMemberParams struct {
	// Unique identifier for the target group or username of the target supergroup or channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int64 `json:"user_id"`

	// Date when the user will be unbanned; Unix time.
	// If user is banned for more than 366 days or less than 30 seconds from the current time they are considered to be banned forever.
	// Applied for supergroups and channels only.
	UntilDate int64 `json:"until_date,omitempty"`

	// Pass True to delete all messages from the chat for the user that is being removed.
	// If False, the user will be able to see messages in the group that were sent before the user was removed.
	// Always True for supergroups and channels.
	RevokeMessages bool `json:"revoke_messages,omitempty"`
}

// BanChatMemberOption configures BanChatMemberParams.
type BanChatMemberOption func(params *BanChatMemberParams) BanChatMemberOption

// Option applies one or more BanChatMemberOption values and returns the last rollback option.
func (r *BanChatMemberParams) Option(opts ...BanChatMemberOption) (previous BanChatMemberOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithBanChatMemberChatID sets the ChatID field.
//
// Unique identifier for the target group or username of the target supergroup or channel (in the format @channelusername)
func WithBanChatMemberChatID(value string) BanChatMemberOption {
	return func(params *BanChatMemberParams) BanChatMemberOption {
		previous := params.ChatID
		params.ChatID = value

		return WithBanChatMemberChatID(previous)
	}
}

// WithBanChatMemberUserID sets the UserID field.
//
// Unique identifier of the target user
func WithBanChatMemberUserID(value int64) BanChatMemberOption {
	return func(params *BanChatMemberParams) BanChatMemberOption {
		previous := params.UserID
		params.UserID = value

		return WithBanChatMemberUserID(previous)
	}
}

// WithBanChatMemberUntilDate sets the UntilDate field.
//
// Date when the user will be unbanned; Unix time.
// If user is banned for more than 366 days or less than 30 seconds from the current time they are considered to be banned forever.
// Applied for supergroups and channels only.
func WithBanChatMemberUntilDate(value int64) BanChatMemberOption {
	return func(params *BanChatMemberParams) BanChatMemberOption {
		previous := params.UntilDate
		params.UntilDate = value

		return WithBanChatMemberUntilDate(previous)
	}
}

// WithBanChatMemberRevokeMessages sets the RevokeMessages field.
//
// Pass True to delete all messages from the chat for the user that is being removed.
// If False, the user will be able to see messages in the group that were sent before the user was removed.
// Always True for supergroups and channels.
func WithBanChatMemberRevokeMessages(value bool) BanChatMemberOption {
	return func(params *BanChatMemberParams) BanChatMemberOption {
		previous := params.RevokeMessages
		params.RevokeMessages = value

		return WithBanChatMemberRevokeMessages(previous)
	}
}

// BanChatMember calls the banChatMember Telegram Bot API method.
//
// Use this method to ban a user in a group, a supergroup or a channel.
// In the case of supergroups and channels, the user will not be able to return to the chat on their own using invite links, etc., unless [unbanned] first.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns True on success.
//
// [unbanned]: https://core.telegram.org/bots/api#unbanchatmember
func (c *Client) BanChatMember(params *BanChatMemberParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("banChatMember", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// BanChatSenderChatParams contains parameters for Client.BanChatSenderChat.
type BanChatSenderChatParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target sender chat
	SenderChatID int64 `json:"sender_chat_id"`
}

// BanChatSenderChatOption configures BanChatSenderChatParams.
type BanChatSenderChatOption func(params *BanChatSenderChatParams) BanChatSenderChatOption

// Option applies one or more BanChatSenderChatOption values and returns the last rollback option.
func (r *BanChatSenderChatParams) Option(opts ...BanChatSenderChatOption) (previous BanChatSenderChatOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithBanChatSenderChatChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithBanChatSenderChatChatID(value string) BanChatSenderChatOption {
	return func(params *BanChatSenderChatParams) BanChatSenderChatOption {
		previous := params.ChatID
		params.ChatID = value

		return WithBanChatSenderChatChatID(previous)
	}
}

// WithBanChatSenderChatSenderChatID sets the SenderChatID field.
//
// Unique identifier of the target sender chat
func WithBanChatSenderChatSenderChatID(value int64) BanChatSenderChatOption {
	return func(params *BanChatSenderChatParams) BanChatSenderChatOption {
		previous := params.SenderChatID
		params.SenderChatID = value

		return WithBanChatSenderChatSenderChatID(previous)
	}
}

// BanChatSenderChat calls the banChatSenderChat Telegram Bot API method.
//
// Use this method to ban a channel chat in a supergroup or a channel.
// Until the chat is [unbanned], the owner of the banned chat won't be able to send messages on behalf of any of their channels.
// The bot must be an administrator in the supergroup or channel for this to work and must have the appropriate administrator rights.
// Returns True on success.
//
// [unbanned]: https://core.telegram.org/bots/api#unbanchatsenderchat
func (c *Client) BanChatSenderChat(params *BanChatSenderChatParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("banChatSenderChat", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// CloseParams contains parameters for Client.Close.
type CloseParams struct {
}

// CloseOption configures CloseParams.
type CloseOption func(params *CloseParams) CloseOption

// Option applies one or more CloseOption values and returns the last rollback option.
func (r *CloseParams) Option(opts ...CloseOption) (previous CloseOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// Close calls the close Telegram Bot API method.
//
// Use this method to close the bot instance before moving it from one local server to another.
// You need to delete the webhook before calling this method to ensure that the bot isn't launched again after server restart.
// The method will return error 429 in the first 10 minutes after the bot is launched.
// Returns True on success.
// Requires no parameters.
func (c *Client) Close(params *CloseParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("close", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// CloseForumTopicParams contains parameters for Client.CloseForumTopic.
type CloseForumTopicParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread of the forum topic
	MessageThreadID int64 `json:"message_thread_id"`
}

// CloseForumTopicOption configures CloseForumTopicParams.
type CloseForumTopicOption func(params *CloseForumTopicParams) CloseForumTopicOption

// Option applies one or more CloseForumTopicOption values and returns the last rollback option.
func (r *CloseForumTopicParams) Option(opts ...CloseForumTopicOption) (previous CloseForumTopicOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithCloseForumTopicChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithCloseForumTopicChatID(value string) CloseForumTopicOption {
	return func(params *CloseForumTopicParams) CloseForumTopicOption {
		previous := params.ChatID
		params.ChatID = value

		return WithCloseForumTopicChatID(previous)
	}
}

// WithCloseForumTopicMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread of the forum topic
func WithCloseForumTopicMessageThreadID(value int64) CloseForumTopicOption {
	return func(params *CloseForumTopicParams) CloseForumTopicOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithCloseForumTopicMessageThreadID(previous)
	}
}

// CloseForumTopic calls the closeForumTopic Telegram Bot API method.
//
// Use this method to close an open topic in a forum supergroup chat.
// The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.
// Returns True on success.
func (c *Client) CloseForumTopic(params *CloseForumTopicParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("closeForumTopic", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// CloseGeneralForumTopicParams contains parameters for Client.CloseGeneralForumTopic.
type CloseGeneralForumTopicParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`
}

// CloseGeneralForumTopicOption configures CloseGeneralForumTopicParams.
type CloseGeneralForumTopicOption func(params *CloseGeneralForumTopicParams) CloseGeneralForumTopicOption

// Option applies one or more CloseGeneralForumTopicOption values and returns the last rollback option.
func (r *CloseGeneralForumTopicParams) Option(opts ...CloseGeneralForumTopicOption) (previous CloseGeneralForumTopicOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithCloseGeneralForumTopicChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithCloseGeneralForumTopicChatID(value string) CloseGeneralForumTopicOption {
	return func(params *CloseGeneralForumTopicParams) CloseGeneralForumTopicOption {
		previous := params.ChatID
		params.ChatID = value

		return WithCloseGeneralForumTopicChatID(previous)
	}
}

// CloseGeneralForumTopic calls the closeGeneralForumTopic Telegram Bot API method.
//
// Use this method to close an open 'General' topic in a forum supergroup chat.
// The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.
// Returns True on success.
func (c *Client) CloseGeneralForumTopic(params *CloseGeneralForumTopicParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("closeGeneralForumTopic", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// ConvertGiftToStarsParams contains parameters for Client.ConvertGiftToStars.
type ConvertGiftToStarsParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// Unique identifier of the regular gift that should be converted to Telegram Stars
	OwnedGiftID string `json:"owned_gift_id"`
}

// ConvertGiftToStarsOption configures ConvertGiftToStarsParams.
type ConvertGiftToStarsOption func(params *ConvertGiftToStarsParams) ConvertGiftToStarsOption

// Option applies one or more ConvertGiftToStarsOption values and returns the last rollback option.
func (r *ConvertGiftToStarsParams) Option(opts ...ConvertGiftToStarsOption) (previous ConvertGiftToStarsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithConvertGiftToStarsBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithConvertGiftToStarsBusinessConnectionID(value string) ConvertGiftToStarsOption {
	return func(params *ConvertGiftToStarsParams) ConvertGiftToStarsOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithConvertGiftToStarsBusinessConnectionID(previous)
	}
}

// WithConvertGiftToStarsOwnedGiftID sets the OwnedGiftID field.
//
// Unique identifier of the regular gift that should be converted to Telegram Stars
func WithConvertGiftToStarsOwnedGiftID(value string) ConvertGiftToStarsOption {
	return func(params *ConvertGiftToStarsParams) ConvertGiftToStarsOption {
		previous := params.OwnedGiftID
		params.OwnedGiftID = value

		return WithConvertGiftToStarsOwnedGiftID(previous)
	}
}

// ConvertGiftToStars calls the convertGiftToStars Telegram Bot API method.
//
// Converts a given regular gift to Telegram Stars.
// Requires the can_convert_gifts_to_stars business bot right.
// Returns True on success.
func (c *Client) ConvertGiftToStars(params *ConvertGiftToStarsParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("convertGiftToStars", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// CopyMessageParams contains parameters for Client.CopyMessage.
type CopyMessageParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Unique identifier for the chat where the original message was sent (or channel username in the format @channelusername)
	FromChatID string `json:"from_chat_id"`

	// Message identifier in the chat specified in from_chat_id
	MessageID int64 `json:"message_id"`

	// New start timestamp for the copied video in the message
	VideoStartTimestamp int64 `json:"video_start_timestamp,omitempty"`

	// New caption for media, 0-1024 characters after entities parsing.
	// If not specified, the original caption is kept
	Caption string `json:"caption,omitempty"`

	// Mode for parsing entities in the new caption.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the new caption, which can be specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Pass True, if the caption must be shown above the message media.
	// Ignored if a new caption isn't specified.
	ShowCaptionAboveMedia bool `json:"show_caption_above_media,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; only available when copying to private chats
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// CopyMessageOption configures CopyMessageParams.
type CopyMessageOption func(params *CopyMessageParams) CopyMessageOption

// Option applies one or more CopyMessageOption values and returns the last rollback option.
func (r *CopyMessageParams) Option(opts ...CopyMessageOption) (previous CopyMessageOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithCopyMessageChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithCopyMessageChatID(value string) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.ChatID
		params.ChatID = value

		return WithCopyMessageChatID(previous)
	}
}

// WithCopyMessageMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithCopyMessageMessageThreadID(value int64) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithCopyMessageMessageThreadID(previous)
	}
}

// WithCopyMessageDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithCopyMessageDirectMessagesTopicID(value int64) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithCopyMessageDirectMessagesTopicID(previous)
	}
}

// WithCopyMessageFromChatID sets the FromChatID field.
//
// Unique identifier for the chat where the original message was sent (or channel username in the format @channelusername)
func WithCopyMessageFromChatID(value string) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.FromChatID
		params.FromChatID = value

		return WithCopyMessageFromChatID(previous)
	}
}

// WithCopyMessageMessageID sets the MessageID field.
//
// Message identifier in the chat specified in from_chat_id
func WithCopyMessageMessageID(value int64) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.MessageID
		params.MessageID = value

		return WithCopyMessageMessageID(previous)
	}
}

// WithCopyMessageVideoStartTimestamp sets the VideoStartTimestamp field.
//
// New start timestamp for the copied video in the message
func WithCopyMessageVideoStartTimestamp(value int64) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.VideoStartTimestamp
		params.VideoStartTimestamp = value

		return WithCopyMessageVideoStartTimestamp(previous)
	}
}

// WithCopyMessageCaption sets the Caption field.
//
// New caption for media, 0-1024 characters after entities parsing.
// If not specified, the original caption is kept
func WithCopyMessageCaption(value string) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.Caption
		params.Caption = value

		return WithCopyMessageCaption(previous)
	}
}

// WithCopyMessageParseMode sets the ParseMode field.
//
// Mode for parsing entities in the new caption.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithCopyMessageParseMode(value string) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithCopyMessageParseMode(previous)
	}
}

// WithCopyMessageCaptionEntities sets the CaptionEntities field.
//
// A JSON-serialized list of special entities that appear in the new caption, which can be specified instead of parse_mode
func WithCopyMessageCaptionEntities(value []MessageEntity) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.CaptionEntities
		params.CaptionEntities = value

		return WithCopyMessageCaptionEntities(previous)
	}
}

// WithCopyMessageShowCaptionAboveMedia sets the ShowCaptionAboveMedia field.
//
// Pass True, if the caption must be shown above the message media.
// Ignored if a new caption isn't specified.
func WithCopyMessageShowCaptionAboveMedia(value bool) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.ShowCaptionAboveMedia
		params.ShowCaptionAboveMedia = value

		return WithCopyMessageShowCaptionAboveMedia(previous)
	}
}

// WithCopyMessageDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithCopyMessageDisableNotification(value bool) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithCopyMessageDisableNotification(previous)
	}
}

// WithCopyMessageProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithCopyMessageProtectContent(value bool) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithCopyMessageProtectContent(previous)
	}
}

// WithCopyMessageAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithCopyMessageAllowPaidBroadcast(value bool) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithCopyMessageAllowPaidBroadcast(previous)
	}
}

// WithCopyMessageMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; only available when copying to private chats
func WithCopyMessageMessageEffectID(value string) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithCopyMessageMessageEffectID(previous)
	}
}

// WithCopyMessageSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithCopyMessageSuggestedPostParameters(value *SuggestedPostParameters) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithCopyMessageSuggestedPostParameters(previous)
	}
}

// WithCopyMessageReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithCopyMessageReplyParameters(value *ReplyParameters) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithCopyMessageReplyParameters(previous)
	}
}

// WithCopyMessageReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithCopyMessageReplyMarkup(value *ReplyMarkup) CopyMessageOption {
	return func(params *CopyMessageParams) CopyMessageOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithCopyMessageReplyMarkup(previous)
	}
}

// CopyMessage calls the copyMessage Telegram Bot API method.
//
// Use this method to copy messages of any kind.
// Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied.
// A quiz [poll] can be copied only if the value of the field correct_option_id is known to the bot.
// The method is analogous to the method [forwardMessage], but the copied message doesn't have a link to the original message.
// Returns the [MessageId] of the sent message on success.
//
// [poll]: https://core.telegram.org/bots/api#poll
// [forwardMessage]: https://core.telegram.org/bots/api#forwardmessage
// [MessageId]: https://core.telegram.org/bots/api#messageid
func (c *Client) CopyMessage(params *CopyMessageParams) (ret *MessageId, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("copyMessage", reader, contentType)
	if err != nil {
		return
	}

	ret = new(MessageId)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// CopyMessagesParams contains parameters for Client.CopyMessages.
type CopyMessagesParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the messages will be sent; required if the messages are sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Unique identifier for the chat where the original messages were sent (or channel username in the format @channelusername)
	FromChatID string `json:"from_chat_id"`

	// A JSON-serialized list of 1-100 identifiers of messages in the chat from_chat_id to copy.
	// The identifiers must be specified in a strictly increasing order.
	MessageIDs []int64 `json:"message_ids"`

	// Sends the messages [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent messages from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to copy the messages without their captions
	RemoveCaption bool `json:"remove_caption,omitempty"`
}

// CopyMessagesOption configures CopyMessagesParams.
type CopyMessagesOption func(params *CopyMessagesParams) CopyMessagesOption

// Option applies one or more CopyMessagesOption values and returns the last rollback option.
func (r *CopyMessagesParams) Option(opts ...CopyMessagesOption) (previous CopyMessagesOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithCopyMessagesChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithCopyMessagesChatID(value string) CopyMessagesOption {
	return func(params *CopyMessagesParams) CopyMessagesOption {
		previous := params.ChatID
		params.ChatID = value

		return WithCopyMessagesChatID(previous)
	}
}

// WithCopyMessagesMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithCopyMessagesMessageThreadID(value int64) CopyMessagesOption {
	return func(params *CopyMessagesParams) CopyMessagesOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithCopyMessagesMessageThreadID(previous)
	}
}

// WithCopyMessagesDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the messages will be sent; required if the messages are sent to a direct messages chat
func WithCopyMessagesDirectMessagesTopicID(value int64) CopyMessagesOption {
	return func(params *CopyMessagesParams) CopyMessagesOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithCopyMessagesDirectMessagesTopicID(previous)
	}
}

// WithCopyMessagesFromChatID sets the FromChatID field.
//
// Unique identifier for the chat where the original messages were sent (or channel username in the format @channelusername)
func WithCopyMessagesFromChatID(value string) CopyMessagesOption {
	return func(params *CopyMessagesParams) CopyMessagesOption {
		previous := params.FromChatID
		params.FromChatID = value

		return WithCopyMessagesFromChatID(previous)
	}
}

// WithCopyMessagesMessageIDs sets the MessageIDs field.
//
// A JSON-serialized list of 1-100 identifiers of messages in the chat from_chat_id to copy.
// The identifiers must be specified in a strictly increasing order.
func WithCopyMessagesMessageIDs(value []int64) CopyMessagesOption {
	return func(params *CopyMessagesParams) CopyMessagesOption {
		previous := params.MessageIDs
		params.MessageIDs = value

		return WithCopyMessagesMessageIDs(previous)
	}
}

// WithCopyMessagesDisableNotification sets the DisableNotification field.
//
// Sends the messages [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithCopyMessagesDisableNotification(value bool) CopyMessagesOption {
	return func(params *CopyMessagesParams) CopyMessagesOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithCopyMessagesDisableNotification(previous)
	}
}

// WithCopyMessagesProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent messages from forwarding and saving
func WithCopyMessagesProtectContent(value bool) CopyMessagesOption {
	return func(params *CopyMessagesParams) CopyMessagesOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithCopyMessagesProtectContent(previous)
	}
}

// WithCopyMessagesRemoveCaption sets the RemoveCaption field.
//
// Pass True to copy the messages without their captions
func WithCopyMessagesRemoveCaption(value bool) CopyMessagesOption {
	return func(params *CopyMessagesParams) CopyMessagesOption {
		previous := params.RemoveCaption
		params.RemoveCaption = value

		return WithCopyMessagesRemoveCaption(previous)
	}
}

// CopyMessages calls the copyMessages Telegram Bot API method.
//
// Use this method to copy messages of any kind.
// If some of the specified messages can't be found or copied, they are skipped.
// Service messages, paid media messages, giveaway messages, giveaway winners messages, and invoice messages can't be copied.
// A quiz [poll] can be copied only if the value of the field correct_option_id is known to the bot.
// The method is analogous to the method [forwardMessages], but the copied messages don't have a link to the original message.
// Album grouping is kept for copied messages.
// On success, an array of [MessageId] of the sent messages is returned.
//
// [poll]: https://core.telegram.org/bots/api#poll
// [forwardMessages]: https://core.telegram.org/bots/api#forwardmessages
// [MessageId]: https://core.telegram.org/bots/api#messageid
func (c *Client) CopyMessages(params *CopyMessagesParams) (ret *MessageId, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("copyMessages", reader, contentType)
	if err != nil {
		return
	}

	ret = new(MessageId)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// CreateChatInviteLinkParams contains parameters for Client.CreateChatInviteLink.
type CreateChatInviteLinkParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Invite link name; 0-32 characters
	Name string `json:"name,omitempty"`

	// Point in time (Unix timestamp) when the link will expire
	ExpireDate int64 `json:"expire_date,omitempty"`

	// The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999
	MemberLimit int64 `json:"member_limit,omitempty"`

	// True, if users joining the chat via the link need to be approved by chat administrators.
	// If True, member_limit can't be specified
	CreatesJoinRequest bool `json:"creates_join_request,omitempty"`
}

// CreateChatInviteLinkOption configures CreateChatInviteLinkParams.
type CreateChatInviteLinkOption func(params *CreateChatInviteLinkParams) CreateChatInviteLinkOption

// Option applies one or more CreateChatInviteLinkOption values and returns the last rollback option.
func (r *CreateChatInviteLinkParams) Option(opts ...CreateChatInviteLinkOption) (previous CreateChatInviteLinkOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithCreateChatInviteLinkChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithCreateChatInviteLinkChatID(value string) CreateChatInviteLinkOption {
	return func(params *CreateChatInviteLinkParams) CreateChatInviteLinkOption {
		previous := params.ChatID
		params.ChatID = value

		return WithCreateChatInviteLinkChatID(previous)
	}
}

// WithCreateChatInviteLinkName sets the Name field.
//
// Invite link name; 0-32 characters
func WithCreateChatInviteLinkName(value string) CreateChatInviteLinkOption {
	return func(params *CreateChatInviteLinkParams) CreateChatInviteLinkOption {
		previous := params.Name
		params.Name = value

		return WithCreateChatInviteLinkName(previous)
	}
}

// WithCreateChatInviteLinkExpireDate sets the ExpireDate field.
//
// Point in time (Unix timestamp) when the link will expire
func WithCreateChatInviteLinkExpireDate(value int64) CreateChatInviteLinkOption {
	return func(params *CreateChatInviteLinkParams) CreateChatInviteLinkOption {
		previous := params.ExpireDate
		params.ExpireDate = value

		return WithCreateChatInviteLinkExpireDate(previous)
	}
}

// WithCreateChatInviteLinkMemberLimit sets the MemberLimit field.
//
// The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999
func WithCreateChatInviteLinkMemberLimit(value int64) CreateChatInviteLinkOption {
	return func(params *CreateChatInviteLinkParams) CreateChatInviteLinkOption {
		previous := params.MemberLimit
		params.MemberLimit = value

		return WithCreateChatInviteLinkMemberLimit(previous)
	}
}

// WithCreateChatInviteLinkCreatesJoinRequest sets the CreatesJoinRequest field.
//
// True, if users joining the chat via the link need to be approved by chat administrators.
// If True, member_limit can't be specified
func WithCreateChatInviteLinkCreatesJoinRequest(value bool) CreateChatInviteLinkOption {
	return func(params *CreateChatInviteLinkParams) CreateChatInviteLinkOption {
		previous := params.CreatesJoinRequest
		params.CreatesJoinRequest = value

		return WithCreateChatInviteLinkCreatesJoinRequest(previous)
	}
}

// CreateChatInviteLink calls the createChatInviteLink Telegram Bot API method.
//
// Use this method to create an additional invite link for a chat.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// The link can be revoked using the method [revokeChatInviteLink].
// Returns the new invite link as [ChatInviteLink] object.
//
// [revokeChatInviteLink]: https://core.telegram.org/bots/api#revokechatinvitelink
// [ChatInviteLink]: https://core.telegram.org/bots/api#chatinvitelink
func (c *Client) CreateChatInviteLink(params *CreateChatInviteLinkParams) (ret *ChatInviteLink, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("createChatInviteLink", reader, contentType)
	if err != nil {
		return
	}

	ret = new(ChatInviteLink)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// CreateChatSubscriptionInviteLinkParams contains parameters for Client.CreateChatSubscriptionInviteLink.
type CreateChatSubscriptionInviteLinkParams struct {
	// Unique identifier for the target channel chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Invite link name; 0-32 characters
	Name string `json:"name,omitempty"`

	// The number of seconds the subscription will be active for before the next payment.
	// Currently, it must always be 2592000 (30 days).
	SubscriptionPeriod int64 `json:"subscription_period"`

	// The amount of Telegram Stars a user must pay initially and after each subsequent subscription period to be a member of the chat; 1-10000
	SubscriptionPrice int64 `json:"subscription_price"`
}

// CreateChatSubscriptionInviteLinkOption configures CreateChatSubscriptionInviteLinkParams.
type CreateChatSubscriptionInviteLinkOption func(params *CreateChatSubscriptionInviteLinkParams) CreateChatSubscriptionInviteLinkOption

// Option applies one or more CreateChatSubscriptionInviteLinkOption values and returns the last rollback option.
func (r *CreateChatSubscriptionInviteLinkParams) Option(opts ...CreateChatSubscriptionInviteLinkOption) (previous CreateChatSubscriptionInviteLinkOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithCreateChatSubscriptionInviteLinkChatID sets the ChatID field.
//
// Unique identifier for the target channel chat or username of the target channel (in the format @channelusername)
func WithCreateChatSubscriptionInviteLinkChatID(value string) CreateChatSubscriptionInviteLinkOption {
	return func(params *CreateChatSubscriptionInviteLinkParams) CreateChatSubscriptionInviteLinkOption {
		previous := params.ChatID
		params.ChatID = value

		return WithCreateChatSubscriptionInviteLinkChatID(previous)
	}
}

// WithCreateChatSubscriptionInviteLinkName sets the Name field.
//
// Invite link name; 0-32 characters
func WithCreateChatSubscriptionInviteLinkName(value string) CreateChatSubscriptionInviteLinkOption {
	return func(params *CreateChatSubscriptionInviteLinkParams) CreateChatSubscriptionInviteLinkOption {
		previous := params.Name
		params.Name = value

		return WithCreateChatSubscriptionInviteLinkName(previous)
	}
}

// WithCreateChatSubscriptionInviteLinkSubscriptionPeriod sets the SubscriptionPeriod field.
//
// The number of seconds the subscription will be active for before the next payment.
// Currently, it must always be 2592000 (30 days).
func WithCreateChatSubscriptionInviteLinkSubscriptionPeriod(value int64) CreateChatSubscriptionInviteLinkOption {
	return func(params *CreateChatSubscriptionInviteLinkParams) CreateChatSubscriptionInviteLinkOption {
		previous := params.SubscriptionPeriod
		params.SubscriptionPeriod = value

		return WithCreateChatSubscriptionInviteLinkSubscriptionPeriod(previous)
	}
}

// WithCreateChatSubscriptionInviteLinkSubscriptionPrice sets the SubscriptionPrice field.
//
// The amount of Telegram Stars a user must pay initially and after each subsequent subscription period to be a member of the chat; 1-10000
func WithCreateChatSubscriptionInviteLinkSubscriptionPrice(value int64) CreateChatSubscriptionInviteLinkOption {
	return func(params *CreateChatSubscriptionInviteLinkParams) CreateChatSubscriptionInviteLinkOption {
		previous := params.SubscriptionPrice
		params.SubscriptionPrice = value

		return WithCreateChatSubscriptionInviteLinkSubscriptionPrice(previous)
	}
}

// CreateChatSubscriptionInviteLink calls the createChatSubscriptionInviteLink Telegram Bot API method.
//
// Use this method to create a [subscription invite link] for a channel chat.
// The bot must have the can_invite_users administrator rights.
// The link can be edited using the method [editChatSubscriptionInviteLink] or revoked using the method [revokeChatInviteLink].
// Returns the new invite link as a [ChatInviteLink] object.
//
// [subscription invite link]: https://telegram.org/blog/superchannels-star-reactions-subscriptions#star-subscriptions
// [editChatSubscriptionInviteLink]: https://core.telegram.org/bots/api#editchatsubscriptioninvitelink
// [revokeChatInviteLink]: https://core.telegram.org/bots/api#revokechatinvitelink
// [ChatInviteLink]: https://core.telegram.org/bots/api#chatinvitelink
func (c *Client) CreateChatSubscriptionInviteLink(params *CreateChatSubscriptionInviteLinkParams) (ret *ChatInviteLink, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("createChatSubscriptionInviteLink", reader, contentType)
	if err != nil {
		return
	}

	ret = new(ChatInviteLink)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// CreateForumTopicParams contains parameters for Client.CreateForumTopic.
type CreateForumTopicParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Topic name, 1-128 characters
	Name string `json:"name"`

	// Color of the topic icon in RGB format.
	// Currently, must be one of 7322096 (0x6FB9F0), 16766590 (0xFFD67E), 13338331 (0xCB86DB), 9367192 (0x8EEE98), 16749490 (0xFF93B2), or 16478047 (0xFB6F5F)
	IconColor int64 `json:"icon_color,omitempty"`

	// Unique identifier of the custom emoji shown as the topic icon.
	// Use [getForumTopicIconStickers] to get all allowed custom emoji identifiers.
	//
	// [getForumTopicIconStickers]: https://core.telegram.org/bots/api#getforumtopiciconstickers
	IconCustomEmojiID string `json:"icon_custom_emoji_id,omitempty"`
}

// CreateForumTopicOption configures CreateForumTopicParams.
type CreateForumTopicOption func(params *CreateForumTopicParams) CreateForumTopicOption

// Option applies one or more CreateForumTopicOption values and returns the last rollback option.
func (r *CreateForumTopicParams) Option(opts ...CreateForumTopicOption) (previous CreateForumTopicOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithCreateForumTopicChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithCreateForumTopicChatID(value string) CreateForumTopicOption {
	return func(params *CreateForumTopicParams) CreateForumTopicOption {
		previous := params.ChatID
		params.ChatID = value

		return WithCreateForumTopicChatID(previous)
	}
}

// WithCreateForumTopicName sets the Name field.
//
// Topic name, 1-128 characters
func WithCreateForumTopicName(value string) CreateForumTopicOption {
	return func(params *CreateForumTopicParams) CreateForumTopicOption {
		previous := params.Name
		params.Name = value

		return WithCreateForumTopicName(previous)
	}
}

// WithCreateForumTopicIconColor sets the IconColor field.
//
// Color of the topic icon in RGB format.
// Currently, must be one of 7322096 (0x6FB9F0), 16766590 (0xFFD67E), 13338331 (0xCB86DB), 9367192 (0x8EEE98), 16749490 (0xFF93B2), or 16478047 (0xFB6F5F)
func WithCreateForumTopicIconColor(value int64) CreateForumTopicOption {
	return func(params *CreateForumTopicParams) CreateForumTopicOption {
		previous := params.IconColor
		params.IconColor = value

		return WithCreateForumTopicIconColor(previous)
	}
}

// WithCreateForumTopicIconCustomEmojiID sets the IconCustomEmojiID field.
//
// Unique identifier of the custom emoji shown as the topic icon.
// Use [getForumTopicIconStickers] to get all allowed custom emoji identifiers.
//
// [getForumTopicIconStickers]: https://core.telegram.org/bots/api#getforumtopiciconstickers
func WithCreateForumTopicIconCustomEmojiID(value string) CreateForumTopicOption {
	return func(params *CreateForumTopicParams) CreateForumTopicOption {
		previous := params.IconCustomEmojiID
		params.IconCustomEmojiID = value

		return WithCreateForumTopicIconCustomEmojiID(previous)
	}
}

// CreateForumTopic calls the createForumTopic Telegram Bot API method.
//
// Use this method to create a topic in a forum supergroup chat or a private chat with a user.
// In the case of a supergroup chat the bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator right.
// Returns information about the created topic as a [ForumTopic] object.
//
// [ForumTopic]: https://core.telegram.org/bots/api#forumtopic
func (c *Client) CreateForumTopic(params *CreateForumTopicParams) (ret *ForumTopic, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("createForumTopic", reader, contentType)
	if err != nil {
		return
	}

	ret = new(ForumTopic)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// CreateInvoiceLinkParams contains parameters for Client.CreateInvoiceLink.
type CreateInvoiceLinkParams struct {
	// Unique identifier of the business connection on behalf of which the link will be created.
	// For payments in [Telegram Stars] only.
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Product name, 1-32 characters
	Title string `json:"title"`

	// Product description, 1-255 characters
	Description string `json:"description"`

	// Bot-defined invoice payload, 1-128 bytes.
	// This will not be displayed to the user, use it for your internal processes.
	Payload string `json:"payload"`

	// Payment provider token, obtained via [@BotFather].
	// Pass an empty string for payments in [Telegram Stars].
	//
	// [@BotFather]: https://t.me/botfather
	// [Telegram Stars]: https://t.me/BotNews/90
	ProviderToken string `json:"provider_token,omitempty"`

	// Three-letter ISO 4217 currency code, see [more on currencies].
	// Pass “XTR” for payments in [Telegram Stars].
	//
	// [more on currencies]: https://core.telegram.org/bots/payments#supported-currencies
	// [Telegram Stars]: https://t.me/BotNews/90
	Currency string `json:"currency"`

	// Price breakdown, a JSON-serialized list of components (e.g.
	// product price, tax, discount, delivery cost, delivery tax, bonus, etc.).
	// Must contain exactly one item for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	Prices []LabeledPrice `json:"prices"`

	// The number of seconds the subscription will be active for before the next payment.
	// The currency must be set to “XTR” (Telegram Stars) if the parameter is used.
	// Currently, it must always be 2592000 (30 days) if specified.
	// Any number of subscriptions can be active for a given bot at the same time, including multiple concurrent subscriptions from the same user.
	// Subscription price must no exceed 10000 Telegram Stars.
	SubscriptionPeriod int64 `json:"subscription_period,omitempty"`

	// The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double).
	// For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145.
	// See the exp parameter in [currencies.json], it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).
	// Defaults to 0.
	// Not supported for payments in [Telegram Stars].
	//
	// [currencies.json]: https://core.telegram.org/bots/payments/currencies.json
	// [Telegram Stars]: https://t.me/BotNews/90
	MaxTipAmount int64 `json:"max_tip_amount,omitempty"`

	// A JSON-serialized array of suggested amounts of tips in the smallest units of the currency (integer, not float/double).
	// At most 4 suggested tip amounts can be specified.
	// The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount.
	SuggestedTipAmounts []int64 `json:"suggested_tip_amounts,omitempty"`

	// JSON-serialized data about the invoice, which will be shared with the payment provider.
	// A detailed description of required fields should be provided by the payment provider.
	ProviderData string `json:"provider_data,omitempty"`

	// URL of the product photo for the invoice.
	// Can be a photo of the goods or a marketing image for a service.
	PhotoUrl string `json:"photo_url,omitempty"`

	// Photo size in bytes
	PhotoSize int64 `json:"photo_size,omitempty"`

	// Photo width
	PhotoWidth int64 `json:"photo_width,omitempty"`

	// Photo height
	PhotoHeight int64 `json:"photo_height,omitempty"`

	// Pass True if you require the user's full name to complete the order.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	NeedName bool `json:"need_name,omitempty"`

	// Pass True if you require the user's phone number to complete the order.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	NeedPhoneNumber bool `json:"need_phone_number,omitempty"`

	// Pass True if you require the user's email address to complete the order.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	NeedEmail bool `json:"need_email,omitempty"`

	// Pass True if you require the user's shipping address to complete the order.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	NeedShippingAddress bool `json:"need_shipping_address,omitempty"`

	// Pass True if the user's phone number should be sent to the provider.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	SendPhoneNumberToProvider bool `json:"send_phone_number_to_provider,omitempty"`

	// Pass True if the user's email address should be sent to the provider.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	SendEmailToProvider bool `json:"send_email_to_provider,omitempty"`

	// Pass True if the final price depends on the shipping method.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	IsFlexible bool `json:"is_flexible,omitempty"`
}

// CreateInvoiceLinkOption configures CreateInvoiceLinkParams.
type CreateInvoiceLinkOption func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption

// Option applies one or more CreateInvoiceLinkOption values and returns the last rollback option.
func (r *CreateInvoiceLinkParams) Option(opts ...CreateInvoiceLinkOption) (previous CreateInvoiceLinkOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithCreateInvoiceLinkBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the link will be created.
// For payments in [Telegram Stars] only.
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkBusinessConnectionID(value string) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithCreateInvoiceLinkBusinessConnectionID(previous)
	}
}

// WithCreateInvoiceLinkTitle sets the Title field.
//
// Product name, 1-32 characters
func WithCreateInvoiceLinkTitle(value string) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.Title
		params.Title = value

		return WithCreateInvoiceLinkTitle(previous)
	}
}

// WithCreateInvoiceLinkDescription sets the Description field.
//
// Product description, 1-255 characters
func WithCreateInvoiceLinkDescription(value string) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.Description
		params.Description = value

		return WithCreateInvoiceLinkDescription(previous)
	}
}

// WithCreateInvoiceLinkPayload sets the Payload field.
//
// Bot-defined invoice payload, 1-128 bytes.
// This will not be displayed to the user, use it for your internal processes.
func WithCreateInvoiceLinkPayload(value string) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.Payload
		params.Payload = value

		return WithCreateInvoiceLinkPayload(previous)
	}
}

// WithCreateInvoiceLinkProviderToken sets the ProviderToken field.
//
// Payment provider token, obtained via [@BotFather].
// Pass an empty string for payments in [Telegram Stars].
//
// [@BotFather]: https://t.me/botfather
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkProviderToken(value string) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.ProviderToken
		params.ProviderToken = value

		return WithCreateInvoiceLinkProviderToken(previous)
	}
}

// WithCreateInvoiceLinkCurrency sets the Currency field.
//
// Three-letter ISO 4217 currency code, see [more on currencies].
// Pass “XTR” for payments in [Telegram Stars].
//
// [more on currencies]: https://core.telegram.org/bots/payments#supported-currencies
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkCurrency(value string) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.Currency
		params.Currency = value

		return WithCreateInvoiceLinkCurrency(previous)
	}
}

// WithCreateInvoiceLinkPrices sets the Prices field.
//
// Price breakdown, a JSON-serialized list of components (e.g.
// product price, tax, discount, delivery cost, delivery tax, bonus, etc.).
// Must contain exactly one item for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkPrices(value []LabeledPrice) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.Prices
		params.Prices = value

		return WithCreateInvoiceLinkPrices(previous)
	}
}

// WithCreateInvoiceLinkSubscriptionPeriod sets the SubscriptionPeriod field.
//
// The number of seconds the subscription will be active for before the next payment.
// The currency must be set to “XTR” (Telegram Stars) if the parameter is used.
// Currently, it must always be 2592000 (30 days) if specified.
// Any number of subscriptions can be active for a given bot at the same time, including multiple concurrent subscriptions from the same user.
// Subscription price must no exceed 10000 Telegram Stars.
func WithCreateInvoiceLinkSubscriptionPeriod(value int64) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.SubscriptionPeriod
		params.SubscriptionPeriod = value

		return WithCreateInvoiceLinkSubscriptionPeriod(previous)
	}
}

// WithCreateInvoiceLinkMaxTipAmount sets the MaxTipAmount field.
//
// The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double).
// For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145.
// See the exp parameter in [currencies.json], it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).
// Defaults to 0.
// Not supported for payments in [Telegram Stars].
//
// [currencies.json]: https://core.telegram.org/bots/payments/currencies.json
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkMaxTipAmount(value int64) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.MaxTipAmount
		params.MaxTipAmount = value

		return WithCreateInvoiceLinkMaxTipAmount(previous)
	}
}

// WithCreateInvoiceLinkSuggestedTipAmounts sets the SuggestedTipAmounts field.
//
// A JSON-serialized array of suggested amounts of tips in the smallest units of the currency (integer, not float/double).
// At most 4 suggested tip amounts can be specified.
// The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount.
func WithCreateInvoiceLinkSuggestedTipAmounts(value []int64) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.SuggestedTipAmounts
		params.SuggestedTipAmounts = value

		return WithCreateInvoiceLinkSuggestedTipAmounts(previous)
	}
}

// WithCreateInvoiceLinkProviderData sets the ProviderData field.
//
// JSON-serialized data about the invoice, which will be shared with the payment provider.
// A detailed description of required fields should be provided by the payment provider.
func WithCreateInvoiceLinkProviderData(value string) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.ProviderData
		params.ProviderData = value

		return WithCreateInvoiceLinkProviderData(previous)
	}
}

// WithCreateInvoiceLinkPhotoUrl sets the PhotoUrl field.
//
// URL of the product photo for the invoice.
// Can be a photo of the goods or a marketing image for a service.
func WithCreateInvoiceLinkPhotoUrl(value string) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.PhotoUrl
		params.PhotoUrl = value

		return WithCreateInvoiceLinkPhotoUrl(previous)
	}
}

// WithCreateInvoiceLinkPhotoSize sets the PhotoSize field.
//
// Photo size in bytes
func WithCreateInvoiceLinkPhotoSize(value int64) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.PhotoSize
		params.PhotoSize = value

		return WithCreateInvoiceLinkPhotoSize(previous)
	}
}

// WithCreateInvoiceLinkPhotoWidth sets the PhotoWidth field.
//
// Photo width
func WithCreateInvoiceLinkPhotoWidth(value int64) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.PhotoWidth
		params.PhotoWidth = value

		return WithCreateInvoiceLinkPhotoWidth(previous)
	}
}

// WithCreateInvoiceLinkPhotoHeight sets the PhotoHeight field.
//
// Photo height
func WithCreateInvoiceLinkPhotoHeight(value int64) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.PhotoHeight
		params.PhotoHeight = value

		return WithCreateInvoiceLinkPhotoHeight(previous)
	}
}

// WithCreateInvoiceLinkNeedName sets the NeedName field.
//
// Pass True if you require the user's full name to complete the order.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkNeedName(value bool) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.NeedName
		params.NeedName = value

		return WithCreateInvoiceLinkNeedName(previous)
	}
}

// WithCreateInvoiceLinkNeedPhoneNumber sets the NeedPhoneNumber field.
//
// Pass True if you require the user's phone number to complete the order.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkNeedPhoneNumber(value bool) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.NeedPhoneNumber
		params.NeedPhoneNumber = value

		return WithCreateInvoiceLinkNeedPhoneNumber(previous)
	}
}

// WithCreateInvoiceLinkNeedEmail sets the NeedEmail field.
//
// Pass True if you require the user's email address to complete the order.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkNeedEmail(value bool) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.NeedEmail
		params.NeedEmail = value

		return WithCreateInvoiceLinkNeedEmail(previous)
	}
}

// WithCreateInvoiceLinkNeedShippingAddress sets the NeedShippingAddress field.
//
// Pass True if you require the user's shipping address to complete the order.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkNeedShippingAddress(value bool) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.NeedShippingAddress
		params.NeedShippingAddress = value

		return WithCreateInvoiceLinkNeedShippingAddress(previous)
	}
}

// WithCreateInvoiceLinkSendPhoneNumberToProvider sets the SendPhoneNumberToProvider field.
//
// Pass True if the user's phone number should be sent to the provider.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkSendPhoneNumberToProvider(value bool) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.SendPhoneNumberToProvider
		params.SendPhoneNumberToProvider = value

		return WithCreateInvoiceLinkSendPhoneNumberToProvider(previous)
	}
}

// WithCreateInvoiceLinkSendEmailToProvider sets the SendEmailToProvider field.
//
// Pass True if the user's email address should be sent to the provider.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkSendEmailToProvider(value bool) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.SendEmailToProvider
		params.SendEmailToProvider = value

		return WithCreateInvoiceLinkSendEmailToProvider(previous)
	}
}

// WithCreateInvoiceLinkIsFlexible sets the IsFlexible field.
//
// Pass True if the final price depends on the shipping method.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithCreateInvoiceLinkIsFlexible(value bool) CreateInvoiceLinkOption {
	return func(params *CreateInvoiceLinkParams) CreateInvoiceLinkOption {
		previous := params.IsFlexible
		params.IsFlexible = value

		return WithCreateInvoiceLinkIsFlexible(previous)
	}
}

// CreateInvoiceLink calls the createInvoiceLink Telegram Bot API method.
//
// Use this method to create a link for an invoice.
// Returns the created invoice link as String on success.
func (c *Client) CreateInvoiceLink(params *CreateInvoiceLinkParams) (ret string, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("createInvoiceLink", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// CreateNewStickerSetParams contains parameters for Client.CreateNewStickerSet.
type CreateNewStickerSetParams struct {
	// User identifier of created sticker set owner
	UserID int64 `json:"user_id"`

	// Short name of sticker set, to be used in t.me/addstickers/ URLs (e.g., animals).
	// Can contain only English letters, digits and underscores.
	// Must begin with a letter, can't contain consecutive underscores and must end in "_by_<bot_username>".
	// <bot_username> is case insensitive.
	// 1-64 characters.
	Name string `json:"name"`

	// Sticker set title, 1-64 characters
	Title string `json:"title"`

	// A JSON-serialized list of 1-50 initial stickers to be added to the sticker set
	Stickers []InputSticker `json:"stickers"`

	// Type of stickers in the set, pass “regular”, “mask”, or “custom_emoji”.
	// By default, a regular sticker set is created.
	StickerType string `json:"sticker_type,omitempty"`

	// Pass True if stickers in the sticker set must be repainted to the color of text when used in messages, the accent color if used as emoji status, white on chat photos, or another appropriate color based on context; for custom emoji sticker sets only
	NeedsRepainting bool `json:"needs_repainting,omitempty"`
}

// CreateNewStickerSetOption configures CreateNewStickerSetParams.
type CreateNewStickerSetOption func(params *CreateNewStickerSetParams) CreateNewStickerSetOption

// Option applies one or more CreateNewStickerSetOption values and returns the last rollback option.
func (r *CreateNewStickerSetParams) Option(opts ...CreateNewStickerSetOption) (previous CreateNewStickerSetOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithCreateNewStickerSetUserID sets the UserID field.
//
// User identifier of created sticker set owner
func WithCreateNewStickerSetUserID(value int64) CreateNewStickerSetOption {
	return func(params *CreateNewStickerSetParams) CreateNewStickerSetOption {
		previous := params.UserID
		params.UserID = value

		return WithCreateNewStickerSetUserID(previous)
	}
}

// WithCreateNewStickerSetName sets the Name field.
//
// Short name of sticker set, to be used in t.me/addstickers/ URLs (e.g., animals).
// Can contain only English letters, digits and underscores.
// Must begin with a letter, can't contain consecutive underscores and must end in "_by_<bot_username>".
// <bot_username> is case insensitive.
// 1-64 characters.
func WithCreateNewStickerSetName(value string) CreateNewStickerSetOption {
	return func(params *CreateNewStickerSetParams) CreateNewStickerSetOption {
		previous := params.Name
		params.Name = value

		return WithCreateNewStickerSetName(previous)
	}
}

// WithCreateNewStickerSetTitle sets the Title field.
//
// Sticker set title, 1-64 characters
func WithCreateNewStickerSetTitle(value string) CreateNewStickerSetOption {
	return func(params *CreateNewStickerSetParams) CreateNewStickerSetOption {
		previous := params.Title
		params.Title = value

		return WithCreateNewStickerSetTitle(previous)
	}
}

// WithCreateNewStickerSetStickers sets the Stickers field.
//
// A JSON-serialized list of 1-50 initial stickers to be added to the sticker set
func WithCreateNewStickerSetStickers(value []InputSticker) CreateNewStickerSetOption {
	return func(params *CreateNewStickerSetParams) CreateNewStickerSetOption {
		previous := params.Stickers
		params.Stickers = value

		return WithCreateNewStickerSetStickers(previous)
	}
}

// WithCreateNewStickerSetStickerType sets the StickerType field.
//
// Type of stickers in the set, pass “regular”, “mask”, or “custom_emoji”.
// By default, a regular sticker set is created.
func WithCreateNewStickerSetStickerType(value string) CreateNewStickerSetOption {
	return func(params *CreateNewStickerSetParams) CreateNewStickerSetOption {
		previous := params.StickerType
		params.StickerType = value

		return WithCreateNewStickerSetStickerType(previous)
	}
}

// WithCreateNewStickerSetNeedsRepainting sets the NeedsRepainting field.
//
// Pass True if stickers in the sticker set must be repainted to the color of text when used in messages, the accent color if used as emoji status, white on chat photos, or another appropriate color based on context; for custom emoji sticker sets only
func WithCreateNewStickerSetNeedsRepainting(value bool) CreateNewStickerSetOption {
	return func(params *CreateNewStickerSetParams) CreateNewStickerSetOption {
		previous := params.NeedsRepainting
		params.NeedsRepainting = value

		return WithCreateNewStickerSetNeedsRepainting(previous)
	}
}

// CreateNewStickerSet calls the createNewStickerSet Telegram Bot API method.
//
// Use this method to create a new sticker set owned by a user.
// The bot will be able to edit the sticker set thus created.
// Returns True on success.
func (c *Client) CreateNewStickerSet(params *CreateNewStickerSetParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("createNewStickerSet", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeclineChatJoinRequestParams contains parameters for Client.DeclineChatJoinRequest.
type DeclineChatJoinRequestParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
}

// DeclineChatJoinRequestOption configures DeclineChatJoinRequestParams.
type DeclineChatJoinRequestOption func(params *DeclineChatJoinRequestParams) DeclineChatJoinRequestOption

// Option applies one or more DeclineChatJoinRequestOption values and returns the last rollback option.
func (r *DeclineChatJoinRequestParams) Option(opts ...DeclineChatJoinRequestOption) (previous DeclineChatJoinRequestOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeclineChatJoinRequestChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithDeclineChatJoinRequestChatID(value string) DeclineChatJoinRequestOption {
	return func(params *DeclineChatJoinRequestParams) DeclineChatJoinRequestOption {
		previous := params.ChatID
		params.ChatID = value

		return WithDeclineChatJoinRequestChatID(previous)
	}
}

// WithDeclineChatJoinRequestUserID sets the UserID field.
//
// Unique identifier of the target user
func WithDeclineChatJoinRequestUserID(value int64) DeclineChatJoinRequestOption {
	return func(params *DeclineChatJoinRequestParams) DeclineChatJoinRequestOption {
		previous := params.UserID
		params.UserID = value

		return WithDeclineChatJoinRequestUserID(previous)
	}
}

// DeclineChatJoinRequest calls the declineChatJoinRequest Telegram Bot API method.
//
// Use this method to decline a chat join request.
// The bot must be an administrator in the chat for this to work and must have the can_invite_users administrator right.
// Returns True on success.
func (c *Client) DeclineChatJoinRequest(params *DeclineChatJoinRequestParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("declineChatJoinRequest", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeclineSuggestedPostParams contains parameters for Client.DeclineSuggestedPost.
type DeclineSuggestedPostParams struct {
	// Unique identifier for the target direct messages chat
	ChatID int64 `json:"chat_id"`

	// Identifier of a suggested post message to decline
	MessageID int64 `json:"message_id"`

	// Comment for the creator of the suggested post; 0-128 characters
	Comment string `json:"comment,omitempty"`
}

// DeclineSuggestedPostOption configures DeclineSuggestedPostParams.
type DeclineSuggestedPostOption func(params *DeclineSuggestedPostParams) DeclineSuggestedPostOption

// Option applies one or more DeclineSuggestedPostOption values and returns the last rollback option.
func (r *DeclineSuggestedPostParams) Option(opts ...DeclineSuggestedPostOption) (previous DeclineSuggestedPostOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeclineSuggestedPostChatID sets the ChatID field.
//
// Unique identifier for the target direct messages chat
func WithDeclineSuggestedPostChatID(value int64) DeclineSuggestedPostOption {
	return func(params *DeclineSuggestedPostParams) DeclineSuggestedPostOption {
		previous := params.ChatID
		params.ChatID = value

		return WithDeclineSuggestedPostChatID(previous)
	}
}

// WithDeclineSuggestedPostMessageID sets the MessageID field.
//
// Identifier of a suggested post message to decline
func WithDeclineSuggestedPostMessageID(value int64) DeclineSuggestedPostOption {
	return func(params *DeclineSuggestedPostParams) DeclineSuggestedPostOption {
		previous := params.MessageID
		params.MessageID = value

		return WithDeclineSuggestedPostMessageID(previous)
	}
}

// WithDeclineSuggestedPostComment sets the Comment field.
//
// Comment for the creator of the suggested post; 0-128 characters
func WithDeclineSuggestedPostComment(value string) DeclineSuggestedPostOption {
	return func(params *DeclineSuggestedPostParams) DeclineSuggestedPostOption {
		previous := params.Comment
		params.Comment = value

		return WithDeclineSuggestedPostComment(previous)
	}
}

// DeclineSuggestedPost calls the declineSuggestedPost Telegram Bot API method.
//
// Use this method to decline a suggested post in a direct messages chat.
// The bot must have the 'can_manage_direct_messages' administrator right in the corresponding channel chat.
// Returns True on success.
func (c *Client) DeclineSuggestedPost(params *DeclineSuggestedPostParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("declineSuggestedPost", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeleteBusinessMessagesParams contains parameters for Client.DeleteBusinessMessages.
type DeleteBusinessMessagesParams struct {
	// Unique identifier of the business connection on behalf of which to delete the messages
	BusinessConnectionID string `json:"business_connection_id"`

	// A JSON-serialized list of 1-100 identifiers of messages to delete.
	// All messages must be from the same chat.
	// See [deleteMessage] for limitations on which messages can be deleted
	//
	// [deleteMessage]: https://core.telegram.org/bots/api#deletemessage
	MessageIDs []int64 `json:"message_ids"`
}

// DeleteBusinessMessagesOption configures DeleteBusinessMessagesParams.
type DeleteBusinessMessagesOption func(params *DeleteBusinessMessagesParams) DeleteBusinessMessagesOption

// Option applies one or more DeleteBusinessMessagesOption values and returns the last rollback option.
func (r *DeleteBusinessMessagesParams) Option(opts ...DeleteBusinessMessagesOption) (previous DeleteBusinessMessagesOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeleteBusinessMessagesBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which to delete the messages
func WithDeleteBusinessMessagesBusinessConnectionID(value string) DeleteBusinessMessagesOption {
	return func(params *DeleteBusinessMessagesParams) DeleteBusinessMessagesOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithDeleteBusinessMessagesBusinessConnectionID(previous)
	}
}

// WithDeleteBusinessMessagesMessageIDs sets the MessageIDs field.
//
// A JSON-serialized list of 1-100 identifiers of messages to delete.
// All messages must be from the same chat.
// See [deleteMessage] for limitations on which messages can be deleted
//
// [deleteMessage]: https://core.telegram.org/bots/api#deletemessage
func WithDeleteBusinessMessagesMessageIDs(value []int64) DeleteBusinessMessagesOption {
	return func(params *DeleteBusinessMessagesParams) DeleteBusinessMessagesOption {
		previous := params.MessageIDs
		params.MessageIDs = value

		return WithDeleteBusinessMessagesMessageIDs(previous)
	}
}

// DeleteBusinessMessages calls the deleteBusinessMessages Telegram Bot API method.
//
// Delete messages on behalf of a business account.
// Requires the can_delete_sent_messages business bot right to delete messages sent by the bot itself, or the can_delete_all_messages business bot right to delete any message.
// Returns True on success.
func (c *Client) DeleteBusinessMessages(params *DeleteBusinessMessagesParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("deleteBusinessMessages", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeleteChatPhotoParams contains parameters for Client.DeleteChatPhoto.
type DeleteChatPhotoParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`
}

// DeleteChatPhotoOption configures DeleteChatPhotoParams.
type DeleteChatPhotoOption func(params *DeleteChatPhotoParams) DeleteChatPhotoOption

// Option applies one or more DeleteChatPhotoOption values and returns the last rollback option.
func (r *DeleteChatPhotoParams) Option(opts ...DeleteChatPhotoOption) (previous DeleteChatPhotoOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeleteChatPhotoChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithDeleteChatPhotoChatID(value string) DeleteChatPhotoOption {
	return func(params *DeleteChatPhotoParams) DeleteChatPhotoOption {
		previous := params.ChatID
		params.ChatID = value

		return WithDeleteChatPhotoChatID(previous)
	}
}

// DeleteChatPhoto calls the deleteChatPhoto Telegram Bot API method.
//
// Use this method to delete a chat photo.
// Photos can't be changed for private chats.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns True on success.
func (c *Client) DeleteChatPhoto(params *DeleteChatPhotoParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("deleteChatPhoto", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeleteChatStickerSetParams contains parameters for Client.DeleteChatStickerSet.
type DeleteChatStickerSetParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`
}

// DeleteChatStickerSetOption configures DeleteChatStickerSetParams.
type DeleteChatStickerSetOption func(params *DeleteChatStickerSetParams) DeleteChatStickerSetOption

// Option applies one or more DeleteChatStickerSetOption values and returns the last rollback option.
func (r *DeleteChatStickerSetParams) Option(opts ...DeleteChatStickerSetOption) (previous DeleteChatStickerSetOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeleteChatStickerSetChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithDeleteChatStickerSetChatID(value string) DeleteChatStickerSetOption {
	return func(params *DeleteChatStickerSetParams) DeleteChatStickerSetOption {
		previous := params.ChatID
		params.ChatID = value

		return WithDeleteChatStickerSetChatID(previous)
	}
}

// DeleteChatStickerSet calls the deleteChatStickerSet Telegram Bot API method.
//
// Use this method to delete a group sticker set from a supergroup.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// Use the field can_set_sticker_set optionally returned in [getChat] requests to check if the bot can use this method.
// Returns True on success.
//
// [getChat]: https://core.telegram.org/bots/api#getchat
func (c *Client) DeleteChatStickerSet(params *DeleteChatStickerSetParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("deleteChatStickerSet", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeleteForumTopicParams contains parameters for Client.DeleteForumTopic.
type DeleteForumTopicParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread of the forum topic
	MessageThreadID int64 `json:"message_thread_id"`
}

// DeleteForumTopicOption configures DeleteForumTopicParams.
type DeleteForumTopicOption func(params *DeleteForumTopicParams) DeleteForumTopicOption

// Option applies one or more DeleteForumTopicOption values and returns the last rollback option.
func (r *DeleteForumTopicParams) Option(opts ...DeleteForumTopicOption) (previous DeleteForumTopicOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeleteForumTopicChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithDeleteForumTopicChatID(value string) DeleteForumTopicOption {
	return func(params *DeleteForumTopicParams) DeleteForumTopicOption {
		previous := params.ChatID
		params.ChatID = value

		return WithDeleteForumTopicChatID(previous)
	}
}

// WithDeleteForumTopicMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread of the forum topic
func WithDeleteForumTopicMessageThreadID(value int64) DeleteForumTopicOption {
	return func(params *DeleteForumTopicParams) DeleteForumTopicOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithDeleteForumTopicMessageThreadID(previous)
	}
}

// DeleteForumTopic calls the deleteForumTopic Telegram Bot API method.
//
// Use this method to delete a forum topic along with all its messages in a forum supergroup chat or a private chat with a user.
// In the case of a supergroup chat the bot must be an administrator in the chat for this to work and must have the can_delete_messages administrator rights.
// Returns True on success.
func (c *Client) DeleteForumTopic(params *DeleteForumTopicParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("deleteForumTopic", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeleteMessageParams contains parameters for Client.DeleteMessage.
type DeleteMessageParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Identifier of the message to delete
	MessageID int64 `json:"message_id"`
}

// DeleteMessageOption configures DeleteMessageParams.
type DeleteMessageOption func(params *DeleteMessageParams) DeleteMessageOption

// Option applies one or more DeleteMessageOption values and returns the last rollback option.
func (r *DeleteMessageParams) Option(opts ...DeleteMessageOption) (previous DeleteMessageOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeleteMessageChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithDeleteMessageChatID(value string) DeleteMessageOption {
	return func(params *DeleteMessageParams) DeleteMessageOption {
		previous := params.ChatID
		params.ChatID = value

		return WithDeleteMessageChatID(previous)
	}
}

// WithDeleteMessageMessageID sets the MessageID field.
//
// Identifier of the message to delete
func WithDeleteMessageMessageID(value int64) DeleteMessageOption {
	return func(params *DeleteMessageParams) DeleteMessageOption {
		previous := params.MessageID
		params.MessageID = value

		return WithDeleteMessageMessageID(previous)
	}
}

// DeleteMessage calls the deleteMessage Telegram Bot API method.
//
// Use this method to delete a message, including service messages, with the following limitations:
// - A message can only be deleted if it was sent less than 48 hours ago.
// - Service messages about a supergroup, channel, or forum topic creation can't be deleted.
// - A dice message in a private chat can only be deleted if it was sent more than 24 hours ago.
// - Bots can delete outgoing messages in private chats, groups, and supergroups.
// - Bots can delete incoming messages in private chats.
// - Bots granted can_post_messages permissions can delete outgoing messages in channels.
// - If the bot is an administrator of a group, it can delete any message there.
// - If the bot has can_delete_messages administrator right in a supergroup or a channel, it can delete any message there.
// - If the bot has can_manage_direct_messages administrator right in a channel, it can delete any message in the corresponding direct messages chat.
// Returns True on success.
func (c *Client) DeleteMessage(params *DeleteMessageParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("deleteMessage", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeleteMessagesParams contains parameters for Client.DeleteMessages.
type DeleteMessagesParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// A JSON-serialized list of 1-100 identifiers of messages to delete.
	// See [deleteMessage] for limitations on which messages can be deleted
	//
	// [deleteMessage]: https://core.telegram.org/bots/api#deletemessage
	MessageIDs []int64 `json:"message_ids"`
}

// DeleteMessagesOption configures DeleteMessagesParams.
type DeleteMessagesOption func(params *DeleteMessagesParams) DeleteMessagesOption

// Option applies one or more DeleteMessagesOption values and returns the last rollback option.
func (r *DeleteMessagesParams) Option(opts ...DeleteMessagesOption) (previous DeleteMessagesOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeleteMessagesChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithDeleteMessagesChatID(value string) DeleteMessagesOption {
	return func(params *DeleteMessagesParams) DeleteMessagesOption {
		previous := params.ChatID
		params.ChatID = value

		return WithDeleteMessagesChatID(previous)
	}
}

// WithDeleteMessagesMessageIDs sets the MessageIDs field.
//
// A JSON-serialized list of 1-100 identifiers of messages to delete.
// See [deleteMessage] for limitations on which messages can be deleted
//
// [deleteMessage]: https://core.telegram.org/bots/api#deletemessage
func WithDeleteMessagesMessageIDs(value []int64) DeleteMessagesOption {
	return func(params *DeleteMessagesParams) DeleteMessagesOption {
		previous := params.MessageIDs
		params.MessageIDs = value

		return WithDeleteMessagesMessageIDs(previous)
	}
}

// DeleteMessages calls the deleteMessages Telegram Bot API method.
//
// Use this method to delete multiple messages simultaneously.
// If some of the specified messages can't be found, they are skipped.
// Returns True on success.
func (c *Client) DeleteMessages(params *DeleteMessagesParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("deleteMessages", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeleteMyCommandsParams contains parameters for Client.DeleteMyCommands.
type DeleteMyCommandsParams struct {
	// A JSON-serialized object, describing scope of users for which the commands are relevant.
	// Defaults to [BotCommandScopeDefault].
	//
	// [BotCommandScopeDefault]: https://core.telegram.org/bots/api#botcommandscopedefault
	Scope *BotCommandScope `json:"scope,omitempty"`

	// A two-letter ISO 639-1 language code.
	// If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands
	LanguageCode string `json:"language_code,omitempty"`
}

// DeleteMyCommandsOption configures DeleteMyCommandsParams.
type DeleteMyCommandsOption func(params *DeleteMyCommandsParams) DeleteMyCommandsOption

// Option applies one or more DeleteMyCommandsOption values and returns the last rollback option.
func (r *DeleteMyCommandsParams) Option(opts ...DeleteMyCommandsOption) (previous DeleteMyCommandsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeleteMyCommandsScope sets the Scope field.
//
// A JSON-serialized object, describing scope of users for which the commands are relevant.
// Defaults to [BotCommandScopeDefault].
//
// [BotCommandScopeDefault]: https://core.telegram.org/bots/api#botcommandscopedefault
func WithDeleteMyCommandsScope(value *BotCommandScope) DeleteMyCommandsOption {
	return func(params *DeleteMyCommandsParams) DeleteMyCommandsOption {
		previous := params.Scope
		params.Scope = value

		return WithDeleteMyCommandsScope(previous)
	}
}

// WithDeleteMyCommandsLanguageCode sets the LanguageCode field.
//
// A two-letter ISO 639-1 language code.
// If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands
func WithDeleteMyCommandsLanguageCode(value string) DeleteMyCommandsOption {
	return func(params *DeleteMyCommandsParams) DeleteMyCommandsOption {
		previous := params.LanguageCode
		params.LanguageCode = value

		return WithDeleteMyCommandsLanguageCode(previous)
	}
}

// DeleteMyCommands calls the deleteMyCommands Telegram Bot API method.
//
// Use this method to delete the list of the bot's commands for the given scope and user language.
// After deletion, [higher level commands] will be shown to affected users.
// Returns True on success.
//
// [higher level commands]: https://core.telegram.org/bots/api#determining-list-of-commands
func (c *Client) DeleteMyCommands(params *DeleteMyCommandsParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("deleteMyCommands", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeleteStickerFromSetParams contains parameters for Client.DeleteStickerFromSet.
type DeleteStickerFromSetParams struct {
	// File identifier of the sticker
	Sticker string `json:"sticker"`
}

// DeleteStickerFromSetOption configures DeleteStickerFromSetParams.
type DeleteStickerFromSetOption func(params *DeleteStickerFromSetParams) DeleteStickerFromSetOption

// Option applies one or more DeleteStickerFromSetOption values and returns the last rollback option.
func (r *DeleteStickerFromSetParams) Option(opts ...DeleteStickerFromSetOption) (previous DeleteStickerFromSetOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeleteStickerFromSetSticker sets the Sticker field.
//
// File identifier of the sticker
func WithDeleteStickerFromSetSticker(value string) DeleteStickerFromSetOption {
	return func(params *DeleteStickerFromSetParams) DeleteStickerFromSetOption {
		previous := params.Sticker
		params.Sticker = value

		return WithDeleteStickerFromSetSticker(previous)
	}
}

// DeleteStickerFromSet calls the deleteStickerFromSet Telegram Bot API method.
//
// Use this method to delete a sticker from a set created by the bot.
// Returns True on success.
func (c *Client) DeleteStickerFromSet(params *DeleteStickerFromSetParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("deleteStickerFromSet", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeleteStickerSetParams contains parameters for Client.DeleteStickerSet.
type DeleteStickerSetParams struct {
	// Sticker set name
	Name string `json:"name"`
}

// DeleteStickerSetOption configures DeleteStickerSetParams.
type DeleteStickerSetOption func(params *DeleteStickerSetParams) DeleteStickerSetOption

// Option applies one or more DeleteStickerSetOption values and returns the last rollback option.
func (r *DeleteStickerSetParams) Option(opts ...DeleteStickerSetOption) (previous DeleteStickerSetOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeleteStickerSetName sets the Name field.
//
// Sticker set name
func WithDeleteStickerSetName(value string) DeleteStickerSetOption {
	return func(params *DeleteStickerSetParams) DeleteStickerSetOption {
		previous := params.Name
		params.Name = value

		return WithDeleteStickerSetName(previous)
	}
}

// DeleteStickerSet calls the deleteStickerSet Telegram Bot API method.
//
// Use this method to delete a sticker set that was created by the bot.
// Returns True on success.
func (c *Client) DeleteStickerSet(params *DeleteStickerSetParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("deleteStickerSet", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeleteStoryParams contains parameters for Client.DeleteStory.
type DeleteStoryParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// Unique identifier of the story to delete
	StoryID int64 `json:"story_id"`
}

// DeleteStoryOption configures DeleteStoryParams.
type DeleteStoryOption func(params *DeleteStoryParams) DeleteStoryOption

// Option applies one or more DeleteStoryOption values and returns the last rollback option.
func (r *DeleteStoryParams) Option(opts ...DeleteStoryOption) (previous DeleteStoryOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeleteStoryBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithDeleteStoryBusinessConnectionID(value string) DeleteStoryOption {
	return func(params *DeleteStoryParams) DeleteStoryOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithDeleteStoryBusinessConnectionID(previous)
	}
}

// WithDeleteStoryStoryID sets the StoryID field.
//
// Unique identifier of the story to delete
func WithDeleteStoryStoryID(value int64) DeleteStoryOption {
	return func(params *DeleteStoryParams) DeleteStoryOption {
		previous := params.StoryID
		params.StoryID = value

		return WithDeleteStoryStoryID(previous)
	}
}

// DeleteStory calls the deleteStory Telegram Bot API method.
//
// Deletes a story previously posted by the bot on behalf of a managed business account.
// Requires the can_manage_stories business bot right.
// Returns True on success.
func (c *Client) DeleteStory(params *DeleteStoryParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("deleteStory", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// DeleteWebhookParams contains parameters for Client.DeleteWebhook.
type DeleteWebhookParams struct {
	// Pass True to drop all pending updates
	DropPendingUpdates bool `json:"drop_pending_updates,omitempty"`
}

// DeleteWebhookOption configures DeleteWebhookParams.
type DeleteWebhookOption func(params *DeleteWebhookParams) DeleteWebhookOption

// Option applies one or more DeleteWebhookOption values and returns the last rollback option.
func (r *DeleteWebhookParams) Option(opts ...DeleteWebhookOption) (previous DeleteWebhookOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithDeleteWebhookDropPendingUpdates sets the DropPendingUpdates field.
//
// Pass True to drop all pending updates
func WithDeleteWebhookDropPendingUpdates(value bool) DeleteWebhookOption {
	return func(params *DeleteWebhookParams) DeleteWebhookOption {
		previous := params.DropPendingUpdates
		params.DropPendingUpdates = value

		return WithDeleteWebhookDropPendingUpdates(previous)
	}
}

// DeleteWebhook calls the deleteWebhook Telegram Bot API method.
//
// Use this method to remove webhook integration if you decide to switch back to [getUpdates].
// Returns True on success.
//
// [getUpdates]: https://core.telegram.org/bots/api#getupdates
func (c *Client) DeleteWebhook(params *DeleteWebhookParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("deleteWebhook", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditChatInviteLinkParams contains parameters for Client.EditChatInviteLink.
type EditChatInviteLinkParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// The invite link to edit
	InviteLink string `json:"invite_link"`

	// Invite link name; 0-32 characters
	Name string `json:"name,omitempty"`

	// Point in time (Unix timestamp) when the link will expire
	ExpireDate int64 `json:"expire_date,omitempty"`

	// The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999
	MemberLimit int64 `json:"member_limit,omitempty"`

	// True, if users joining the chat via the link need to be approved by chat administrators.
	// If True, member_limit can't be specified
	CreatesJoinRequest bool `json:"creates_join_request,omitempty"`
}

// EditChatInviteLinkOption configures EditChatInviteLinkParams.
type EditChatInviteLinkOption func(params *EditChatInviteLinkParams) EditChatInviteLinkOption

// Option applies one or more EditChatInviteLinkOption values and returns the last rollback option.
func (r *EditChatInviteLinkParams) Option(opts ...EditChatInviteLinkOption) (previous EditChatInviteLinkOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditChatInviteLinkChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithEditChatInviteLinkChatID(value string) EditChatInviteLinkOption {
	return func(params *EditChatInviteLinkParams) EditChatInviteLinkOption {
		previous := params.ChatID
		params.ChatID = value

		return WithEditChatInviteLinkChatID(previous)
	}
}

// WithEditChatInviteLinkInviteLink sets the InviteLink field.
//
// The invite link to edit
func WithEditChatInviteLinkInviteLink(value string) EditChatInviteLinkOption {
	return func(params *EditChatInviteLinkParams) EditChatInviteLinkOption {
		previous := params.InviteLink
		params.InviteLink = value

		return WithEditChatInviteLinkInviteLink(previous)
	}
}

// WithEditChatInviteLinkName sets the Name field.
//
// Invite link name; 0-32 characters
func WithEditChatInviteLinkName(value string) EditChatInviteLinkOption {
	return func(params *EditChatInviteLinkParams) EditChatInviteLinkOption {
		previous := params.Name
		params.Name = value

		return WithEditChatInviteLinkName(previous)
	}
}

// WithEditChatInviteLinkExpireDate sets the ExpireDate field.
//
// Point in time (Unix timestamp) when the link will expire
func WithEditChatInviteLinkExpireDate(value int64) EditChatInviteLinkOption {
	return func(params *EditChatInviteLinkParams) EditChatInviteLinkOption {
		previous := params.ExpireDate
		params.ExpireDate = value

		return WithEditChatInviteLinkExpireDate(previous)
	}
}

// WithEditChatInviteLinkMemberLimit sets the MemberLimit field.
//
// The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999
func WithEditChatInviteLinkMemberLimit(value int64) EditChatInviteLinkOption {
	return func(params *EditChatInviteLinkParams) EditChatInviteLinkOption {
		previous := params.MemberLimit
		params.MemberLimit = value

		return WithEditChatInviteLinkMemberLimit(previous)
	}
}

// WithEditChatInviteLinkCreatesJoinRequest sets the CreatesJoinRequest field.
//
// True, if users joining the chat via the link need to be approved by chat administrators.
// If True, member_limit can't be specified
func WithEditChatInviteLinkCreatesJoinRequest(value bool) EditChatInviteLinkOption {
	return func(params *EditChatInviteLinkParams) EditChatInviteLinkOption {
		previous := params.CreatesJoinRequest
		params.CreatesJoinRequest = value

		return WithEditChatInviteLinkCreatesJoinRequest(previous)
	}
}

// EditChatInviteLink calls the editChatInviteLink Telegram Bot API method.
//
// Use this method to edit a non-primary invite link created by the bot.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns the edited invite link as a [ChatInviteLink] object.
//
// [ChatInviteLink]: https://core.telegram.org/bots/api#chatinvitelink
func (c *Client) EditChatInviteLink(params *EditChatInviteLinkParams) (ret *ChatInviteLink, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editChatInviteLink", reader, contentType)
	if err != nil {
		return
	}

	ret = new(ChatInviteLink)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditChatSubscriptionInviteLinkParams contains parameters for Client.EditChatSubscriptionInviteLink.
type EditChatSubscriptionInviteLinkParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// The invite link to edit
	InviteLink string `json:"invite_link"`

	// Invite link name; 0-32 characters
	Name string `json:"name,omitempty"`
}

// EditChatSubscriptionInviteLinkOption configures EditChatSubscriptionInviteLinkParams.
type EditChatSubscriptionInviteLinkOption func(params *EditChatSubscriptionInviteLinkParams) EditChatSubscriptionInviteLinkOption

// Option applies one or more EditChatSubscriptionInviteLinkOption values and returns the last rollback option.
func (r *EditChatSubscriptionInviteLinkParams) Option(opts ...EditChatSubscriptionInviteLinkOption) (previous EditChatSubscriptionInviteLinkOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditChatSubscriptionInviteLinkChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithEditChatSubscriptionInviteLinkChatID(value string) EditChatSubscriptionInviteLinkOption {
	return func(params *EditChatSubscriptionInviteLinkParams) EditChatSubscriptionInviteLinkOption {
		previous := params.ChatID
		params.ChatID = value

		return WithEditChatSubscriptionInviteLinkChatID(previous)
	}
}

// WithEditChatSubscriptionInviteLinkInviteLink sets the InviteLink field.
//
// The invite link to edit
func WithEditChatSubscriptionInviteLinkInviteLink(value string) EditChatSubscriptionInviteLinkOption {
	return func(params *EditChatSubscriptionInviteLinkParams) EditChatSubscriptionInviteLinkOption {
		previous := params.InviteLink
		params.InviteLink = value

		return WithEditChatSubscriptionInviteLinkInviteLink(previous)
	}
}

// WithEditChatSubscriptionInviteLinkName sets the Name field.
//
// Invite link name; 0-32 characters
func WithEditChatSubscriptionInviteLinkName(value string) EditChatSubscriptionInviteLinkOption {
	return func(params *EditChatSubscriptionInviteLinkParams) EditChatSubscriptionInviteLinkOption {
		previous := params.Name
		params.Name = value

		return WithEditChatSubscriptionInviteLinkName(previous)
	}
}

// EditChatSubscriptionInviteLink calls the editChatSubscriptionInviteLink Telegram Bot API method.
//
// Use this method to edit a subscription invite link created by the bot.
// The bot must have the can_invite_users administrator rights.
// Returns the edited invite link as a [ChatInviteLink] object.
//
// [ChatInviteLink]: https://core.telegram.org/bots/api#chatinvitelink
func (c *Client) EditChatSubscriptionInviteLink(params *EditChatSubscriptionInviteLinkParams) (ret *ChatInviteLink, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editChatSubscriptionInviteLink", reader, contentType)
	if err != nil {
		return
	}

	ret = new(ChatInviteLink)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditForumTopicParams contains parameters for Client.EditForumTopic.
type EditForumTopicParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread of the forum topic
	MessageThreadID int64 `json:"message_thread_id"`

	// New topic name, 0-128 characters.
	// If not specified or empty, the current name of the topic will be kept
	Name string `json:"name,omitempty"`

	// New unique identifier of the custom emoji shown as the topic icon.
	// Use [getForumTopicIconStickers] to get all allowed custom emoji identifiers.
	// Pass an empty string to remove the icon.
	// If not specified, the current icon will be kept
	//
	// [getForumTopicIconStickers]: https://core.telegram.org/bots/api#getforumtopiciconstickers
	IconCustomEmojiID string `json:"icon_custom_emoji_id,omitempty"`
}

// EditForumTopicOption configures EditForumTopicParams.
type EditForumTopicOption func(params *EditForumTopicParams) EditForumTopicOption

// Option applies one or more EditForumTopicOption values and returns the last rollback option.
func (r *EditForumTopicParams) Option(opts ...EditForumTopicOption) (previous EditForumTopicOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditForumTopicChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithEditForumTopicChatID(value string) EditForumTopicOption {
	return func(params *EditForumTopicParams) EditForumTopicOption {
		previous := params.ChatID
		params.ChatID = value

		return WithEditForumTopicChatID(previous)
	}
}

// WithEditForumTopicMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread of the forum topic
func WithEditForumTopicMessageThreadID(value int64) EditForumTopicOption {
	return func(params *EditForumTopicParams) EditForumTopicOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithEditForumTopicMessageThreadID(previous)
	}
}

// WithEditForumTopicName sets the Name field.
//
// New topic name, 0-128 characters.
// If not specified or empty, the current name of the topic will be kept
func WithEditForumTopicName(value string) EditForumTopicOption {
	return func(params *EditForumTopicParams) EditForumTopicOption {
		previous := params.Name
		params.Name = value

		return WithEditForumTopicName(previous)
	}
}

// WithEditForumTopicIconCustomEmojiID sets the IconCustomEmojiID field.
//
// New unique identifier of the custom emoji shown as the topic icon.
// Use [getForumTopicIconStickers] to get all allowed custom emoji identifiers.
// Pass an empty string to remove the icon.
// If not specified, the current icon will be kept
//
// [getForumTopicIconStickers]: https://core.telegram.org/bots/api#getforumtopiciconstickers
func WithEditForumTopicIconCustomEmojiID(value string) EditForumTopicOption {
	return func(params *EditForumTopicParams) EditForumTopicOption {
		previous := params.IconCustomEmojiID
		params.IconCustomEmojiID = value

		return WithEditForumTopicIconCustomEmojiID(previous)
	}
}

// EditForumTopic calls the editForumTopic Telegram Bot API method.
//
// Use this method to edit name and icon of a topic in a forum supergroup chat or a private chat with a user.
// In the case of a supergroup chat the bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.
// Returns True on success.
func (c *Client) EditForumTopic(params *EditForumTopicParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editForumTopic", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditGeneralForumTopicParams contains parameters for Client.EditGeneralForumTopic.
type EditGeneralForumTopicParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// New topic name, 1-128 characters
	Name string `json:"name"`
}

// EditGeneralForumTopicOption configures EditGeneralForumTopicParams.
type EditGeneralForumTopicOption func(params *EditGeneralForumTopicParams) EditGeneralForumTopicOption

// Option applies one or more EditGeneralForumTopicOption values and returns the last rollback option.
func (r *EditGeneralForumTopicParams) Option(opts ...EditGeneralForumTopicOption) (previous EditGeneralForumTopicOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditGeneralForumTopicChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithEditGeneralForumTopicChatID(value string) EditGeneralForumTopicOption {
	return func(params *EditGeneralForumTopicParams) EditGeneralForumTopicOption {
		previous := params.ChatID
		params.ChatID = value

		return WithEditGeneralForumTopicChatID(previous)
	}
}

// WithEditGeneralForumTopicName sets the Name field.
//
// New topic name, 1-128 characters
func WithEditGeneralForumTopicName(value string) EditGeneralForumTopicOption {
	return func(params *EditGeneralForumTopicParams) EditGeneralForumTopicOption {
		previous := params.Name
		params.Name = value

		return WithEditGeneralForumTopicName(previous)
	}
}

// EditGeneralForumTopic calls the editGeneralForumTopic Telegram Bot API method.
//
// Use this method to edit the name of the 'General' topic in a forum supergroup chat.
// The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.
// Returns True on success.
func (c *Client) EditGeneralForumTopic(params *EditGeneralForumTopicParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editGeneralForumTopic", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditMessageCaptionParams contains parameters for Client.EditMessageCaption.
type EditMessageCaptionParams struct {
	// Unique identifier of the business connection on behalf of which the message to be edited was sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`

	// Required if chat_id and message_id are not specified.
	// Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// New caption of the message, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Mode for parsing entities in the message caption.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Pass True, if the caption must be shown above the message media.
	// Supported only for animation, photo and video messages.
	ShowCaptionAboveMedia bool `json:"show_caption_above_media,omitempty"`

	// A JSON-serialized object for an [inline keyboard].
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageCaptionOption configures EditMessageCaptionParams.
type EditMessageCaptionOption func(params *EditMessageCaptionParams) EditMessageCaptionOption

// Option applies one or more EditMessageCaptionOption values and returns the last rollback option.
func (r *EditMessageCaptionParams) Option(opts ...EditMessageCaptionOption) (previous EditMessageCaptionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditMessageCaptionBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message to be edited was sent
func WithEditMessageCaptionBusinessConnectionID(value string) EditMessageCaptionOption {
	return func(params *EditMessageCaptionParams) EditMessageCaptionOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithEditMessageCaptionBusinessConnectionID(previous)
	}
}

// WithEditMessageCaptionChatID sets the ChatID field.
//
// Required if inline_message_id is not specified.
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithEditMessageCaptionChatID(value string) EditMessageCaptionOption {
	return func(params *EditMessageCaptionParams) EditMessageCaptionOption {
		previous := params.ChatID
		params.ChatID = value

		return WithEditMessageCaptionChatID(previous)
	}
}

// WithEditMessageCaptionMessageID sets the MessageID field.
//
// Required if inline_message_id is not specified.
// Identifier of the message to edit
func WithEditMessageCaptionMessageID(value int64) EditMessageCaptionOption {
	return func(params *EditMessageCaptionParams) EditMessageCaptionOption {
		previous := params.MessageID
		params.MessageID = value

		return WithEditMessageCaptionMessageID(previous)
	}
}

// WithEditMessageCaptionInlineMessageID sets the InlineMessageID field.
//
// Required if chat_id and message_id are not specified.
// Identifier of the inline message
func WithEditMessageCaptionInlineMessageID(value string) EditMessageCaptionOption {
	return func(params *EditMessageCaptionParams) EditMessageCaptionOption {
		previous := params.InlineMessageID
		params.InlineMessageID = value

		return WithEditMessageCaptionInlineMessageID(previous)
	}
}

// WithEditMessageCaptionCaption sets the Caption field.
//
// New caption of the message, 0-1024 characters after entities parsing
func WithEditMessageCaptionCaption(value string) EditMessageCaptionOption {
	return func(params *EditMessageCaptionParams) EditMessageCaptionOption {
		previous := params.Caption
		params.Caption = value

		return WithEditMessageCaptionCaption(previous)
	}
}

// WithEditMessageCaptionParseMode sets the ParseMode field.
//
// Mode for parsing entities in the message caption.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithEditMessageCaptionParseMode(value string) EditMessageCaptionOption {
	return func(params *EditMessageCaptionParams) EditMessageCaptionOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithEditMessageCaptionParseMode(previous)
	}
}

// WithEditMessageCaptionCaptionEntities sets the CaptionEntities field.
//
// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
func WithEditMessageCaptionCaptionEntities(value []MessageEntity) EditMessageCaptionOption {
	return func(params *EditMessageCaptionParams) EditMessageCaptionOption {
		previous := params.CaptionEntities
		params.CaptionEntities = value

		return WithEditMessageCaptionCaptionEntities(previous)
	}
}

// WithEditMessageCaptionShowCaptionAboveMedia sets the ShowCaptionAboveMedia field.
//
// Pass True, if the caption must be shown above the message media.
// Supported only for animation, photo and video messages.
func WithEditMessageCaptionShowCaptionAboveMedia(value bool) EditMessageCaptionOption {
	return func(params *EditMessageCaptionParams) EditMessageCaptionOption {
		previous := params.ShowCaptionAboveMedia
		params.ShowCaptionAboveMedia = value

		return WithEditMessageCaptionShowCaptionAboveMedia(previous)
	}
}

// WithEditMessageCaptionReplyMarkup sets the ReplyMarkup field.
//
// A JSON-serialized object for an [inline keyboard].
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
func WithEditMessageCaptionReplyMarkup(value *InlineKeyboardMarkup) EditMessageCaptionOption {
	return func(params *EditMessageCaptionParams) EditMessageCaptionOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithEditMessageCaptionReplyMarkup(previous)
	}
}

// EditMessageCaption calls the editMessageCaption Telegram Bot API method.
//
// Use this method to edit captions of messages.
// On success, if the edited message is not an inline message, the edited [Message] is returned, otherwise True is returned.
// Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within 48 hours from the time they were sent.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) EditMessageCaption(params *EditMessageCaptionParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editMessageCaption", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditMessageChecklistParams contains parameters for Client.EditMessageChecklist.
type EditMessageChecklistParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id"`

	// Unique identifier for the target chat
	ChatID int64 `json:"chat_id"`

	// Unique identifier for the target message
	MessageID int64 `json:"message_id"`

	// A JSON-serialized object for the new checklist
	Checklist InputChecklist `json:"checklist"`

	// A JSON-serialized object for the new [inline keyboard] for the message
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageChecklistOption configures EditMessageChecklistParams.
type EditMessageChecklistOption func(params *EditMessageChecklistParams) EditMessageChecklistOption

// Option applies one or more EditMessageChecklistOption values and returns the last rollback option.
func (r *EditMessageChecklistParams) Option(opts ...EditMessageChecklistOption) (previous EditMessageChecklistOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditMessageChecklistBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithEditMessageChecklistBusinessConnectionID(value string) EditMessageChecklistOption {
	return func(params *EditMessageChecklistParams) EditMessageChecklistOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithEditMessageChecklistBusinessConnectionID(previous)
	}
}

// WithEditMessageChecklistChatID sets the ChatID field.
//
// Unique identifier for the target chat
func WithEditMessageChecklistChatID(value int64) EditMessageChecklistOption {
	return func(params *EditMessageChecklistParams) EditMessageChecklistOption {
		previous := params.ChatID
		params.ChatID = value

		return WithEditMessageChecklistChatID(previous)
	}
}

// WithEditMessageChecklistMessageID sets the MessageID field.
//
// Unique identifier for the target message
func WithEditMessageChecklistMessageID(value int64) EditMessageChecklistOption {
	return func(params *EditMessageChecklistParams) EditMessageChecklistOption {
		previous := params.MessageID
		params.MessageID = value

		return WithEditMessageChecklistMessageID(previous)
	}
}

// WithEditMessageChecklistChecklist sets the Checklist field.
//
// A JSON-serialized object for the new checklist
func WithEditMessageChecklistChecklist(value InputChecklist) EditMessageChecklistOption {
	return func(params *EditMessageChecklistParams) EditMessageChecklistOption {
		previous := params.Checklist
		params.Checklist = value

		return WithEditMessageChecklistChecklist(previous)
	}
}

// WithEditMessageChecklistReplyMarkup sets the ReplyMarkup field.
//
// A JSON-serialized object for the new [inline keyboard] for the message
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
func WithEditMessageChecklistReplyMarkup(value *InlineKeyboardMarkup) EditMessageChecklistOption {
	return func(params *EditMessageChecklistParams) EditMessageChecklistOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithEditMessageChecklistReplyMarkup(previous)
	}
}

// EditMessageChecklist calls the editMessageChecklist Telegram Bot API method.
//
// Use this method to edit a checklist on behalf of a connected business account.
// On success, the edited [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) EditMessageChecklist(params *EditMessageChecklistParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editMessageChecklist", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditMessageLiveLocationParams contains parameters for Client.EditMessageLiveLocation.
type EditMessageLiveLocationParams struct {
	// Unique identifier of the business connection on behalf of which the message to be edited was sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`

	// Required if chat_id and message_id are not specified.
	// Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// Latitude of new location
	Latitude float64 `json:"latitude"`

	// Longitude of new location
	Longitude float64 `json:"longitude"`

	// New period in seconds during which the location can be updated, starting from the message send date.
	// If 0x7FFFFFFF is specified, then the location can be updated forever.
	// Otherwise, the new value must not exceed the current live_period by more than a day, and the live location expiration date must remain within the next 90 days.
	// If not specified, then live_period remains unchanged
	LivePeriod int64 `json:"live_period,omitempty"`

	// The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy float64 `json:"horizontal_accuracy,omitempty"`

	// Direction in which the user is moving, in degrees.
	// Must be between 1 and 360 if specified.
	Heading int64 `json:"heading,omitempty"`

	// The maximum distance for proximity alerts about approaching another chat member, in meters.
	// Must be between 1 and 100000 if specified.
	ProximityAlertRadius int64 `json:"proximity_alert_radius,omitempty"`

	// A JSON-serialized object for a new [inline keyboard].
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageLiveLocationOption configures EditMessageLiveLocationParams.
type EditMessageLiveLocationOption func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption

// Option applies one or more EditMessageLiveLocationOption values and returns the last rollback option.
func (r *EditMessageLiveLocationParams) Option(opts ...EditMessageLiveLocationOption) (previous EditMessageLiveLocationOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditMessageLiveLocationBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message to be edited was sent
func WithEditMessageLiveLocationBusinessConnectionID(value string) EditMessageLiveLocationOption {
	return func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithEditMessageLiveLocationBusinessConnectionID(previous)
	}
}

// WithEditMessageLiveLocationChatID sets the ChatID field.
//
// Required if inline_message_id is not specified.
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithEditMessageLiveLocationChatID(value string) EditMessageLiveLocationOption {
	return func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption {
		previous := params.ChatID
		params.ChatID = value

		return WithEditMessageLiveLocationChatID(previous)
	}
}

// WithEditMessageLiveLocationMessageID sets the MessageID field.
//
// Required if inline_message_id is not specified.
// Identifier of the message to edit
func WithEditMessageLiveLocationMessageID(value int64) EditMessageLiveLocationOption {
	return func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption {
		previous := params.MessageID
		params.MessageID = value

		return WithEditMessageLiveLocationMessageID(previous)
	}
}

// WithEditMessageLiveLocationInlineMessageID sets the InlineMessageID field.
//
// Required if chat_id and message_id are not specified.
// Identifier of the inline message
func WithEditMessageLiveLocationInlineMessageID(value string) EditMessageLiveLocationOption {
	return func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption {
		previous := params.InlineMessageID
		params.InlineMessageID = value

		return WithEditMessageLiveLocationInlineMessageID(previous)
	}
}

// WithEditMessageLiveLocationLatitude sets the Latitude field.
//
// Latitude of new location
func WithEditMessageLiveLocationLatitude(value float64) EditMessageLiveLocationOption {
	return func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption {
		previous := params.Latitude
		params.Latitude = value

		return WithEditMessageLiveLocationLatitude(previous)
	}
}

// WithEditMessageLiveLocationLongitude sets the Longitude field.
//
// Longitude of new location
func WithEditMessageLiveLocationLongitude(value float64) EditMessageLiveLocationOption {
	return func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption {
		previous := params.Longitude
		params.Longitude = value

		return WithEditMessageLiveLocationLongitude(previous)
	}
}

// WithEditMessageLiveLocationLivePeriod sets the LivePeriod field.
//
// New period in seconds during which the location can be updated, starting from the message send date.
// If 0x7FFFFFFF is specified, then the location can be updated forever.
// Otherwise, the new value must not exceed the current live_period by more than a day, and the live location expiration date must remain within the next 90 days.
// If not specified, then live_period remains unchanged
func WithEditMessageLiveLocationLivePeriod(value int64) EditMessageLiveLocationOption {
	return func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption {
		previous := params.LivePeriod
		params.LivePeriod = value

		return WithEditMessageLiveLocationLivePeriod(previous)
	}
}

// WithEditMessageLiveLocationHorizontalAccuracy sets the HorizontalAccuracy field.
//
// The radius of uncertainty for the location, measured in meters; 0-1500
func WithEditMessageLiveLocationHorizontalAccuracy(value float64) EditMessageLiveLocationOption {
	return func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption {
		previous := params.HorizontalAccuracy
		params.HorizontalAccuracy = value

		return WithEditMessageLiveLocationHorizontalAccuracy(previous)
	}
}

// WithEditMessageLiveLocationHeading sets the Heading field.
//
// Direction in which the user is moving, in degrees.
// Must be between 1 and 360 if specified.
func WithEditMessageLiveLocationHeading(value int64) EditMessageLiveLocationOption {
	return func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption {
		previous := params.Heading
		params.Heading = value

		return WithEditMessageLiveLocationHeading(previous)
	}
}

// WithEditMessageLiveLocationProximityAlertRadius sets the ProximityAlertRadius field.
//
// The maximum distance for proximity alerts about approaching another chat member, in meters.
// Must be between 1 and 100000 if specified.
func WithEditMessageLiveLocationProximityAlertRadius(value int64) EditMessageLiveLocationOption {
	return func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption {
		previous := params.ProximityAlertRadius
		params.ProximityAlertRadius = value

		return WithEditMessageLiveLocationProximityAlertRadius(previous)
	}
}

// WithEditMessageLiveLocationReplyMarkup sets the ReplyMarkup field.
//
// A JSON-serialized object for a new [inline keyboard].
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
func WithEditMessageLiveLocationReplyMarkup(value *InlineKeyboardMarkup) EditMessageLiveLocationOption {
	return func(params *EditMessageLiveLocationParams) EditMessageLiveLocationOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithEditMessageLiveLocationReplyMarkup(previous)
	}
}

// EditMessageLiveLocation calls the editMessageLiveLocation Telegram Bot API method.
//
// Use this method to edit live location messages.
// A location can be edited until its live_period expires or editing is explicitly disabled by a call to [stopMessageLiveLocation].
// On success, if the edited message is not an inline message, the edited [Message] is returned, otherwise True is returned.
//
// [stopMessageLiveLocation]: https://core.telegram.org/bots/api#stopmessagelivelocation
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) EditMessageLiveLocation(params *EditMessageLiveLocationParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editMessageLiveLocation", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditMessageMediaParams contains parameters for Client.EditMessageMedia.
type EditMessageMediaParams struct {
	// Unique identifier of the business connection on behalf of which the message to be edited was sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`

	// Required if chat_id and message_id are not specified.
	// Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// A JSON-serialized object for a new media content of the message
	Media InputMedia `json:"media"`

	// A JSON-serialized object for a new [inline keyboard].
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageMediaOption configures EditMessageMediaParams.
type EditMessageMediaOption func(params *EditMessageMediaParams) EditMessageMediaOption

// Option applies one or more EditMessageMediaOption values and returns the last rollback option.
func (r *EditMessageMediaParams) Option(opts ...EditMessageMediaOption) (previous EditMessageMediaOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditMessageMediaBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message to be edited was sent
func WithEditMessageMediaBusinessConnectionID(value string) EditMessageMediaOption {
	return func(params *EditMessageMediaParams) EditMessageMediaOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithEditMessageMediaBusinessConnectionID(previous)
	}
}

// WithEditMessageMediaChatID sets the ChatID field.
//
// Required if inline_message_id is not specified.
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithEditMessageMediaChatID(value string) EditMessageMediaOption {
	return func(params *EditMessageMediaParams) EditMessageMediaOption {
		previous := params.ChatID
		params.ChatID = value

		return WithEditMessageMediaChatID(previous)
	}
}

// WithEditMessageMediaMessageID sets the MessageID field.
//
// Required if inline_message_id is not specified.
// Identifier of the message to edit
func WithEditMessageMediaMessageID(value int64) EditMessageMediaOption {
	return func(params *EditMessageMediaParams) EditMessageMediaOption {
		previous := params.MessageID
		params.MessageID = value

		return WithEditMessageMediaMessageID(previous)
	}
}

// WithEditMessageMediaInlineMessageID sets the InlineMessageID field.
//
// Required if chat_id and message_id are not specified.
// Identifier of the inline message
func WithEditMessageMediaInlineMessageID(value string) EditMessageMediaOption {
	return func(params *EditMessageMediaParams) EditMessageMediaOption {
		previous := params.InlineMessageID
		params.InlineMessageID = value

		return WithEditMessageMediaInlineMessageID(previous)
	}
}

// WithEditMessageMediaMedia sets the Media field.
//
// A JSON-serialized object for a new media content of the message
func WithEditMessageMediaMedia(value InputMedia) EditMessageMediaOption {
	return func(params *EditMessageMediaParams) EditMessageMediaOption {
		previous := params.Media
		params.Media = value

		return WithEditMessageMediaMedia(previous)
	}
}

// WithEditMessageMediaReplyMarkup sets the ReplyMarkup field.
//
// A JSON-serialized object for a new [inline keyboard].
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
func WithEditMessageMediaReplyMarkup(value *InlineKeyboardMarkup) EditMessageMediaOption {
	return func(params *EditMessageMediaParams) EditMessageMediaOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithEditMessageMediaReplyMarkup(previous)
	}
}

// EditMessageMedia calls the editMessageMedia Telegram Bot API method.
//
// Use this method to edit animation, audio, document, photo, or video messages, or to add media to text messages.
// If a message is part of a message album, then it can be edited only to an audio for audio albums, only to a document for document albums and to a photo or a video otherwise.
// When an inline message is edited, a new file can't be uploaded; use a previously uploaded file via its file_id or specify a URL.
// On success, if the edited message is not an inline message, the edited [Message] is returned, otherwise True is returned.
// Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within 48 hours from the time they were sent.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) EditMessageMedia(params *EditMessageMediaParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editMessageMedia", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditMessageReplyMarkupParams contains parameters for Client.EditMessageReplyMarkup.
type EditMessageReplyMarkupParams struct {
	// Unique identifier of the business connection on behalf of which the message to be edited was sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`

	// Required if chat_id and message_id are not specified.
	// Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// A JSON-serialized object for an [inline keyboard].
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageReplyMarkupOption configures EditMessageReplyMarkupParams.
type EditMessageReplyMarkupOption func(params *EditMessageReplyMarkupParams) EditMessageReplyMarkupOption

// Option applies one or more EditMessageReplyMarkupOption values and returns the last rollback option.
func (r *EditMessageReplyMarkupParams) Option(opts ...EditMessageReplyMarkupOption) (previous EditMessageReplyMarkupOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditMessageReplyMarkupBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message to be edited was sent
func WithEditMessageReplyMarkupBusinessConnectionID(value string) EditMessageReplyMarkupOption {
	return func(params *EditMessageReplyMarkupParams) EditMessageReplyMarkupOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithEditMessageReplyMarkupBusinessConnectionID(previous)
	}
}

// WithEditMessageReplyMarkupChatID sets the ChatID field.
//
// Required if inline_message_id is not specified.
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithEditMessageReplyMarkupChatID(value string) EditMessageReplyMarkupOption {
	return func(params *EditMessageReplyMarkupParams) EditMessageReplyMarkupOption {
		previous := params.ChatID
		params.ChatID = value

		return WithEditMessageReplyMarkupChatID(previous)
	}
}

// WithEditMessageReplyMarkupMessageID sets the MessageID field.
//
// Required if inline_message_id is not specified.
// Identifier of the message to edit
func WithEditMessageReplyMarkupMessageID(value int64) EditMessageReplyMarkupOption {
	return func(params *EditMessageReplyMarkupParams) EditMessageReplyMarkupOption {
		previous := params.MessageID
		params.MessageID = value

		return WithEditMessageReplyMarkupMessageID(previous)
	}
}

// WithEditMessageReplyMarkupInlineMessageID sets the InlineMessageID field.
//
// Required if chat_id and message_id are not specified.
// Identifier of the inline message
func WithEditMessageReplyMarkupInlineMessageID(value string) EditMessageReplyMarkupOption {
	return func(params *EditMessageReplyMarkupParams) EditMessageReplyMarkupOption {
		previous := params.InlineMessageID
		params.InlineMessageID = value

		return WithEditMessageReplyMarkupInlineMessageID(previous)
	}
}

// WithEditMessageReplyMarkupReplyMarkup sets the ReplyMarkup field.
//
// A JSON-serialized object for an [inline keyboard].
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
func WithEditMessageReplyMarkupReplyMarkup(value *InlineKeyboardMarkup) EditMessageReplyMarkupOption {
	return func(params *EditMessageReplyMarkupParams) EditMessageReplyMarkupOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithEditMessageReplyMarkupReplyMarkup(previous)
	}
}

// EditMessageReplyMarkup calls the editMessageReplyMarkup Telegram Bot API method.
//
// Use this method to edit only the reply markup of messages.
// On success, if the edited message is not an inline message, the edited [Message] is returned, otherwise True is returned.
// Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within 48 hours from the time they were sent.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) EditMessageReplyMarkup(params *EditMessageReplyMarkupParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editMessageReplyMarkup", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditMessageTextParams contains parameters for Client.EditMessageText.
type EditMessageTextParams struct {
	// Unique identifier of the business connection on behalf of which the message to be edited was sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Identifier of the message to edit
	MessageID int64 `json:"message_id,omitempty"`

	// Required if chat_id and message_id are not specified.
	// Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// New text of the message, 1-4096 characters after entities parsing
	Text string `json:"text"`

	// Mode for parsing entities in the message text.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in message text, which can be specified instead of parse_mode
	Entities []MessageEntity `json:"entities,omitempty"`

	// Link preview generation options for the message
	LinkPreviewOptions *LinkPreviewOptions `json:"link_preview_options,omitempty"`

	// A JSON-serialized object for an [inline keyboard].
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// EditMessageTextOption configures EditMessageTextParams.
type EditMessageTextOption func(params *EditMessageTextParams) EditMessageTextOption

// Option applies one or more EditMessageTextOption values and returns the last rollback option.
func (r *EditMessageTextParams) Option(opts ...EditMessageTextOption) (previous EditMessageTextOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditMessageTextBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message to be edited was sent
func WithEditMessageTextBusinessConnectionID(value string) EditMessageTextOption {
	return func(params *EditMessageTextParams) EditMessageTextOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithEditMessageTextBusinessConnectionID(previous)
	}
}

// WithEditMessageTextChatID sets the ChatID field.
//
// Required if inline_message_id is not specified.
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithEditMessageTextChatID(value string) EditMessageTextOption {
	return func(params *EditMessageTextParams) EditMessageTextOption {
		previous := params.ChatID
		params.ChatID = value

		return WithEditMessageTextChatID(previous)
	}
}

// WithEditMessageTextMessageID sets the MessageID field.
//
// Required if inline_message_id is not specified.
// Identifier of the message to edit
func WithEditMessageTextMessageID(value int64) EditMessageTextOption {
	return func(params *EditMessageTextParams) EditMessageTextOption {
		previous := params.MessageID
		params.MessageID = value

		return WithEditMessageTextMessageID(previous)
	}
}

// WithEditMessageTextInlineMessageID sets the InlineMessageID field.
//
// Required if chat_id and message_id are not specified.
// Identifier of the inline message
func WithEditMessageTextInlineMessageID(value string) EditMessageTextOption {
	return func(params *EditMessageTextParams) EditMessageTextOption {
		previous := params.InlineMessageID
		params.InlineMessageID = value

		return WithEditMessageTextInlineMessageID(previous)
	}
}

// WithEditMessageTextText sets the Text field.
//
// New text of the message, 1-4096 characters after entities parsing
func WithEditMessageTextText(value string) EditMessageTextOption {
	return func(params *EditMessageTextParams) EditMessageTextOption {
		previous := params.Text
		params.Text = value

		return WithEditMessageTextText(previous)
	}
}

// WithEditMessageTextParseMode sets the ParseMode field.
//
// Mode for parsing entities in the message text.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithEditMessageTextParseMode(value string) EditMessageTextOption {
	return func(params *EditMessageTextParams) EditMessageTextOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithEditMessageTextParseMode(previous)
	}
}

// WithEditMessageTextEntities sets the Entities field.
//
// A JSON-serialized list of special entities that appear in message text, which can be specified instead of parse_mode
func WithEditMessageTextEntities(value []MessageEntity) EditMessageTextOption {
	return func(params *EditMessageTextParams) EditMessageTextOption {
		previous := params.Entities
		params.Entities = value

		return WithEditMessageTextEntities(previous)
	}
}

// WithEditMessageTextLinkPreviewOptions sets the LinkPreviewOptions field.
//
// Link preview generation options for the message
func WithEditMessageTextLinkPreviewOptions(value *LinkPreviewOptions) EditMessageTextOption {
	return func(params *EditMessageTextParams) EditMessageTextOption {
		previous := params.LinkPreviewOptions
		params.LinkPreviewOptions = value

		return WithEditMessageTextLinkPreviewOptions(previous)
	}
}

// WithEditMessageTextReplyMarkup sets the ReplyMarkup field.
//
// A JSON-serialized object for an [inline keyboard].
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
func WithEditMessageTextReplyMarkup(value *InlineKeyboardMarkup) EditMessageTextOption {
	return func(params *EditMessageTextParams) EditMessageTextOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithEditMessageTextReplyMarkup(previous)
	}
}

// EditMessageText calls the editMessageText Telegram Bot API method.
//
// Use this method to edit text and [game] messages.
// On success, if the edited message is not an inline message, the edited [Message] is returned, otherwise True is returned.
// Note that business messages that were not sent by the bot and do not contain an inline keyboard can only be edited within 48 hours from the time they were sent.
//
// [game]: https://core.telegram.org/bots/api#games
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) EditMessageText(params *EditMessageTextParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editMessageText", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditStoryParams contains parameters for Client.EditStory.
type EditStoryParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// Unique identifier of the story to edit
	StoryID int64 `json:"story_id"`

	// Content of the story
	Content InputStoryContent `json:"content"`

	// Caption of the story, 0-2048 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Mode for parsing entities in the story caption.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// A JSON-serialized list of clickable areas to be shown on the story
	Areas []StoryArea `json:"areas,omitempty"`
}

// EditStoryOption configures EditStoryParams.
type EditStoryOption func(params *EditStoryParams) EditStoryOption

// Option applies one or more EditStoryOption values and returns the last rollback option.
func (r *EditStoryParams) Option(opts ...EditStoryOption) (previous EditStoryOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditStoryBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithEditStoryBusinessConnectionID(value string) EditStoryOption {
	return func(params *EditStoryParams) EditStoryOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithEditStoryBusinessConnectionID(previous)
	}
}

// WithEditStoryStoryID sets the StoryID field.
//
// Unique identifier of the story to edit
func WithEditStoryStoryID(value int64) EditStoryOption {
	return func(params *EditStoryParams) EditStoryOption {
		previous := params.StoryID
		params.StoryID = value

		return WithEditStoryStoryID(previous)
	}
}

// WithEditStoryContent sets the Content field.
//
// Content of the story
func WithEditStoryContent(value InputStoryContent) EditStoryOption {
	return func(params *EditStoryParams) EditStoryOption {
		previous := params.Content
		params.Content = value

		return WithEditStoryContent(previous)
	}
}

// WithEditStoryCaption sets the Caption field.
//
// Caption of the story, 0-2048 characters after entities parsing
func WithEditStoryCaption(value string) EditStoryOption {
	return func(params *EditStoryParams) EditStoryOption {
		previous := params.Caption
		params.Caption = value

		return WithEditStoryCaption(previous)
	}
}

// WithEditStoryParseMode sets the ParseMode field.
//
// Mode for parsing entities in the story caption.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithEditStoryParseMode(value string) EditStoryOption {
	return func(params *EditStoryParams) EditStoryOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithEditStoryParseMode(previous)
	}
}

// WithEditStoryCaptionEntities sets the CaptionEntities field.
//
// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
func WithEditStoryCaptionEntities(value []MessageEntity) EditStoryOption {
	return func(params *EditStoryParams) EditStoryOption {
		previous := params.CaptionEntities
		params.CaptionEntities = value

		return WithEditStoryCaptionEntities(previous)
	}
}

// WithEditStoryAreas sets the Areas field.
//
// A JSON-serialized list of clickable areas to be shown on the story
func WithEditStoryAreas(value []StoryArea) EditStoryOption {
	return func(params *EditStoryParams) EditStoryOption {
		previous := params.Areas
		params.Areas = value

		return WithEditStoryAreas(previous)
	}
}

// EditStory calls the editStory Telegram Bot API method.
//
// Edits a story previously posted by the bot on behalf of a managed business account.
// Requires the can_manage_stories business bot right.
// Returns [Story] on success.
//
// [Story]: https://core.telegram.org/bots/api#story
func (c *Client) EditStory(params *EditStoryParams) (ret *Story, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editStory", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Story)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// EditUserStarSubscriptionParams contains parameters for Client.EditUserStarSubscription.
type EditUserStarSubscriptionParams struct {
	// Identifier of the user whose subscription will be edited
	UserID int64 `json:"user_id"`

	// Telegram payment identifier for the subscription
	TelegramPaymentChargeID string `json:"telegram_payment_charge_id"`

	// Pass True to cancel extension of the user subscription; the subscription must be active up to the end of the current subscription period.
	// Pass False to allow the user to re-enable a subscription that was previously canceled by the bot.
	IsCanceled bool `json:"is_canceled"`
}

// EditUserStarSubscriptionOption configures EditUserStarSubscriptionParams.
type EditUserStarSubscriptionOption func(params *EditUserStarSubscriptionParams) EditUserStarSubscriptionOption

// Option applies one or more EditUserStarSubscriptionOption values and returns the last rollback option.
func (r *EditUserStarSubscriptionParams) Option(opts ...EditUserStarSubscriptionOption) (previous EditUserStarSubscriptionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithEditUserStarSubscriptionUserID sets the UserID field.
//
// Identifier of the user whose subscription will be edited
func WithEditUserStarSubscriptionUserID(value int64) EditUserStarSubscriptionOption {
	return func(params *EditUserStarSubscriptionParams) EditUserStarSubscriptionOption {
		previous := params.UserID
		params.UserID = value

		return WithEditUserStarSubscriptionUserID(previous)
	}
}

// WithEditUserStarSubscriptionTelegramPaymentChargeID sets the TelegramPaymentChargeID field.
//
// Telegram payment identifier for the subscription
func WithEditUserStarSubscriptionTelegramPaymentChargeID(value string) EditUserStarSubscriptionOption {
	return func(params *EditUserStarSubscriptionParams) EditUserStarSubscriptionOption {
		previous := params.TelegramPaymentChargeID
		params.TelegramPaymentChargeID = value

		return WithEditUserStarSubscriptionTelegramPaymentChargeID(previous)
	}
}

// WithEditUserStarSubscriptionIsCanceled sets the IsCanceled field.
//
// Pass True to cancel extension of the user subscription; the subscription must be active up to the end of the current subscription period.
// Pass False to allow the user to re-enable a subscription that was previously canceled by the bot.
func WithEditUserStarSubscriptionIsCanceled(value bool) EditUserStarSubscriptionOption {
	return func(params *EditUserStarSubscriptionParams) EditUserStarSubscriptionOption {
		previous := params.IsCanceled
		params.IsCanceled = value

		return WithEditUserStarSubscriptionIsCanceled(previous)
	}
}

// EditUserStarSubscription calls the editUserStarSubscription Telegram Bot API method.
//
// Allows the bot to cancel or re-enable extension of a subscription paid in Telegram Stars.
// Returns True on success.
func (c *Client) EditUserStarSubscription(params *EditUserStarSubscriptionParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("editUserStarSubscription", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// ExportChatInviteLinkParams contains parameters for Client.ExportChatInviteLink.
type ExportChatInviteLinkParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`
}

// ExportChatInviteLinkOption configures ExportChatInviteLinkParams.
type ExportChatInviteLinkOption func(params *ExportChatInviteLinkParams) ExportChatInviteLinkOption

// Option applies one or more ExportChatInviteLinkOption values and returns the last rollback option.
func (r *ExportChatInviteLinkParams) Option(opts ...ExportChatInviteLinkOption) (previous ExportChatInviteLinkOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithExportChatInviteLinkChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithExportChatInviteLinkChatID(value string) ExportChatInviteLinkOption {
	return func(params *ExportChatInviteLinkParams) ExportChatInviteLinkOption {
		previous := params.ChatID
		params.ChatID = value

		return WithExportChatInviteLinkChatID(previous)
	}
}

// ExportChatInviteLink calls the exportChatInviteLink Telegram Bot API method.
//
// Use this method to generate a new primary invite link for a chat; any previously generated primary link is revoked.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns the new invite link as String on success.
func (c *Client) ExportChatInviteLink(params *ExportChatInviteLinkParams) (ret string, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("exportChatInviteLink", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// ForwardMessageParams contains parameters for Client.ForwardMessage.
type ForwardMessageParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be forwarded; required if the message is forwarded to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Unique identifier for the chat where the original message was sent (or channel username in the format @channelusername)
	FromChatID string `json:"from_chat_id"`

	// New start timestamp for the forwarded video in the message
	VideoStartTimestamp int64 `json:"video_start_timestamp,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the forwarded message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Unique identifier of the message effect to be added to the message; only available when forwarding to private chats
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Message identifier in the chat specified in from_chat_id
	MessageID int64 `json:"message_id"`
}

// ForwardMessageOption configures ForwardMessageParams.
type ForwardMessageOption func(params *ForwardMessageParams) ForwardMessageOption

// Option applies one or more ForwardMessageOption values and returns the last rollback option.
func (r *ForwardMessageParams) Option(opts ...ForwardMessageOption) (previous ForwardMessageOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithForwardMessageChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithForwardMessageChatID(value string) ForwardMessageOption {
	return func(params *ForwardMessageParams) ForwardMessageOption {
		previous := params.ChatID
		params.ChatID = value

		return WithForwardMessageChatID(previous)
	}
}

// WithForwardMessageMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithForwardMessageMessageThreadID(value int64) ForwardMessageOption {
	return func(params *ForwardMessageParams) ForwardMessageOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithForwardMessageMessageThreadID(previous)
	}
}

// WithForwardMessageDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be forwarded; required if the message is forwarded to a direct messages chat
func WithForwardMessageDirectMessagesTopicID(value int64) ForwardMessageOption {
	return func(params *ForwardMessageParams) ForwardMessageOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithForwardMessageDirectMessagesTopicID(previous)
	}
}

// WithForwardMessageFromChatID sets the FromChatID field.
//
// Unique identifier for the chat where the original message was sent (or channel username in the format @channelusername)
func WithForwardMessageFromChatID(value string) ForwardMessageOption {
	return func(params *ForwardMessageParams) ForwardMessageOption {
		previous := params.FromChatID
		params.FromChatID = value

		return WithForwardMessageFromChatID(previous)
	}
}

// WithForwardMessageVideoStartTimestamp sets the VideoStartTimestamp field.
//
// New start timestamp for the forwarded video in the message
func WithForwardMessageVideoStartTimestamp(value int64) ForwardMessageOption {
	return func(params *ForwardMessageParams) ForwardMessageOption {
		previous := params.VideoStartTimestamp
		params.VideoStartTimestamp = value

		return WithForwardMessageVideoStartTimestamp(previous)
	}
}

// WithForwardMessageDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithForwardMessageDisableNotification(value bool) ForwardMessageOption {
	return func(params *ForwardMessageParams) ForwardMessageOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithForwardMessageDisableNotification(previous)
	}
}

// WithForwardMessageProtectContent sets the ProtectContent field.
//
// Protects the contents of the forwarded message from forwarding and saving
func WithForwardMessageProtectContent(value bool) ForwardMessageOption {
	return func(params *ForwardMessageParams) ForwardMessageOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithForwardMessageProtectContent(previous)
	}
}

// WithForwardMessageMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; only available when forwarding to private chats
func WithForwardMessageMessageEffectID(value string) ForwardMessageOption {
	return func(params *ForwardMessageParams) ForwardMessageOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithForwardMessageMessageEffectID(previous)
	}
}

// WithForwardMessageSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only
func WithForwardMessageSuggestedPostParameters(value *SuggestedPostParameters) ForwardMessageOption {
	return func(params *ForwardMessageParams) ForwardMessageOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithForwardMessageSuggestedPostParameters(previous)
	}
}

// WithForwardMessageMessageID sets the MessageID field.
//
// Message identifier in the chat specified in from_chat_id
func WithForwardMessageMessageID(value int64) ForwardMessageOption {
	return func(params *ForwardMessageParams) ForwardMessageOption {
		previous := params.MessageID
		params.MessageID = value

		return WithForwardMessageMessageID(previous)
	}
}

// ForwardMessage calls the forwardMessage Telegram Bot API method.
//
// Use this method to forward messages of any kind.
// Service messages and messages with protected content can't be forwarded.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) ForwardMessage(params *ForwardMessageParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("forwardMessage", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// ForwardMessagesParams contains parameters for Client.ForwardMessages.
type ForwardMessagesParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the messages will be forwarded; required if the messages are forwarded to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Unique identifier for the chat where the original messages were sent (or channel username in the format @channelusername)
	FromChatID string `json:"from_chat_id"`

	// A JSON-serialized list of 1-100 identifiers of messages in the chat from_chat_id to forward.
	// The identifiers must be specified in a strictly increasing order.
	MessageIDs []int64 `json:"message_ids"`

	// Sends the messages [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the forwarded messages from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`
}

// ForwardMessagesOption configures ForwardMessagesParams.
type ForwardMessagesOption func(params *ForwardMessagesParams) ForwardMessagesOption

// Option applies one or more ForwardMessagesOption values and returns the last rollback option.
func (r *ForwardMessagesParams) Option(opts ...ForwardMessagesOption) (previous ForwardMessagesOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithForwardMessagesChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithForwardMessagesChatID(value string) ForwardMessagesOption {
	return func(params *ForwardMessagesParams) ForwardMessagesOption {
		previous := params.ChatID
		params.ChatID = value

		return WithForwardMessagesChatID(previous)
	}
}

// WithForwardMessagesMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithForwardMessagesMessageThreadID(value int64) ForwardMessagesOption {
	return func(params *ForwardMessagesParams) ForwardMessagesOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithForwardMessagesMessageThreadID(previous)
	}
}

// WithForwardMessagesDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the messages will be forwarded; required if the messages are forwarded to a direct messages chat
func WithForwardMessagesDirectMessagesTopicID(value int64) ForwardMessagesOption {
	return func(params *ForwardMessagesParams) ForwardMessagesOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithForwardMessagesDirectMessagesTopicID(previous)
	}
}

// WithForwardMessagesFromChatID sets the FromChatID field.
//
// Unique identifier for the chat where the original messages were sent (or channel username in the format @channelusername)
func WithForwardMessagesFromChatID(value string) ForwardMessagesOption {
	return func(params *ForwardMessagesParams) ForwardMessagesOption {
		previous := params.FromChatID
		params.FromChatID = value

		return WithForwardMessagesFromChatID(previous)
	}
}

// WithForwardMessagesMessageIDs sets the MessageIDs field.
//
// A JSON-serialized list of 1-100 identifiers of messages in the chat from_chat_id to forward.
// The identifiers must be specified in a strictly increasing order.
func WithForwardMessagesMessageIDs(value []int64) ForwardMessagesOption {
	return func(params *ForwardMessagesParams) ForwardMessagesOption {
		previous := params.MessageIDs
		params.MessageIDs = value

		return WithForwardMessagesMessageIDs(previous)
	}
}

// WithForwardMessagesDisableNotification sets the DisableNotification field.
//
// Sends the messages [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithForwardMessagesDisableNotification(value bool) ForwardMessagesOption {
	return func(params *ForwardMessagesParams) ForwardMessagesOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithForwardMessagesDisableNotification(previous)
	}
}

// WithForwardMessagesProtectContent sets the ProtectContent field.
//
// Protects the contents of the forwarded messages from forwarding and saving
func WithForwardMessagesProtectContent(value bool) ForwardMessagesOption {
	return func(params *ForwardMessagesParams) ForwardMessagesOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithForwardMessagesProtectContent(previous)
	}
}

// ForwardMessages calls the forwardMessages Telegram Bot API method.
//
// Use this method to forward multiple messages of any kind.
// If some of the specified messages can't be found or forwarded, they are skipped.
// Service messages and messages with protected content can't be forwarded.
// Album grouping is kept for forwarded messages.
// On success, an array of [MessageId] of the sent messages is returned.
//
// [MessageId]: https://core.telegram.org/bots/api#messageid
func (c *Client) ForwardMessages(params *ForwardMessagesParams) (ret *MessageId, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("forwardMessages", reader, contentType)
	if err != nil {
		return
	}

	ret = new(MessageId)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetAvailableGiftsParams contains parameters for Client.GetAvailableGifts.
type GetAvailableGiftsParams struct {
}

// GetAvailableGiftsOption configures GetAvailableGiftsParams.
type GetAvailableGiftsOption func(params *GetAvailableGiftsParams) GetAvailableGiftsOption

// Option applies one or more GetAvailableGiftsOption values and returns the last rollback option.
func (r *GetAvailableGiftsParams) Option(opts ...GetAvailableGiftsOption) (previous GetAvailableGiftsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// GetAvailableGifts calls the getAvailableGifts Telegram Bot API method.
//
// Returns the list of gifts that can be sent by the bot to users and channel chats.
// Requires no parameters.
// Returns a [Gifts] object.
//
// [Gifts]: https://core.telegram.org/bots/api#gifts
func (c *Client) GetAvailableGifts(params *GetAvailableGiftsParams) (ret *Gifts, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getAvailableGifts", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Gifts)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetBusinessAccountGiftsParams contains parameters for Client.GetBusinessAccountGifts.
type GetBusinessAccountGiftsParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// Pass True to exclude gifts that aren't saved to the account's profile page
	ExcludeUnsaved bool `json:"exclude_unsaved,omitempty"`

	// Pass True to exclude gifts that are saved to the account's profile page
	ExcludeSaved bool `json:"exclude_saved,omitempty"`

	// Pass True to exclude gifts that can be purchased an unlimited number of times
	ExcludeUnlimited bool `json:"exclude_unlimited,omitempty"`

	// Pass True to exclude gifts that can be purchased a limited number of times and can be upgraded to unique
	ExcludeLimitedUpgradable bool `json:"exclude_limited_upgradable,omitempty"`

	// Pass True to exclude gifts that can be purchased a limited number of times and can't be upgraded to unique
	ExcludeLimitedNonUpgradable bool `json:"exclude_limited_non_upgradable,omitempty"`

	// Pass True to exclude unique gifts
	ExcludeUnique bool `json:"exclude_unique,omitempty"`

	// Pass True to exclude gifts that were assigned from the TON blockchain and can't be resold or transferred in Telegram
	ExcludeFromBlockchain bool `json:"exclude_from_blockchain,omitempty"`

	// Pass True to sort results by gift price instead of send date.
	// Sorting is applied before pagination.
	SortByPrice bool `json:"sort_by_price,omitempty"`

	// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
	Offset string `json:"offset,omitempty"`

	// The maximum number of gifts to be returned; 1-100.
	// Defaults to 100
	Limit int64 `json:"limit,omitempty"`
}

// GetBusinessAccountGiftsOption configures GetBusinessAccountGiftsParams.
type GetBusinessAccountGiftsOption func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption

// Option applies one or more GetBusinessAccountGiftsOption values and returns the last rollback option.
func (r *GetBusinessAccountGiftsParams) Option(opts ...GetBusinessAccountGiftsOption) (previous GetBusinessAccountGiftsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetBusinessAccountGiftsBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithGetBusinessAccountGiftsBusinessConnectionID(value string) GetBusinessAccountGiftsOption {
	return func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithGetBusinessAccountGiftsBusinessConnectionID(previous)
	}
}

// WithGetBusinessAccountGiftsExcludeUnsaved sets the ExcludeUnsaved field.
//
// Pass True to exclude gifts that aren't saved to the account's profile page
func WithGetBusinessAccountGiftsExcludeUnsaved(value bool) GetBusinessAccountGiftsOption {
	return func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption {
		previous := params.ExcludeUnsaved
		params.ExcludeUnsaved = value

		return WithGetBusinessAccountGiftsExcludeUnsaved(previous)
	}
}

// WithGetBusinessAccountGiftsExcludeSaved sets the ExcludeSaved field.
//
// Pass True to exclude gifts that are saved to the account's profile page
func WithGetBusinessAccountGiftsExcludeSaved(value bool) GetBusinessAccountGiftsOption {
	return func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption {
		previous := params.ExcludeSaved
		params.ExcludeSaved = value

		return WithGetBusinessAccountGiftsExcludeSaved(previous)
	}
}

// WithGetBusinessAccountGiftsExcludeUnlimited sets the ExcludeUnlimited field.
//
// Pass True to exclude gifts that can be purchased an unlimited number of times
func WithGetBusinessAccountGiftsExcludeUnlimited(value bool) GetBusinessAccountGiftsOption {
	return func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption {
		previous := params.ExcludeUnlimited
		params.ExcludeUnlimited = value

		return WithGetBusinessAccountGiftsExcludeUnlimited(previous)
	}
}

// WithGetBusinessAccountGiftsExcludeLimitedUpgradable sets the ExcludeLimitedUpgradable field.
//
// Pass True to exclude gifts that can be purchased a limited number of times and can be upgraded to unique
func WithGetBusinessAccountGiftsExcludeLimitedUpgradable(value bool) GetBusinessAccountGiftsOption {
	return func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption {
		previous := params.ExcludeLimitedUpgradable
		params.ExcludeLimitedUpgradable = value

		return WithGetBusinessAccountGiftsExcludeLimitedUpgradable(previous)
	}
}

// WithGetBusinessAccountGiftsExcludeLimitedNonUpgradable sets the ExcludeLimitedNonUpgradable field.
//
// Pass True to exclude gifts that can be purchased a limited number of times and can't be upgraded to unique
func WithGetBusinessAccountGiftsExcludeLimitedNonUpgradable(value bool) GetBusinessAccountGiftsOption {
	return func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption {
		previous := params.ExcludeLimitedNonUpgradable
		params.ExcludeLimitedNonUpgradable = value

		return WithGetBusinessAccountGiftsExcludeLimitedNonUpgradable(previous)
	}
}

// WithGetBusinessAccountGiftsExcludeUnique sets the ExcludeUnique field.
//
// Pass True to exclude unique gifts
func WithGetBusinessAccountGiftsExcludeUnique(value bool) GetBusinessAccountGiftsOption {
	return func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption {
		previous := params.ExcludeUnique
		params.ExcludeUnique = value

		return WithGetBusinessAccountGiftsExcludeUnique(previous)
	}
}

// WithGetBusinessAccountGiftsExcludeFromBlockchain sets the ExcludeFromBlockchain field.
//
// Pass True to exclude gifts that were assigned from the TON blockchain and can't be resold or transferred in Telegram
func WithGetBusinessAccountGiftsExcludeFromBlockchain(value bool) GetBusinessAccountGiftsOption {
	return func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption {
		previous := params.ExcludeFromBlockchain
		params.ExcludeFromBlockchain = value

		return WithGetBusinessAccountGiftsExcludeFromBlockchain(previous)
	}
}

// WithGetBusinessAccountGiftsSortByPrice sets the SortByPrice field.
//
// Pass True to sort results by gift price instead of send date.
// Sorting is applied before pagination.
func WithGetBusinessAccountGiftsSortByPrice(value bool) GetBusinessAccountGiftsOption {
	return func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption {
		previous := params.SortByPrice
		params.SortByPrice = value

		return WithGetBusinessAccountGiftsSortByPrice(previous)
	}
}

// WithGetBusinessAccountGiftsOffset sets the Offset field.
//
// Offset of the first entry to return as received from the previous request; use empty string to get the first chunk of results
func WithGetBusinessAccountGiftsOffset(value string) GetBusinessAccountGiftsOption {
	return func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption {
		previous := params.Offset
		params.Offset = value

		return WithGetBusinessAccountGiftsOffset(previous)
	}
}

// WithGetBusinessAccountGiftsLimit sets the Limit field.
//
// The maximum number of gifts to be returned; 1-100.
// Defaults to 100
func WithGetBusinessAccountGiftsLimit(value int64) GetBusinessAccountGiftsOption {
	return func(params *GetBusinessAccountGiftsParams) GetBusinessAccountGiftsOption {
		previous := params.Limit
		params.Limit = value

		return WithGetBusinessAccountGiftsLimit(previous)
	}
}

// GetBusinessAccountGifts calls the getBusinessAccountGifts Telegram Bot API method.
//
// Returns the gifts received and owned by a managed business account.
// Requires the can_view_gifts_and_stars business bot right.
// Returns [OwnedGifts] on success.
//
// [OwnedGifts]: https://core.telegram.org/bots/api#ownedgifts
func (c *Client) GetBusinessAccountGifts(params *GetBusinessAccountGiftsParams) (ret *OwnedGifts, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getBusinessAccountGifts", reader, contentType)
	if err != nil {
		return
	}

	ret = new(OwnedGifts)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetBusinessAccountStarBalanceParams contains parameters for Client.GetBusinessAccountStarBalance.
type GetBusinessAccountStarBalanceParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`
}

// GetBusinessAccountStarBalanceOption configures GetBusinessAccountStarBalanceParams.
type GetBusinessAccountStarBalanceOption func(params *GetBusinessAccountStarBalanceParams) GetBusinessAccountStarBalanceOption

// Option applies one or more GetBusinessAccountStarBalanceOption values and returns the last rollback option.
func (r *GetBusinessAccountStarBalanceParams) Option(opts ...GetBusinessAccountStarBalanceOption) (previous GetBusinessAccountStarBalanceOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetBusinessAccountStarBalanceBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithGetBusinessAccountStarBalanceBusinessConnectionID(value string) GetBusinessAccountStarBalanceOption {
	return func(params *GetBusinessAccountStarBalanceParams) GetBusinessAccountStarBalanceOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithGetBusinessAccountStarBalanceBusinessConnectionID(previous)
	}
}

// GetBusinessAccountStarBalance calls the getBusinessAccountStarBalance Telegram Bot API method.
//
// Returns the amount of Telegram Stars owned by a managed business account.
// Requires the can_view_gifts_and_stars business bot right.
// Returns [StarAmount] on success.
//
// [StarAmount]: https://core.telegram.org/bots/api#staramount
func (c *Client) GetBusinessAccountStarBalance(params *GetBusinessAccountStarBalanceParams) (ret *StarAmount, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getBusinessAccountStarBalance", reader, contentType)
	if err != nil {
		return
	}

	ret = new(StarAmount)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetBusinessConnectionParams contains parameters for Client.GetBusinessConnection.
type GetBusinessConnectionParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`
}

// GetBusinessConnectionOption configures GetBusinessConnectionParams.
type GetBusinessConnectionOption func(params *GetBusinessConnectionParams) GetBusinessConnectionOption

// Option applies one or more GetBusinessConnectionOption values and returns the last rollback option.
func (r *GetBusinessConnectionParams) Option(opts ...GetBusinessConnectionOption) (previous GetBusinessConnectionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetBusinessConnectionBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithGetBusinessConnectionBusinessConnectionID(value string) GetBusinessConnectionOption {
	return func(params *GetBusinessConnectionParams) GetBusinessConnectionOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithGetBusinessConnectionBusinessConnectionID(previous)
	}
}

// GetBusinessConnection calls the getBusinessConnection Telegram Bot API method.
//
// Use this method to get information about the connection of the bot with a business account.
// Returns a [BusinessConnection] object on success.
//
// [BusinessConnection]: https://core.telegram.org/bots/api#businessconnection
func (c *Client) GetBusinessConnection(params *GetBusinessConnectionParams) (ret *BusinessConnection, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getBusinessConnection", reader, contentType)
	if err != nil {
		return
	}

	ret = new(BusinessConnection)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetChatParams contains parameters for Client.GetChat.
type GetChatParams struct {
	// Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
	ChatID string `json:"chat_id"`
}

// GetChatOption configures GetChatParams.
type GetChatOption func(params *GetChatParams) GetChatOption

// Option applies one or more GetChatOption values and returns the last rollback option.
func (r *GetChatParams) Option(opts ...GetChatOption) (previous GetChatOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetChatChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
func WithGetChatChatID(value string) GetChatOption {
	return func(params *GetChatParams) GetChatOption {
		previous := params.ChatID
		params.ChatID = value

		return WithGetChatChatID(previous)
	}
}

// GetChat calls the getChat Telegram Bot API method.
//
// Use this method to get up-to-date information about the chat.
// Returns a [ChatFullInfo] object on success.
//
// [ChatFullInfo]: https://core.telegram.org/bots/api#chatfullinfo
func (c *Client) GetChat(params *GetChatParams) (ret *ChatFullInfo, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getChat", reader, contentType)
	if err != nil {
		return
	}

	ret = new(ChatFullInfo)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetChatAdministratorsParams contains parameters for Client.GetChatAdministrators.
type GetChatAdministratorsParams struct {
	// Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
	ChatID string `json:"chat_id"`
}

// GetChatAdministratorsOption configures GetChatAdministratorsParams.
type GetChatAdministratorsOption func(params *GetChatAdministratorsParams) GetChatAdministratorsOption

// Option applies one or more GetChatAdministratorsOption values and returns the last rollback option.
func (r *GetChatAdministratorsParams) Option(opts ...GetChatAdministratorsOption) (previous GetChatAdministratorsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetChatAdministratorsChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
func WithGetChatAdministratorsChatID(value string) GetChatAdministratorsOption {
	return func(params *GetChatAdministratorsParams) GetChatAdministratorsOption {
		previous := params.ChatID
		params.ChatID = value

		return WithGetChatAdministratorsChatID(previous)
	}
}

// GetChatAdministrators calls the getChatAdministrators Telegram Bot API method.
//
// Use this method to get a list of administrators in a chat, which aren't bots.
// Returns an Array of [ChatMember] objects.
//
// [ChatMember]: https://core.telegram.org/bots/api#chatmember
func (c *Client) GetChatAdministrators(params *GetChatAdministratorsParams) (ret []ChatMember, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getChatAdministrators", reader, contentType)
	if err != nil {
		return
	}

	ret = make([]ChatMember, 0, 100)
	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetChatGiftsParams contains parameters for Client.GetChatGifts.
type GetChatGiftsParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Pass True to exclude gifts that aren't saved to the chat's profile page.
	// Always True, unless the bot has the can_post_messages administrator right in the channel.
	ExcludeUnsaved bool `json:"exclude_unsaved,omitempty"`

	// Pass True to exclude gifts that are saved to the chat's profile page.
	// Always False, unless the bot has the can_post_messages administrator right in the channel.
	ExcludeSaved bool `json:"exclude_saved,omitempty"`

	// Pass True to exclude gifts that can be purchased an unlimited number of times
	ExcludeUnlimited bool `json:"exclude_unlimited,omitempty"`

	// Pass True to exclude gifts that can be purchased a limited number of times and can be upgraded to unique
	ExcludeLimitedUpgradable bool `json:"exclude_limited_upgradable,omitempty"`

	// Pass True to exclude gifts that can be purchased a limited number of times and can't be upgraded to unique
	ExcludeLimitedNonUpgradable bool `json:"exclude_limited_non_upgradable,omitempty"`

	// Pass True to exclude gifts that were assigned from the TON blockchain and can't be resold or transferred in Telegram
	ExcludeFromBlockchain bool `json:"exclude_from_blockchain,omitempty"`

	// Pass True to exclude unique gifts
	ExcludeUnique bool `json:"exclude_unique,omitempty"`

	// Pass True to sort results by gift price instead of send date.
	// Sorting is applied before pagination.
	SortByPrice bool `json:"sort_by_price,omitempty"`

	// Offset of the first entry to return as received from the previous request; use an empty string to get the first chunk of results
	Offset string `json:"offset,omitempty"`

	// The maximum number of gifts to be returned; 1-100.
	// Defaults to 100
	Limit int64 `json:"limit,omitempty"`
}

// GetChatGiftsOption configures GetChatGiftsParams.
type GetChatGiftsOption func(params *GetChatGiftsParams) GetChatGiftsOption

// Option applies one or more GetChatGiftsOption values and returns the last rollback option.
func (r *GetChatGiftsParams) Option(opts ...GetChatGiftsOption) (previous GetChatGiftsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetChatGiftsChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithGetChatGiftsChatID(value string) GetChatGiftsOption {
	return func(params *GetChatGiftsParams) GetChatGiftsOption {
		previous := params.ChatID
		params.ChatID = value

		return WithGetChatGiftsChatID(previous)
	}
}

// WithGetChatGiftsExcludeUnsaved sets the ExcludeUnsaved field.
//
// Pass True to exclude gifts that aren't saved to the chat's profile page.
// Always True, unless the bot has the can_post_messages administrator right in the channel.
func WithGetChatGiftsExcludeUnsaved(value bool) GetChatGiftsOption {
	return func(params *GetChatGiftsParams) GetChatGiftsOption {
		previous := params.ExcludeUnsaved
		params.ExcludeUnsaved = value

		return WithGetChatGiftsExcludeUnsaved(previous)
	}
}

// WithGetChatGiftsExcludeSaved sets the ExcludeSaved field.
//
// Pass True to exclude gifts that are saved to the chat's profile page.
// Always False, unless the bot has the can_post_messages administrator right in the channel.
func WithGetChatGiftsExcludeSaved(value bool) GetChatGiftsOption {
	return func(params *GetChatGiftsParams) GetChatGiftsOption {
		previous := params.ExcludeSaved
		params.ExcludeSaved = value

		return WithGetChatGiftsExcludeSaved(previous)
	}
}

// WithGetChatGiftsExcludeUnlimited sets the ExcludeUnlimited field.
//
// Pass True to exclude gifts that can be purchased an unlimited number of times
func WithGetChatGiftsExcludeUnlimited(value bool) GetChatGiftsOption {
	return func(params *GetChatGiftsParams) GetChatGiftsOption {
		previous := params.ExcludeUnlimited
		params.ExcludeUnlimited = value

		return WithGetChatGiftsExcludeUnlimited(previous)
	}
}

// WithGetChatGiftsExcludeLimitedUpgradable sets the ExcludeLimitedUpgradable field.
//
// Pass True to exclude gifts that can be purchased a limited number of times and can be upgraded to unique
func WithGetChatGiftsExcludeLimitedUpgradable(value bool) GetChatGiftsOption {
	return func(params *GetChatGiftsParams) GetChatGiftsOption {
		previous := params.ExcludeLimitedUpgradable
		params.ExcludeLimitedUpgradable = value

		return WithGetChatGiftsExcludeLimitedUpgradable(previous)
	}
}

// WithGetChatGiftsExcludeLimitedNonUpgradable sets the ExcludeLimitedNonUpgradable field.
//
// Pass True to exclude gifts that can be purchased a limited number of times and can't be upgraded to unique
func WithGetChatGiftsExcludeLimitedNonUpgradable(value bool) GetChatGiftsOption {
	return func(params *GetChatGiftsParams) GetChatGiftsOption {
		previous := params.ExcludeLimitedNonUpgradable
		params.ExcludeLimitedNonUpgradable = value

		return WithGetChatGiftsExcludeLimitedNonUpgradable(previous)
	}
}

// WithGetChatGiftsExcludeFromBlockchain sets the ExcludeFromBlockchain field.
//
// Pass True to exclude gifts that were assigned from the TON blockchain and can't be resold or transferred in Telegram
func WithGetChatGiftsExcludeFromBlockchain(value bool) GetChatGiftsOption {
	return func(params *GetChatGiftsParams) GetChatGiftsOption {
		previous := params.ExcludeFromBlockchain
		params.ExcludeFromBlockchain = value

		return WithGetChatGiftsExcludeFromBlockchain(previous)
	}
}

// WithGetChatGiftsExcludeUnique sets the ExcludeUnique field.
//
// Pass True to exclude unique gifts
func WithGetChatGiftsExcludeUnique(value bool) GetChatGiftsOption {
	return func(params *GetChatGiftsParams) GetChatGiftsOption {
		previous := params.ExcludeUnique
		params.ExcludeUnique = value

		return WithGetChatGiftsExcludeUnique(previous)
	}
}

// WithGetChatGiftsSortByPrice sets the SortByPrice field.
//
// Pass True to sort results by gift price instead of send date.
// Sorting is applied before pagination.
func WithGetChatGiftsSortByPrice(value bool) GetChatGiftsOption {
	return func(params *GetChatGiftsParams) GetChatGiftsOption {
		previous := params.SortByPrice
		params.SortByPrice = value

		return WithGetChatGiftsSortByPrice(previous)
	}
}

// WithGetChatGiftsOffset sets the Offset field.
//
// Offset of the first entry to return as received from the previous request; use an empty string to get the first chunk of results
func WithGetChatGiftsOffset(value string) GetChatGiftsOption {
	return func(params *GetChatGiftsParams) GetChatGiftsOption {
		previous := params.Offset
		params.Offset = value

		return WithGetChatGiftsOffset(previous)
	}
}

// WithGetChatGiftsLimit sets the Limit field.
//
// The maximum number of gifts to be returned; 1-100.
// Defaults to 100
func WithGetChatGiftsLimit(value int64) GetChatGiftsOption {
	return func(params *GetChatGiftsParams) GetChatGiftsOption {
		previous := params.Limit
		params.Limit = value

		return WithGetChatGiftsLimit(previous)
	}
}

// GetChatGifts calls the getChatGifts Telegram Bot API method.
//
// Returns the gifts owned by a chat.
// Returns [OwnedGifts] on success.
//
// [OwnedGifts]: https://core.telegram.org/bots/api#ownedgifts
func (c *Client) GetChatGifts(params *GetChatGiftsParams) (ret *OwnedGifts, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getChatGifts", reader, contentType)
	if err != nil {
		return
	}

	ret = new(OwnedGifts)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetChatMemberParams contains parameters for Client.GetChatMember.
type GetChatMemberParams struct {
	// Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
}

// GetChatMemberOption configures GetChatMemberParams.
type GetChatMemberOption func(params *GetChatMemberParams) GetChatMemberOption

// Option applies one or more GetChatMemberOption values and returns the last rollback option.
func (r *GetChatMemberParams) Option(opts ...GetChatMemberOption) (previous GetChatMemberOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetChatMemberChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
func WithGetChatMemberChatID(value string) GetChatMemberOption {
	return func(params *GetChatMemberParams) GetChatMemberOption {
		previous := params.ChatID
		params.ChatID = value

		return WithGetChatMemberChatID(previous)
	}
}

// WithGetChatMemberUserID sets the UserID field.
//
// Unique identifier of the target user
func WithGetChatMemberUserID(value int64) GetChatMemberOption {
	return func(params *GetChatMemberParams) GetChatMemberOption {
		previous := params.UserID
		params.UserID = value

		return WithGetChatMemberUserID(previous)
	}
}

// GetChatMember calls the getChatMember Telegram Bot API method.
//
// Use this method to get information about a member of a chat.
// The method is only guaranteed to work for other users if the bot is an administrator in the chat.
// Returns a [ChatMember] object on success.
//
// [ChatMember]: https://core.telegram.org/bots/api#chatmember
func (c *Client) GetChatMember(params *GetChatMemberParams) (ret *ChatMember, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getChatMember", reader, contentType)
	if err != nil {
		return
	}

	ret = new(ChatMember)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetChatMemberCountParams contains parameters for Client.GetChatMemberCount.
type GetChatMemberCountParams struct {
	// Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
	ChatID string `json:"chat_id"`
}

// GetChatMemberCountOption configures GetChatMemberCountParams.
type GetChatMemberCountOption func(params *GetChatMemberCountParams) GetChatMemberCountOption

// Option applies one or more GetChatMemberCountOption values and returns the last rollback option.
func (r *GetChatMemberCountParams) Option(opts ...GetChatMemberCountOption) (previous GetChatMemberCountOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetChatMemberCountChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername)
func WithGetChatMemberCountChatID(value string) GetChatMemberCountOption {
	return func(params *GetChatMemberCountParams) GetChatMemberCountOption {
		previous := params.ChatID
		params.ChatID = value

		return WithGetChatMemberCountChatID(previous)
	}
}

// GetChatMemberCount calls the getChatMemberCount Telegram Bot API method.
//
// Use this method to get the number of members in a chat.
// Returns Int on success.
func (c *Client) GetChatMemberCount(params *GetChatMemberCountParams) (ret int64, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getChatMemberCount", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetChatMenuButtonParams contains parameters for Client.GetChatMenuButton.
type GetChatMenuButtonParams struct {
	// Unique identifier for the target private chat.
	// If not specified, default bot's menu button will be returned
	ChatID int64 `json:"chat_id,omitempty"`
}

// GetChatMenuButtonOption configures GetChatMenuButtonParams.
type GetChatMenuButtonOption func(params *GetChatMenuButtonParams) GetChatMenuButtonOption

// Option applies one or more GetChatMenuButtonOption values and returns the last rollback option.
func (r *GetChatMenuButtonParams) Option(opts ...GetChatMenuButtonOption) (previous GetChatMenuButtonOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetChatMenuButtonChatID sets the ChatID field.
//
// Unique identifier for the target private chat.
// If not specified, default bot's menu button will be returned
func WithGetChatMenuButtonChatID(value int64) GetChatMenuButtonOption {
	return func(params *GetChatMenuButtonParams) GetChatMenuButtonOption {
		previous := params.ChatID
		params.ChatID = value

		return WithGetChatMenuButtonChatID(previous)
	}
}

// GetChatMenuButton calls the getChatMenuButton Telegram Bot API method.
//
// Use this method to get the current value of the bot's menu button in a private chat, or the default menu button.
// Returns [MenuButton] on success.
//
// [MenuButton]: https://core.telegram.org/bots/api#menubutton
func (c *Client) GetChatMenuButton(params *GetChatMenuButtonParams) (ret *MenuButton, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getChatMenuButton", reader, contentType)
	if err != nil {
		return
	}

	ret = new(MenuButton)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetCustomEmojiStickersParams contains parameters for Client.GetCustomEmojiStickers.
type GetCustomEmojiStickersParams struct {
	// A JSON-serialized list of custom emoji identifiers.
	// At most 200 custom emoji identifiers can be specified.
	CustomEmojiIDs []string `json:"custom_emoji_ids"`
}

// GetCustomEmojiStickersOption configures GetCustomEmojiStickersParams.
type GetCustomEmojiStickersOption func(params *GetCustomEmojiStickersParams) GetCustomEmojiStickersOption

// Option applies one or more GetCustomEmojiStickersOption values and returns the last rollback option.
func (r *GetCustomEmojiStickersParams) Option(opts ...GetCustomEmojiStickersOption) (previous GetCustomEmojiStickersOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetCustomEmojiStickersCustomEmojiIDs sets the CustomEmojiIDs field.
//
// A JSON-serialized list of custom emoji identifiers.
// At most 200 custom emoji identifiers can be specified.
func WithGetCustomEmojiStickersCustomEmojiIDs(value []string) GetCustomEmojiStickersOption {
	return func(params *GetCustomEmojiStickersParams) GetCustomEmojiStickersOption {
		previous := params.CustomEmojiIDs
		params.CustomEmojiIDs = value

		return WithGetCustomEmojiStickersCustomEmojiIDs(previous)
	}
}

// GetCustomEmojiStickers calls the getCustomEmojiStickers Telegram Bot API method.
//
// Use this method to get information about custom emoji stickers by their identifiers.
// Returns an Array of [Sticker] objects.
//
// [Sticker]: https://core.telegram.org/bots/api#sticker
func (c *Client) GetCustomEmojiStickers(params *GetCustomEmojiStickersParams) (ret []Sticker, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getCustomEmojiStickers", reader, contentType)
	if err != nil {
		return
	}

	ret = make([]Sticker, 0, 100)
	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetFileParams contains parameters for Client.GetFile.
type GetFileParams struct {
	// File identifier to get information about
	FileID string `json:"file_id"`
}

// GetFileOption configures GetFileParams.
type GetFileOption func(params *GetFileParams) GetFileOption

// Option applies one or more GetFileOption values and returns the last rollback option.
func (r *GetFileParams) Option(opts ...GetFileOption) (previous GetFileOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetFileFileID sets the FileID field.
//
// File identifier to get information about
func WithGetFileFileID(value string) GetFileOption {
	return func(params *GetFileParams) GetFileOption {
		previous := params.FileID
		params.FileID = value

		return WithGetFileFileID(previous)
	}
}

// GetFile calls the getFile Telegram Bot API method.
//
// Use this method to get basic information about a file and prepare it for downloading.
// For the moment, bots can download files of up to 20MB in size.
// On success, a [File] object is returned.
// The file can then be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>, where <file_path> is taken from the response.
// It is guaranteed that the link will be valid for at least 1 hour.
// When the link expires, a new one can be requested by calling [getFile] again.
// Note: This function may not preserve the original file name and MIME type.
// You should save the file's MIME type and name (if available) when the File object is received.
//
// [File]: https://core.telegram.org/bots/api#file
// [getFile]: https://core.telegram.org/bots/api#getfile
func (c *Client) GetFile(params *GetFileParams) (ret *File, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getFile", reader, contentType)
	if err != nil {
		return
	}

	ret = new(File)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetForumTopicIconStickersParams contains parameters for Client.GetForumTopicIconStickers.
type GetForumTopicIconStickersParams struct {
}

// GetForumTopicIconStickersOption configures GetForumTopicIconStickersParams.
type GetForumTopicIconStickersOption func(params *GetForumTopicIconStickersParams) GetForumTopicIconStickersOption

// Option applies one or more GetForumTopicIconStickersOption values and returns the last rollback option.
func (r *GetForumTopicIconStickersParams) Option(opts ...GetForumTopicIconStickersOption) (previous GetForumTopicIconStickersOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// GetForumTopicIconStickers calls the getForumTopicIconStickers Telegram Bot API method.
//
// Use this method to get custom emoji stickers, which can be used as a forum topic icon by any user.
// Requires no parameters.
// Returns an Array of [Sticker] objects.
//
// [Sticker]: https://core.telegram.org/bots/api#sticker
func (c *Client) GetForumTopicIconStickers(params *GetForumTopicIconStickersParams) (ret []Sticker, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getForumTopicIconStickers", reader, contentType)
	if err != nil {
		return
	}

	ret = make([]Sticker, 0, 100)
	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetGameHighScoresParams contains parameters for Client.GetGameHighScores.
type GetGameHighScoresParams struct {
	// Target user id
	UserID int64 `json:"user_id"`

	// Required if inline_message_id is not specified.
	// Unique identifier for the target chat
	ChatID int64 `json:"chat_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Identifier of the sent message
	MessageID int64 `json:"message_id,omitempty"`

	// Required if chat_id and message_id are not specified.
	// Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
}

// GetGameHighScoresOption configures GetGameHighScoresParams.
type GetGameHighScoresOption func(params *GetGameHighScoresParams) GetGameHighScoresOption

// Option applies one or more GetGameHighScoresOption values and returns the last rollback option.
func (r *GetGameHighScoresParams) Option(opts ...GetGameHighScoresOption) (previous GetGameHighScoresOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetGameHighScoresUserID sets the UserID field.
//
// Target user id
func WithGetGameHighScoresUserID(value int64) GetGameHighScoresOption {
	return func(params *GetGameHighScoresParams) GetGameHighScoresOption {
		previous := params.UserID
		params.UserID = value

		return WithGetGameHighScoresUserID(previous)
	}
}

// WithGetGameHighScoresChatID sets the ChatID field.
//
// Required if inline_message_id is not specified.
// Unique identifier for the target chat
func WithGetGameHighScoresChatID(value int64) GetGameHighScoresOption {
	return func(params *GetGameHighScoresParams) GetGameHighScoresOption {
		previous := params.ChatID
		params.ChatID = value

		return WithGetGameHighScoresChatID(previous)
	}
}

// WithGetGameHighScoresMessageID sets the MessageID field.
//
// Required if inline_message_id is not specified.
// Identifier of the sent message
func WithGetGameHighScoresMessageID(value int64) GetGameHighScoresOption {
	return func(params *GetGameHighScoresParams) GetGameHighScoresOption {
		previous := params.MessageID
		params.MessageID = value

		return WithGetGameHighScoresMessageID(previous)
	}
}

// WithGetGameHighScoresInlineMessageID sets the InlineMessageID field.
//
// Required if chat_id and message_id are not specified.
// Identifier of the inline message
func WithGetGameHighScoresInlineMessageID(value string) GetGameHighScoresOption {
	return func(params *GetGameHighScoresParams) GetGameHighScoresOption {
		previous := params.InlineMessageID
		params.InlineMessageID = value

		return WithGetGameHighScoresInlineMessageID(previous)
	}
}

// GetGameHighScores calls the getGameHighScores Telegram Bot API method.
//
// Use this method to get data for high score tables.
// Will return the score of the specified user and several of their neighbors in a game.
// Returns an Array of [GameHighScore] objects.
//
// [GameHighScore]: https://core.telegram.org/bots/api#gamehighscore
func (c *Client) GetGameHighScores(params *GetGameHighScoresParams) (ret []GameHighScore, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getGameHighScores", reader, contentType)
	if err != nil {
		return
	}

	ret = make([]GameHighScore, 0, 100)
	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetMeParams contains parameters for Client.GetMe.
type GetMeParams struct {
}

// GetMeOption configures GetMeParams.
type GetMeOption func(params *GetMeParams) GetMeOption

// Option applies one or more GetMeOption values and returns the last rollback option.
func (r *GetMeParams) Option(opts ...GetMeOption) (previous GetMeOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// GetMe calls the getMe Telegram Bot API method.
//
// A simple method for testing your bot's authentication token.
// Requires no parameters.
// Returns basic information about the bot in form of a [User] object.
//
// [User]: https://core.telegram.org/bots/api#user
func (c *Client) GetMe(params *GetMeParams) (ret *User, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getMe", reader, contentType)
	if err != nil {
		return
	}

	ret = new(User)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetMyCommandsParams contains parameters for Client.GetMyCommands.
type GetMyCommandsParams struct {
	// A JSON-serialized object, describing scope of users.
	// Defaults to [BotCommandScopeDefault].
	//
	// [BotCommandScopeDefault]: https://core.telegram.org/bots/api#botcommandscopedefault
	Scope *BotCommandScope `json:"scope,omitempty"`

	// A two-letter ISO 639-1 language code or an empty string
	LanguageCode string `json:"language_code,omitempty"`
}

// GetMyCommandsOption configures GetMyCommandsParams.
type GetMyCommandsOption func(params *GetMyCommandsParams) GetMyCommandsOption

// Option applies one or more GetMyCommandsOption values and returns the last rollback option.
func (r *GetMyCommandsParams) Option(opts ...GetMyCommandsOption) (previous GetMyCommandsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetMyCommandsScope sets the Scope field.
//
// A JSON-serialized object, describing scope of users.
// Defaults to [BotCommandScopeDefault].
//
// [BotCommandScopeDefault]: https://core.telegram.org/bots/api#botcommandscopedefault
func WithGetMyCommandsScope(value *BotCommandScope) GetMyCommandsOption {
	return func(params *GetMyCommandsParams) GetMyCommandsOption {
		previous := params.Scope
		params.Scope = value

		return WithGetMyCommandsScope(previous)
	}
}

// WithGetMyCommandsLanguageCode sets the LanguageCode field.
//
// A two-letter ISO 639-1 language code or an empty string
func WithGetMyCommandsLanguageCode(value string) GetMyCommandsOption {
	return func(params *GetMyCommandsParams) GetMyCommandsOption {
		previous := params.LanguageCode
		params.LanguageCode = value

		return WithGetMyCommandsLanguageCode(previous)
	}
}

// GetMyCommands calls the getMyCommands Telegram Bot API method.
//
// Use this method to get the current list of the bot's commands for the given scope and user language.
// Returns an Array of [BotCommand] objects.
// If commands aren't set, an empty list is returned.
//
// [BotCommand]: https://core.telegram.org/bots/api#botcommand
func (c *Client) GetMyCommands(params *GetMyCommandsParams) (ret []BotCommand, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getMyCommands", reader, contentType)
	if err != nil {
		return
	}

	ret = make([]BotCommand, 0, 100)
	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetMyDefaultAdministratorRightsParams contains parameters for Client.GetMyDefaultAdministratorRights.
type GetMyDefaultAdministratorRightsParams struct {
	// Pass True to get default administrator rights of the bot in channels.
	// Otherwise, default administrator rights of the bot for groups and supergroups will be returned.
	ForChannels bool `json:"for_channels,omitempty"`
}

// GetMyDefaultAdministratorRightsOption configures GetMyDefaultAdministratorRightsParams.
type GetMyDefaultAdministratorRightsOption func(params *GetMyDefaultAdministratorRightsParams) GetMyDefaultAdministratorRightsOption

// Option applies one or more GetMyDefaultAdministratorRightsOption values and returns the last rollback option.
func (r *GetMyDefaultAdministratorRightsParams) Option(opts ...GetMyDefaultAdministratorRightsOption) (previous GetMyDefaultAdministratorRightsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetMyDefaultAdministratorRightsForChannels sets the ForChannels field.
//
// Pass True to get default administrator rights of the bot in channels.
// Otherwise, default administrator rights of the bot for groups and supergroups will be returned.
func WithGetMyDefaultAdministratorRightsForChannels(value bool) GetMyDefaultAdministratorRightsOption {
	return func(params *GetMyDefaultAdministratorRightsParams) GetMyDefaultAdministratorRightsOption {
		previous := params.ForChannels
		params.ForChannels = value

		return WithGetMyDefaultAdministratorRightsForChannels(previous)
	}
}

// GetMyDefaultAdministratorRights calls the getMyDefaultAdministratorRights Telegram Bot API method.
//
// Use this method to get the current default administrator rights of the bot.
// Returns [ChatAdministratorRights] on success.
//
// [ChatAdministratorRights]: https://core.telegram.org/bots/api#chatadministratorrights
func (c *Client) GetMyDefaultAdministratorRights(params *GetMyDefaultAdministratorRightsParams) (ret *ChatAdministratorRights, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getMyDefaultAdministratorRights", reader, contentType)
	if err != nil {
		return
	}

	ret = new(ChatAdministratorRights)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetMyDescriptionParams contains parameters for Client.GetMyDescription.
type GetMyDescriptionParams struct {
	// A two-letter ISO 639-1 language code or an empty string
	LanguageCode string `json:"language_code,omitempty"`
}

// GetMyDescriptionOption configures GetMyDescriptionParams.
type GetMyDescriptionOption func(params *GetMyDescriptionParams) GetMyDescriptionOption

// Option applies one or more GetMyDescriptionOption values and returns the last rollback option.
func (r *GetMyDescriptionParams) Option(opts ...GetMyDescriptionOption) (previous GetMyDescriptionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetMyDescriptionLanguageCode sets the LanguageCode field.
//
// A two-letter ISO 639-1 language code or an empty string
func WithGetMyDescriptionLanguageCode(value string) GetMyDescriptionOption {
	return func(params *GetMyDescriptionParams) GetMyDescriptionOption {
		previous := params.LanguageCode
		params.LanguageCode = value

		return WithGetMyDescriptionLanguageCode(previous)
	}
}

// GetMyDescription calls the getMyDescription Telegram Bot API method.
//
// Use this method to get the current bot description for the given user language.
// Returns [BotDescription] on success.
//
// [BotDescription]: https://core.telegram.org/bots/api#botdescription
func (c *Client) GetMyDescription(params *GetMyDescriptionParams) (ret *BotDescription, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getMyDescription", reader, contentType)
	if err != nil {
		return
	}

	ret = new(BotDescription)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetMyNameParams contains parameters for Client.GetMyName.
type GetMyNameParams struct {
	// A two-letter ISO 639-1 language code or an empty string
	LanguageCode string `json:"language_code,omitempty"`
}

// GetMyNameOption configures GetMyNameParams.
type GetMyNameOption func(params *GetMyNameParams) GetMyNameOption

// Option applies one or more GetMyNameOption values and returns the last rollback option.
func (r *GetMyNameParams) Option(opts ...GetMyNameOption) (previous GetMyNameOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetMyNameLanguageCode sets the LanguageCode field.
//
// A two-letter ISO 639-1 language code or an empty string
func WithGetMyNameLanguageCode(value string) GetMyNameOption {
	return func(params *GetMyNameParams) GetMyNameOption {
		previous := params.LanguageCode
		params.LanguageCode = value

		return WithGetMyNameLanguageCode(previous)
	}
}

// GetMyName calls the getMyName Telegram Bot API method.
//
// Use this method to get the current bot name for the given user language.
// Returns [BotName] on success.
//
// [BotName]: https://core.telegram.org/bots/api#botname
func (c *Client) GetMyName(params *GetMyNameParams) (ret *BotName, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getMyName", reader, contentType)
	if err != nil {
		return
	}

	ret = new(BotName)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetMyShortDescriptionParams contains parameters for Client.GetMyShortDescription.
type GetMyShortDescriptionParams struct {
	// A two-letter ISO 639-1 language code or an empty string
	LanguageCode string `json:"language_code,omitempty"`
}

// GetMyShortDescriptionOption configures GetMyShortDescriptionParams.
type GetMyShortDescriptionOption func(params *GetMyShortDescriptionParams) GetMyShortDescriptionOption

// Option applies one or more GetMyShortDescriptionOption values and returns the last rollback option.
func (r *GetMyShortDescriptionParams) Option(opts ...GetMyShortDescriptionOption) (previous GetMyShortDescriptionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetMyShortDescriptionLanguageCode sets the LanguageCode field.
//
// A two-letter ISO 639-1 language code or an empty string
func WithGetMyShortDescriptionLanguageCode(value string) GetMyShortDescriptionOption {
	return func(params *GetMyShortDescriptionParams) GetMyShortDescriptionOption {
		previous := params.LanguageCode
		params.LanguageCode = value

		return WithGetMyShortDescriptionLanguageCode(previous)
	}
}

// GetMyShortDescription calls the getMyShortDescription Telegram Bot API method.
//
// Use this method to get the current bot short description for the given user language.
// Returns [BotShortDescription] on success.
//
// [BotShortDescription]: https://core.telegram.org/bots/api#botshortdescription
func (c *Client) GetMyShortDescription(params *GetMyShortDescriptionParams) (ret *BotShortDescription, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getMyShortDescription", reader, contentType)
	if err != nil {
		return
	}

	ret = new(BotShortDescription)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetMyStarBalanceParams contains parameters for Client.GetMyStarBalance.
type GetMyStarBalanceParams struct {
}

// GetMyStarBalanceOption configures GetMyStarBalanceParams.
type GetMyStarBalanceOption func(params *GetMyStarBalanceParams) GetMyStarBalanceOption

// Option applies one or more GetMyStarBalanceOption values and returns the last rollback option.
func (r *GetMyStarBalanceParams) Option(opts ...GetMyStarBalanceOption) (previous GetMyStarBalanceOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// GetMyStarBalance calls the getMyStarBalance Telegram Bot API method.
//
// A method to get the current Telegram Stars balance of the bot.
// Requires no parameters.
// On success, returns a [StarAmount] object.
//
// [StarAmount]: https://core.telegram.org/bots/api#staramount
func (c *Client) GetMyStarBalance(params *GetMyStarBalanceParams) (ret *StarAmount, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getMyStarBalance", reader, contentType)
	if err != nil {
		return
	}

	ret = new(StarAmount)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetStarTransactionsParams contains parameters for Client.GetStarTransactions.
type GetStarTransactionsParams struct {
	// Number of transactions to skip in the response
	Offset int64 `json:"offset,omitempty"`

	// The maximum number of transactions to be retrieved.
	// Values between 1-100 are accepted.
	// Defaults to 100.
	Limit int64 `json:"limit,omitempty"`
}

// GetStarTransactionsOption configures GetStarTransactionsParams.
type GetStarTransactionsOption func(params *GetStarTransactionsParams) GetStarTransactionsOption

// Option applies one or more GetStarTransactionsOption values and returns the last rollback option.
func (r *GetStarTransactionsParams) Option(opts ...GetStarTransactionsOption) (previous GetStarTransactionsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetStarTransactionsOffset sets the Offset field.
//
// Number of transactions to skip in the response
func WithGetStarTransactionsOffset(value int64) GetStarTransactionsOption {
	return func(params *GetStarTransactionsParams) GetStarTransactionsOption {
		previous := params.Offset
		params.Offset = value

		return WithGetStarTransactionsOffset(previous)
	}
}

// WithGetStarTransactionsLimit sets the Limit field.
//
// The maximum number of transactions to be retrieved.
// Values between 1-100 are accepted.
// Defaults to 100.
func WithGetStarTransactionsLimit(value int64) GetStarTransactionsOption {
	return func(params *GetStarTransactionsParams) GetStarTransactionsOption {
		previous := params.Limit
		params.Limit = value

		return WithGetStarTransactionsLimit(previous)
	}
}

// GetStarTransactions calls the getStarTransactions Telegram Bot API method.
//
// Returns the bot's Telegram Star transactions in chronological order.
// On success, returns a [StarTransactions] object.
//
// [StarTransactions]: https://core.telegram.org/bots/api#startransactions
func (c *Client) GetStarTransactions(params *GetStarTransactionsParams) (ret *StarTransactions, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getStarTransactions", reader, contentType)
	if err != nil {
		return
	}

	ret = new(StarTransactions)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetStickerSetParams contains parameters for Client.GetStickerSet.
type GetStickerSetParams struct {
	// Name of the sticker set
	Name string `json:"name"`
}

// GetStickerSetOption configures GetStickerSetParams.
type GetStickerSetOption func(params *GetStickerSetParams) GetStickerSetOption

// Option applies one or more GetStickerSetOption values and returns the last rollback option.
func (r *GetStickerSetParams) Option(opts ...GetStickerSetOption) (previous GetStickerSetOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetStickerSetName sets the Name field.
//
// Name of the sticker set
func WithGetStickerSetName(value string) GetStickerSetOption {
	return func(params *GetStickerSetParams) GetStickerSetOption {
		previous := params.Name
		params.Name = value

		return WithGetStickerSetName(previous)
	}
}

// GetStickerSet calls the getStickerSet Telegram Bot API method.
//
// Use this method to get a sticker set.
// On success, a [StickerSet] object is returned.
//
// [StickerSet]: https://core.telegram.org/bots/api#stickerset
func (c *Client) GetStickerSet(params *GetStickerSetParams) (ret *StickerSet, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getStickerSet", reader, contentType)
	if err != nil {
		return
	}

	ret = new(StickerSet)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetUpdatesParams contains parameters for Client.GetUpdates.
type GetUpdatesParams struct {
	// Identifier of the first update to be returned.
	// Must be greater by one than the highest among the identifiers of previously received updates.
	// By default, updates starting with the earliest unconfirmed update are returned.
	// An update is considered confirmed as soon as [getUpdates] is called with an offset higher than its update_id.
	// The negative offset can be specified to retrieve updates starting from -offset update from the end of the updates queue.
	// All previous updates will be forgotten.
	//
	// [getUpdates]: https://core.telegram.org/bots/api#getupdates
	Offset int64 `json:"offset,omitempty"`

	// Limits the number of updates to be retrieved.
	// Values between 1-100 are accepted.
	// Defaults to 100.
	Limit int64 `json:"limit,omitempty"`

	// Timeout in seconds for long polling.
	// Defaults to 0, i.e.
	// usual short polling.
	// Should be positive, short polling should be used for testing purposes only.
	Timeout int64 `json:"timeout,omitempty"`

	// A JSON-serialized list of the update types you want your bot to receive.
	// For example, specify ["message", "edited_channel_post", "callback_query"] to only receive updates of these types.
	// See [Update] for a complete list of available update types.
	// Specify an empty list to receive all update types except chat_member, message_reaction, and message_reaction_count (default).
	// If not specified, the previous setting will be used.
	//
	// Please note that this parameter doesn't affect updates created before the call to getUpdates, so unwanted updates may be received for a short period of time.
	//
	// [Update]: https://core.telegram.org/bots/api#update
	AllowedUpdates []string `json:"allowed_updates,omitempty"`
}

// GetUpdatesOption configures GetUpdatesParams.
type GetUpdatesOption func(params *GetUpdatesParams) GetUpdatesOption

// Option applies one or more GetUpdatesOption values and returns the last rollback option.
func (r *GetUpdatesParams) Option(opts ...GetUpdatesOption) (previous GetUpdatesOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetUpdatesOffset sets the Offset field.
//
// Identifier of the first update to be returned.
// Must be greater by one than the highest among the identifiers of previously received updates.
// By default, updates starting with the earliest unconfirmed update are returned.
// An update is considered confirmed as soon as [getUpdates] is called with an offset higher than its update_id.
// The negative offset can be specified to retrieve updates starting from -offset update from the end of the updates queue.
// All previous updates will be forgotten.
//
// [getUpdates]: https://core.telegram.org/bots/api#getupdates
func WithGetUpdatesOffset(value int64) GetUpdatesOption {
	return func(params *GetUpdatesParams) GetUpdatesOption {
		previous := params.Offset
		params.Offset = value

		return WithGetUpdatesOffset(previous)
	}
}

// WithGetUpdatesLimit sets the Limit field.
//
// Limits the number of updates to be retrieved.
// Values between 1-100 are accepted.
// Defaults to 100.
func WithGetUpdatesLimit(value int64) GetUpdatesOption {
	return func(params *GetUpdatesParams) GetUpdatesOption {
		previous := params.Limit
		params.Limit = value

		return WithGetUpdatesLimit(previous)
	}
}

// WithGetUpdatesTimeout sets the Timeout field.
//
// Timeout in seconds for long polling.
// Defaults to 0, i.e.
// usual short polling.
// Should be positive, short polling should be used for testing purposes only.
func WithGetUpdatesTimeout(value int64) GetUpdatesOption {
	return func(params *GetUpdatesParams) GetUpdatesOption {
		previous := params.Timeout
		params.Timeout = value

		return WithGetUpdatesTimeout(previous)
	}
}

// WithGetUpdatesAllowedUpdates sets the AllowedUpdates field.
//
// A JSON-serialized list of the update types you want your bot to receive.
// For example, specify ["message", "edited_channel_post", "callback_query"] to only receive updates of these types.
// See [Update] for a complete list of available update types.
// Specify an empty list to receive all update types except chat_member, message_reaction, and message_reaction_count (default).
// If not specified, the previous setting will be used.
//
// Please note that this parameter doesn't affect updates created before the call to getUpdates, so unwanted updates may be received for a short period of time.
//
// [Update]: https://core.telegram.org/bots/api#update
func WithGetUpdatesAllowedUpdates(value []string) GetUpdatesOption {
	return func(params *GetUpdatesParams) GetUpdatesOption {
		previous := params.AllowedUpdates
		params.AllowedUpdates = value

		return WithGetUpdatesAllowedUpdates(previous)
	}
}

// GetUpdates calls the getUpdates Telegram Bot API method.
//
// Use this method to receive incoming updates using long polling ([wiki]).
// Returns an Array of [Update] objects.
//
// [wiki]: https://en.wikipedia.org/wiki/Push_technology#Long_polling
// [Update]: https://core.telegram.org/bots/api#update
func (c *Client) GetUpdates(params *GetUpdatesParams) (ret []Update, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getUpdates", reader, contentType)
	if err != nil {
		return
	}

	ret = make([]Update, 0, 100)
	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetUserChatBoostsParams contains parameters for Client.GetUserChatBoosts.
type GetUserChatBoostsParams struct {
	// Unique identifier for the chat or username of the channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
}

// GetUserChatBoostsOption configures GetUserChatBoostsParams.
type GetUserChatBoostsOption func(params *GetUserChatBoostsParams) GetUserChatBoostsOption

// Option applies one or more GetUserChatBoostsOption values and returns the last rollback option.
func (r *GetUserChatBoostsParams) Option(opts ...GetUserChatBoostsOption) (previous GetUserChatBoostsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetUserChatBoostsChatID sets the ChatID field.
//
// Unique identifier for the chat or username of the channel (in the format @channelusername)
func WithGetUserChatBoostsChatID(value string) GetUserChatBoostsOption {
	return func(params *GetUserChatBoostsParams) GetUserChatBoostsOption {
		previous := params.ChatID
		params.ChatID = value

		return WithGetUserChatBoostsChatID(previous)
	}
}

// WithGetUserChatBoostsUserID sets the UserID field.
//
// Unique identifier of the target user
func WithGetUserChatBoostsUserID(value int64) GetUserChatBoostsOption {
	return func(params *GetUserChatBoostsParams) GetUserChatBoostsOption {
		previous := params.UserID
		params.UserID = value

		return WithGetUserChatBoostsUserID(previous)
	}
}

// GetUserChatBoosts calls the getUserChatBoosts Telegram Bot API method.
//
// Use this method to get the list of boosts added to a chat by a user.
// Requires administrator rights in the chat.
// Returns a [UserChatBoosts] object.
//
// [UserChatBoosts]: https://core.telegram.org/bots/api#userchatboosts
func (c *Client) GetUserChatBoosts(params *GetUserChatBoostsParams) (ret *UserChatBoosts, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getUserChatBoosts", reader, contentType)
	if err != nil {
		return
	}

	ret = new(UserChatBoosts)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetUserGiftsParams contains parameters for Client.GetUserGifts.
type GetUserGiftsParams struct {
	// Unique identifier of the user
	UserID int64 `json:"user_id"`

	// Pass True to exclude gifts that can be purchased an unlimited number of times
	ExcludeUnlimited bool `json:"exclude_unlimited,omitempty"`

	// Pass True to exclude gifts that can be purchased a limited number of times and can be upgraded to unique
	ExcludeLimitedUpgradable bool `json:"exclude_limited_upgradable,omitempty"`

	// Pass True to exclude gifts that can be purchased a limited number of times and can't be upgraded to unique
	ExcludeLimitedNonUpgradable bool `json:"exclude_limited_non_upgradable,omitempty"`

	// Pass True to exclude gifts that were assigned from the TON blockchain and can't be resold or transferred in Telegram
	ExcludeFromBlockchain bool `json:"exclude_from_blockchain,omitempty"`

	// Pass True to exclude unique gifts
	ExcludeUnique bool `json:"exclude_unique,omitempty"`

	// Pass True to sort results by gift price instead of send date.
	// Sorting is applied before pagination.
	SortByPrice bool `json:"sort_by_price,omitempty"`

	// Offset of the first entry to return as received from the previous request; use an empty string to get the first chunk of results
	Offset string `json:"offset,omitempty"`

	// The maximum number of gifts to be returned; 1-100.
	// Defaults to 100
	Limit int64 `json:"limit,omitempty"`
}

// GetUserGiftsOption configures GetUserGiftsParams.
type GetUserGiftsOption func(params *GetUserGiftsParams) GetUserGiftsOption

// Option applies one or more GetUserGiftsOption values and returns the last rollback option.
func (r *GetUserGiftsParams) Option(opts ...GetUserGiftsOption) (previous GetUserGiftsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetUserGiftsUserID sets the UserID field.
//
// Unique identifier of the user
func WithGetUserGiftsUserID(value int64) GetUserGiftsOption {
	return func(params *GetUserGiftsParams) GetUserGiftsOption {
		previous := params.UserID
		params.UserID = value

		return WithGetUserGiftsUserID(previous)
	}
}

// WithGetUserGiftsExcludeUnlimited sets the ExcludeUnlimited field.
//
// Pass True to exclude gifts that can be purchased an unlimited number of times
func WithGetUserGiftsExcludeUnlimited(value bool) GetUserGiftsOption {
	return func(params *GetUserGiftsParams) GetUserGiftsOption {
		previous := params.ExcludeUnlimited
		params.ExcludeUnlimited = value

		return WithGetUserGiftsExcludeUnlimited(previous)
	}
}

// WithGetUserGiftsExcludeLimitedUpgradable sets the ExcludeLimitedUpgradable field.
//
// Pass True to exclude gifts that can be purchased a limited number of times and can be upgraded to unique
func WithGetUserGiftsExcludeLimitedUpgradable(value bool) GetUserGiftsOption {
	return func(params *GetUserGiftsParams) GetUserGiftsOption {
		previous := params.ExcludeLimitedUpgradable
		params.ExcludeLimitedUpgradable = value

		return WithGetUserGiftsExcludeLimitedUpgradable(previous)
	}
}

// WithGetUserGiftsExcludeLimitedNonUpgradable sets the ExcludeLimitedNonUpgradable field.
//
// Pass True to exclude gifts that can be purchased a limited number of times and can't be upgraded to unique
func WithGetUserGiftsExcludeLimitedNonUpgradable(value bool) GetUserGiftsOption {
	return func(params *GetUserGiftsParams) GetUserGiftsOption {
		previous := params.ExcludeLimitedNonUpgradable
		params.ExcludeLimitedNonUpgradable = value

		return WithGetUserGiftsExcludeLimitedNonUpgradable(previous)
	}
}

// WithGetUserGiftsExcludeFromBlockchain sets the ExcludeFromBlockchain field.
//
// Pass True to exclude gifts that were assigned from the TON blockchain and can't be resold or transferred in Telegram
func WithGetUserGiftsExcludeFromBlockchain(value bool) GetUserGiftsOption {
	return func(params *GetUserGiftsParams) GetUserGiftsOption {
		previous := params.ExcludeFromBlockchain
		params.ExcludeFromBlockchain = value

		return WithGetUserGiftsExcludeFromBlockchain(previous)
	}
}

// WithGetUserGiftsExcludeUnique sets the ExcludeUnique field.
//
// Pass True to exclude unique gifts
func WithGetUserGiftsExcludeUnique(value bool) GetUserGiftsOption {
	return func(params *GetUserGiftsParams) GetUserGiftsOption {
		previous := params.ExcludeUnique
		params.ExcludeUnique = value

		return WithGetUserGiftsExcludeUnique(previous)
	}
}

// WithGetUserGiftsSortByPrice sets the SortByPrice field.
//
// Pass True to sort results by gift price instead of send date.
// Sorting is applied before pagination.
func WithGetUserGiftsSortByPrice(value bool) GetUserGiftsOption {
	return func(params *GetUserGiftsParams) GetUserGiftsOption {
		previous := params.SortByPrice
		params.SortByPrice = value

		return WithGetUserGiftsSortByPrice(previous)
	}
}

// WithGetUserGiftsOffset sets the Offset field.
//
// Offset of the first entry to return as received from the previous request; use an empty string to get the first chunk of results
func WithGetUserGiftsOffset(value string) GetUserGiftsOption {
	return func(params *GetUserGiftsParams) GetUserGiftsOption {
		previous := params.Offset
		params.Offset = value

		return WithGetUserGiftsOffset(previous)
	}
}

// WithGetUserGiftsLimit sets the Limit field.
//
// The maximum number of gifts to be returned; 1-100.
// Defaults to 100
func WithGetUserGiftsLimit(value int64) GetUserGiftsOption {
	return func(params *GetUserGiftsParams) GetUserGiftsOption {
		previous := params.Limit
		params.Limit = value

		return WithGetUserGiftsLimit(previous)
	}
}

// GetUserGifts calls the getUserGifts Telegram Bot API method.
//
// Returns the gifts owned and hosted by a user.
// Returns [OwnedGifts] on success.
//
// [OwnedGifts]: https://core.telegram.org/bots/api#ownedgifts
func (c *Client) GetUserGifts(params *GetUserGiftsParams) (ret *OwnedGifts, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getUserGifts", reader, contentType)
	if err != nil {
		return
	}

	ret = new(OwnedGifts)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetUserProfileAudiosParams contains parameters for Client.GetUserProfileAudios.
type GetUserProfileAudiosParams struct {
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`

	// Sequential number of the first audio to be returned.
	// By default, all audios are returned.
	Offset int64 `json:"offset,omitempty"`

	// Limits the number of audios to be retrieved.
	// Values between 1-100 are accepted.
	// Defaults to 100.
	Limit int64 `json:"limit,omitempty"`
}

// GetUserProfileAudiosOption configures GetUserProfileAudiosParams.
type GetUserProfileAudiosOption func(params *GetUserProfileAudiosParams) GetUserProfileAudiosOption

// Option applies one or more GetUserProfileAudiosOption values and returns the last rollback option.
func (r *GetUserProfileAudiosParams) Option(opts ...GetUserProfileAudiosOption) (previous GetUserProfileAudiosOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetUserProfileAudiosUserID sets the UserID field.
//
// Unique identifier of the target user
func WithGetUserProfileAudiosUserID(value int64) GetUserProfileAudiosOption {
	return func(params *GetUserProfileAudiosParams) GetUserProfileAudiosOption {
		previous := params.UserID
		params.UserID = value

		return WithGetUserProfileAudiosUserID(previous)
	}
}

// WithGetUserProfileAudiosOffset sets the Offset field.
//
// Sequential number of the first audio to be returned.
// By default, all audios are returned.
func WithGetUserProfileAudiosOffset(value int64) GetUserProfileAudiosOption {
	return func(params *GetUserProfileAudiosParams) GetUserProfileAudiosOption {
		previous := params.Offset
		params.Offset = value

		return WithGetUserProfileAudiosOffset(previous)
	}
}

// WithGetUserProfileAudiosLimit sets the Limit field.
//
// Limits the number of audios to be retrieved.
// Values between 1-100 are accepted.
// Defaults to 100.
func WithGetUserProfileAudiosLimit(value int64) GetUserProfileAudiosOption {
	return func(params *GetUserProfileAudiosParams) GetUserProfileAudiosOption {
		previous := params.Limit
		params.Limit = value

		return WithGetUserProfileAudiosLimit(previous)
	}
}

// GetUserProfileAudios calls the getUserProfileAudios Telegram Bot API method.
//
// Use this method to get a list of profile audios for a user.
// Returns a [UserProfileAudios] object.
//
// [UserProfileAudios]: https://core.telegram.org/bots/api#userprofileaudios
func (c *Client) GetUserProfileAudios(params *GetUserProfileAudiosParams) (ret *UserProfileAudios, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getUserProfileAudios", reader, contentType)
	if err != nil {
		return
	}

	ret = new(UserProfileAudios)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetUserProfilePhotosParams contains parameters for Client.GetUserProfilePhotos.
type GetUserProfilePhotosParams struct {
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`

	// Sequential number of the first photo to be returned.
	// By default, all photos are returned.
	Offset int64 `json:"offset,omitempty"`

	// Limits the number of photos to be retrieved.
	// Values between 1-100 are accepted.
	// Defaults to 100.
	Limit int64 `json:"limit,omitempty"`
}

// GetUserProfilePhotosOption configures GetUserProfilePhotosParams.
type GetUserProfilePhotosOption func(params *GetUserProfilePhotosParams) GetUserProfilePhotosOption

// Option applies one or more GetUserProfilePhotosOption values and returns the last rollback option.
func (r *GetUserProfilePhotosParams) Option(opts ...GetUserProfilePhotosOption) (previous GetUserProfilePhotosOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGetUserProfilePhotosUserID sets the UserID field.
//
// Unique identifier of the target user
func WithGetUserProfilePhotosUserID(value int64) GetUserProfilePhotosOption {
	return func(params *GetUserProfilePhotosParams) GetUserProfilePhotosOption {
		previous := params.UserID
		params.UserID = value

		return WithGetUserProfilePhotosUserID(previous)
	}
}

// WithGetUserProfilePhotosOffset sets the Offset field.
//
// Sequential number of the first photo to be returned.
// By default, all photos are returned.
func WithGetUserProfilePhotosOffset(value int64) GetUserProfilePhotosOption {
	return func(params *GetUserProfilePhotosParams) GetUserProfilePhotosOption {
		previous := params.Offset
		params.Offset = value

		return WithGetUserProfilePhotosOffset(previous)
	}
}

// WithGetUserProfilePhotosLimit sets the Limit field.
//
// Limits the number of photos to be retrieved.
// Values between 1-100 are accepted.
// Defaults to 100.
func WithGetUserProfilePhotosLimit(value int64) GetUserProfilePhotosOption {
	return func(params *GetUserProfilePhotosParams) GetUserProfilePhotosOption {
		previous := params.Limit
		params.Limit = value

		return WithGetUserProfilePhotosLimit(previous)
	}
}

// GetUserProfilePhotos calls the getUserProfilePhotos Telegram Bot API method.
//
// Use this method to get a list of profile pictures for a user.
// Returns a [UserProfilePhotos] object.
//
// [UserProfilePhotos]: https://core.telegram.org/bots/api#userprofilephotos
func (c *Client) GetUserProfilePhotos(params *GetUserProfilePhotosParams) (ret *UserProfilePhotos, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getUserProfilePhotos", reader, contentType)
	if err != nil {
		return
	}

	ret = new(UserProfilePhotos)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GetWebhookInfoParams contains parameters for Client.GetWebhookInfo.
type GetWebhookInfoParams struct {
}

// GetWebhookInfoOption configures GetWebhookInfoParams.
type GetWebhookInfoOption func(params *GetWebhookInfoParams) GetWebhookInfoOption

// Option applies one or more GetWebhookInfoOption values and returns the last rollback option.
func (r *GetWebhookInfoParams) Option(opts ...GetWebhookInfoOption) (previous GetWebhookInfoOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// GetWebhookInfo calls the getWebhookInfo Telegram Bot API method.
//
// Use this method to get current webhook status.
// Requires no parameters.
// On success, returns a [WebhookInfo] object.
// If the bot is using [getUpdates], will return an object with the url field empty.
//
// [WebhookInfo]: https://core.telegram.org/bots/api#webhookinfo
// [getUpdates]: https://core.telegram.org/bots/api#getupdates
func (c *Client) GetWebhookInfo(params *GetWebhookInfoParams) (ret *WebhookInfo, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("getWebhookInfo", reader, contentType)
	if err != nil {
		return
	}

	ret = new(WebhookInfo)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// GiftPremiumSubscriptionParams contains parameters for Client.GiftPremiumSubscription.
type GiftPremiumSubscriptionParams struct {
	// Unique identifier of the target user who will receive a Telegram Premium subscription
	UserID int64 `json:"user_id"`

	// Number of months the Telegram Premium subscription will be active for the user; must be one of 3, 6, or 12
	MonthCount int64 `json:"month_count"`

	// Number of Telegram Stars to pay for the Telegram Premium subscription; must be 1000 for 3 months, 1500 for 6 months, and 2500 for 12 months
	StarCount int64 `json:"star_count"`

	// Text that will be shown along with the service message about the subscription; 0-128 characters
	Text string `json:"text,omitempty"`

	// Mode for parsing entities in the text.
	// See [formatting options] for more details.
	// Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom_emoji” are ignored.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	TextParseMode string `json:"text_parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the gift text.
	// It can be specified instead of text_parse_mode.
	// Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom_emoji” are ignored.
	TextEntities []MessageEntity `json:"text_entities,omitempty"`
}

// GiftPremiumSubscriptionOption configures GiftPremiumSubscriptionParams.
type GiftPremiumSubscriptionOption func(params *GiftPremiumSubscriptionParams) GiftPremiumSubscriptionOption

// Option applies one or more GiftPremiumSubscriptionOption values and returns the last rollback option.
func (r *GiftPremiumSubscriptionParams) Option(opts ...GiftPremiumSubscriptionOption) (previous GiftPremiumSubscriptionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithGiftPremiumSubscriptionUserID sets the UserID field.
//
// Unique identifier of the target user who will receive a Telegram Premium subscription
func WithGiftPremiumSubscriptionUserID(value int64) GiftPremiumSubscriptionOption {
	return func(params *GiftPremiumSubscriptionParams) GiftPremiumSubscriptionOption {
		previous := params.UserID
		params.UserID = value

		return WithGiftPremiumSubscriptionUserID(previous)
	}
}

// WithGiftPremiumSubscriptionMonthCount sets the MonthCount field.
//
// Number of months the Telegram Premium subscription will be active for the user; must be one of 3, 6, or 12
func WithGiftPremiumSubscriptionMonthCount(value int64) GiftPremiumSubscriptionOption {
	return func(params *GiftPremiumSubscriptionParams) GiftPremiumSubscriptionOption {
		previous := params.MonthCount
		params.MonthCount = value

		return WithGiftPremiumSubscriptionMonthCount(previous)
	}
}

// WithGiftPremiumSubscriptionStarCount sets the StarCount field.
//
// Number of Telegram Stars to pay for the Telegram Premium subscription; must be 1000 for 3 months, 1500 for 6 months, and 2500 for 12 months
func WithGiftPremiumSubscriptionStarCount(value int64) GiftPremiumSubscriptionOption {
	return func(params *GiftPremiumSubscriptionParams) GiftPremiumSubscriptionOption {
		previous := params.StarCount
		params.StarCount = value

		return WithGiftPremiumSubscriptionStarCount(previous)
	}
}

// WithGiftPremiumSubscriptionText sets the Text field.
//
// Text that will be shown along with the service message about the subscription; 0-128 characters
func WithGiftPremiumSubscriptionText(value string) GiftPremiumSubscriptionOption {
	return func(params *GiftPremiumSubscriptionParams) GiftPremiumSubscriptionOption {
		previous := params.Text
		params.Text = value

		return WithGiftPremiumSubscriptionText(previous)
	}
}

// WithGiftPremiumSubscriptionTextParseMode sets the TextParseMode field.
//
// Mode for parsing entities in the text.
// See [formatting options] for more details.
// Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom_emoji” are ignored.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithGiftPremiumSubscriptionTextParseMode(value string) GiftPremiumSubscriptionOption {
	return func(params *GiftPremiumSubscriptionParams) GiftPremiumSubscriptionOption {
		previous := params.TextParseMode
		params.TextParseMode = value

		return WithGiftPremiumSubscriptionTextParseMode(previous)
	}
}

// WithGiftPremiumSubscriptionTextEntities sets the TextEntities field.
//
// A JSON-serialized list of special entities that appear in the gift text.
// It can be specified instead of text_parse_mode.
// Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom_emoji” are ignored.
func WithGiftPremiumSubscriptionTextEntities(value []MessageEntity) GiftPremiumSubscriptionOption {
	return func(params *GiftPremiumSubscriptionParams) GiftPremiumSubscriptionOption {
		previous := params.TextEntities
		params.TextEntities = value

		return WithGiftPremiumSubscriptionTextEntities(previous)
	}
}

// GiftPremiumSubscription calls the giftPremiumSubscription Telegram Bot API method.
//
// Gifts a Telegram Premium subscription to the given user.
// Returns True on success.
func (c *Client) GiftPremiumSubscription(params *GiftPremiumSubscriptionParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("giftPremiumSubscription", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// HideGeneralForumTopicParams contains parameters for Client.HideGeneralForumTopic.
type HideGeneralForumTopicParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`
}

// HideGeneralForumTopicOption configures HideGeneralForumTopicParams.
type HideGeneralForumTopicOption func(params *HideGeneralForumTopicParams) HideGeneralForumTopicOption

// Option applies one or more HideGeneralForumTopicOption values and returns the last rollback option.
func (r *HideGeneralForumTopicParams) Option(opts ...HideGeneralForumTopicOption) (previous HideGeneralForumTopicOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithHideGeneralForumTopicChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithHideGeneralForumTopicChatID(value string) HideGeneralForumTopicOption {
	return func(params *HideGeneralForumTopicParams) HideGeneralForumTopicOption {
		previous := params.ChatID
		params.ChatID = value

		return WithHideGeneralForumTopicChatID(previous)
	}
}

// HideGeneralForumTopic calls the hideGeneralForumTopic Telegram Bot API method.
//
// Use this method to hide the 'General' topic in a forum supergroup chat.
// The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.
// The topic will be automatically closed if it was open.
// Returns True on success.
func (c *Client) HideGeneralForumTopic(params *HideGeneralForumTopicParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("hideGeneralForumTopic", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// LeaveChatParams contains parameters for Client.LeaveChat.
type LeaveChatParams struct {
	// Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername).
	// Channel direct messages chats aren't supported; leave the corresponding channel instead.
	ChatID string `json:"chat_id"`
}

// LeaveChatOption configures LeaveChatParams.
type LeaveChatOption func(params *LeaveChatParams) LeaveChatOption

// Option applies one or more LeaveChatOption values and returns the last rollback option.
func (r *LeaveChatParams) Option(opts ...LeaveChatOption) (previous LeaveChatOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithLeaveChatChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup or channel (in the format @channelusername).
// Channel direct messages chats aren't supported; leave the corresponding channel instead.
func WithLeaveChatChatID(value string) LeaveChatOption {
	return func(params *LeaveChatParams) LeaveChatOption {
		previous := params.ChatID
		params.ChatID = value

		return WithLeaveChatChatID(previous)
	}
}

// LeaveChat calls the leaveChat Telegram Bot API method.
//
// Use this method for your bot to leave a group, supergroup or channel.
// Returns True on success.
func (c *Client) LeaveChat(params *LeaveChatParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("leaveChat", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// LogOutParams contains parameters for Client.LogOut.
type LogOutParams struct {
}

// LogOutOption configures LogOutParams.
type LogOutOption func(params *LogOutParams) LogOutOption

// Option applies one or more LogOutOption values and returns the last rollback option.
func (r *LogOutParams) Option(opts ...LogOutOption) (previous LogOutOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// LogOut calls the logOut Telegram Bot API method.
//
// Use this method to log out from the cloud Bot API server before launching the bot locally.
// You must log out the bot before running it locally, otherwise there is no guarantee that the bot will receive updates.
// After a successful call, you can immediately log in on a local server, but will not be able to log in back to the cloud Bot API server for 10 minutes.
// Returns True on success.
// Requires no parameters.
func (c *Client) LogOut(params *LogOutParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("logOut", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// PinChatMessageParams contains parameters for Client.PinChatMessage.
type PinChatMessageParams struct {
	// Unique identifier of the business connection on behalf of which the message will be pinned
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Identifier of a message to pin
	MessageID int64 `json:"message_id"`

	// Pass True if it is not necessary to send a notification to all chat members about the new pinned message.
	// Notifications are always disabled in channels and private chats.
	DisableNotification bool `json:"disable_notification,omitempty"`
}

// PinChatMessageOption configures PinChatMessageParams.
type PinChatMessageOption func(params *PinChatMessageParams) PinChatMessageOption

// Option applies one or more PinChatMessageOption values and returns the last rollback option.
func (r *PinChatMessageParams) Option(opts ...PinChatMessageOption) (previous PinChatMessageOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithPinChatMessageBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be pinned
func WithPinChatMessageBusinessConnectionID(value string) PinChatMessageOption {
	return func(params *PinChatMessageParams) PinChatMessageOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithPinChatMessageBusinessConnectionID(previous)
	}
}

// WithPinChatMessageChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithPinChatMessageChatID(value string) PinChatMessageOption {
	return func(params *PinChatMessageParams) PinChatMessageOption {
		previous := params.ChatID
		params.ChatID = value

		return WithPinChatMessageChatID(previous)
	}
}

// WithPinChatMessageMessageID sets the MessageID field.
//
// Identifier of a message to pin
func WithPinChatMessageMessageID(value int64) PinChatMessageOption {
	return func(params *PinChatMessageParams) PinChatMessageOption {
		previous := params.MessageID
		params.MessageID = value

		return WithPinChatMessageMessageID(previous)
	}
}

// WithPinChatMessageDisableNotification sets the DisableNotification field.
//
// Pass True if it is not necessary to send a notification to all chat members about the new pinned message.
// Notifications are always disabled in channels and private chats.
func WithPinChatMessageDisableNotification(value bool) PinChatMessageOption {
	return func(params *PinChatMessageParams) PinChatMessageOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithPinChatMessageDisableNotification(previous)
	}
}

// PinChatMessage calls the pinChatMessage Telegram Bot API method.
//
// Use this method to add a message to the list of pinned messages in a chat.
// In private chats and channel direct messages chats, all non-service messages can be pinned.
// Conversely, the bot must be an administrator with the 'can_pin_messages' right or the 'can_edit_messages' right to pin messages in groups and channels respectively.
// Returns True on success.
func (c *Client) PinChatMessage(params *PinChatMessageParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("pinChatMessage", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// PostStoryParams contains parameters for Client.PostStory.
type PostStoryParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// Content of the story
	Content InputStoryContent `json:"content"`

	// Period after which the story is moved to the archive, in seconds; must be one of 6 * 3600, 12 * 3600, 86400, or 2 * 86400
	ActivePeriod int64 `json:"active_period"`

	// Caption of the story, 0-2048 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Mode for parsing entities in the story caption.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// A JSON-serialized list of clickable areas to be shown on the story
	Areas []StoryArea `json:"areas,omitempty"`

	// Pass True to keep the story accessible after it expires
	PostToChatPage bool `json:"post_to_chat_page,omitempty"`

	// Pass True if the content of the story must be protected from forwarding and screenshotting
	ProtectContent bool `json:"protect_content,omitempty"`
}

// PostStoryOption configures PostStoryParams.
type PostStoryOption func(params *PostStoryParams) PostStoryOption

// Option applies one or more PostStoryOption values and returns the last rollback option.
func (r *PostStoryParams) Option(opts ...PostStoryOption) (previous PostStoryOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithPostStoryBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithPostStoryBusinessConnectionID(value string) PostStoryOption {
	return func(params *PostStoryParams) PostStoryOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithPostStoryBusinessConnectionID(previous)
	}
}

// WithPostStoryContent sets the Content field.
//
// Content of the story
func WithPostStoryContent(value InputStoryContent) PostStoryOption {
	return func(params *PostStoryParams) PostStoryOption {
		previous := params.Content
		params.Content = value

		return WithPostStoryContent(previous)
	}
}

// WithPostStoryActivePeriod sets the ActivePeriod field.
//
// Period after which the story is moved to the archive, in seconds; must be one of 6 * 3600, 12 * 3600, 86400, or 2 * 86400
func WithPostStoryActivePeriod(value int64) PostStoryOption {
	return func(params *PostStoryParams) PostStoryOption {
		previous := params.ActivePeriod
		params.ActivePeriod = value

		return WithPostStoryActivePeriod(previous)
	}
}

// WithPostStoryCaption sets the Caption field.
//
// Caption of the story, 0-2048 characters after entities parsing
func WithPostStoryCaption(value string) PostStoryOption {
	return func(params *PostStoryParams) PostStoryOption {
		previous := params.Caption
		params.Caption = value

		return WithPostStoryCaption(previous)
	}
}

// WithPostStoryParseMode sets the ParseMode field.
//
// Mode for parsing entities in the story caption.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithPostStoryParseMode(value string) PostStoryOption {
	return func(params *PostStoryParams) PostStoryOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithPostStoryParseMode(previous)
	}
}

// WithPostStoryCaptionEntities sets the CaptionEntities field.
//
// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
func WithPostStoryCaptionEntities(value []MessageEntity) PostStoryOption {
	return func(params *PostStoryParams) PostStoryOption {
		previous := params.CaptionEntities
		params.CaptionEntities = value

		return WithPostStoryCaptionEntities(previous)
	}
}

// WithPostStoryAreas sets the Areas field.
//
// A JSON-serialized list of clickable areas to be shown on the story
func WithPostStoryAreas(value []StoryArea) PostStoryOption {
	return func(params *PostStoryParams) PostStoryOption {
		previous := params.Areas
		params.Areas = value

		return WithPostStoryAreas(previous)
	}
}

// WithPostStoryPostToChatPage sets the PostToChatPage field.
//
// Pass True to keep the story accessible after it expires
func WithPostStoryPostToChatPage(value bool) PostStoryOption {
	return func(params *PostStoryParams) PostStoryOption {
		previous := params.PostToChatPage
		params.PostToChatPage = value

		return WithPostStoryPostToChatPage(previous)
	}
}

// WithPostStoryProtectContent sets the ProtectContent field.
//
// Pass True if the content of the story must be protected from forwarding and screenshotting
func WithPostStoryProtectContent(value bool) PostStoryOption {
	return func(params *PostStoryParams) PostStoryOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithPostStoryProtectContent(previous)
	}
}

// PostStory calls the postStory Telegram Bot API method.
//
// Posts a story on behalf of a managed business account.
// Requires the can_manage_stories business bot right.
// Returns [Story] on success.
//
// [Story]: https://core.telegram.org/bots/api#story
func (c *Client) PostStory(params *PostStoryParams) (ret *Story, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("postStory", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Story)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// PromoteChatMemberParams contains parameters for Client.PromoteChatMember.
type PromoteChatMemberParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int64 `json:"user_id"`

	// Pass True if the administrator's presence in the chat is hidden
	IsAnonymous bool `json:"is_anonymous,omitempty"`

	// Pass True if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report spam messages, ignore slow mode, and send messages to the chat without paying Telegram Stars.
	// Implied by any other administrator privilege.
	CanManageChat bool `json:"can_manage_chat,omitempty"`

	// Pass True if the administrator can delete messages of other users
	CanDeleteMessages bool `json:"can_delete_messages,omitempty"`

	// Pass True if the administrator can manage video chats
	CanManageVideoChats bool `json:"can_manage_video_chats,omitempty"`

	// Pass True if the administrator can restrict, ban or unban chat members, or access supergroup statistics.
	// For backward compatibility, defaults to True for promotions of channel administrators
	CanRestrictMembers bool `json:"can_restrict_members,omitempty"`

	// Pass True if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by him)
	CanPromoteMembers bool `json:"can_promote_members,omitempty"`

	// Pass True if the administrator can change chat title, photo and other settings
	CanChangeInfo bool `json:"can_change_info,omitempty"`

	// Pass True if the administrator can invite new users to the chat
	CanInviteUsers bool `json:"can_invite_users,omitempty"`

	// Pass True if the administrator can post stories to the chat
	CanPostStories bool `json:"can_post_stories,omitempty"`

	// Pass True if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access the chat's story archive
	CanEditStories bool `json:"can_edit_stories,omitempty"`

	// Pass True if the administrator can delete stories posted by other users
	CanDeleteStories bool `json:"can_delete_stories,omitempty"`

	// Pass True if the administrator can post messages in the channel, approve suggested posts, or access channel statistics; for channels only
	CanPostMessages bool `json:"can_post_messages,omitempty"`

	// Pass True if the administrator can edit messages of other users and can pin messages; for channels only
	CanEditMessages bool `json:"can_edit_messages,omitempty"`

	// Pass True if the administrator can pin messages; for supergroups only
	CanPinMessages bool `json:"can_pin_messages,omitempty"`

	// Pass True if the user is allowed to create, rename, close, and reopen forum topics; for supergroups only
	CanManageTopics bool `json:"can_manage_topics,omitempty"`

	// Pass True if the administrator can manage direct messages within the channel and decline suggested posts; for channels only
	CanManageDirectMessages bool `json:"can_manage_direct_messages,omitempty"`

	// Pass True if the administrator can edit the tags of regular members; for groups and supergroups only
	CanManageTags bool `json:"can_manage_tags,omitempty"`
}

// PromoteChatMemberOption configures PromoteChatMemberParams.
type PromoteChatMemberOption func(params *PromoteChatMemberParams) PromoteChatMemberOption

// Option applies one or more PromoteChatMemberOption values and returns the last rollback option.
func (r *PromoteChatMemberParams) Option(opts ...PromoteChatMemberOption) (previous PromoteChatMemberOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithPromoteChatMemberChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithPromoteChatMemberChatID(value string) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.ChatID
		params.ChatID = value

		return WithPromoteChatMemberChatID(previous)
	}
}

// WithPromoteChatMemberUserID sets the UserID field.
//
// Unique identifier of the target user
func WithPromoteChatMemberUserID(value int64) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.UserID
		params.UserID = value

		return WithPromoteChatMemberUserID(previous)
	}
}

// WithPromoteChatMemberIsAnonymous sets the IsAnonymous field.
//
// Pass True if the administrator's presence in the chat is hidden
func WithPromoteChatMemberIsAnonymous(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.IsAnonymous
		params.IsAnonymous = value

		return WithPromoteChatMemberIsAnonymous(previous)
	}
}

// WithPromoteChatMemberCanManageChat sets the CanManageChat field.
//
// Pass True if the administrator can access the chat event log, get boost list, see hidden supergroup and channel members, report spam messages, ignore slow mode, and send messages to the chat without paying Telegram Stars.
// Implied by any other administrator privilege.
func WithPromoteChatMemberCanManageChat(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanManageChat
		params.CanManageChat = value

		return WithPromoteChatMemberCanManageChat(previous)
	}
}

// WithPromoteChatMemberCanDeleteMessages sets the CanDeleteMessages field.
//
// Pass True if the administrator can delete messages of other users
func WithPromoteChatMemberCanDeleteMessages(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanDeleteMessages
		params.CanDeleteMessages = value

		return WithPromoteChatMemberCanDeleteMessages(previous)
	}
}

// WithPromoteChatMemberCanManageVideoChats sets the CanManageVideoChats field.
//
// Pass True if the administrator can manage video chats
func WithPromoteChatMemberCanManageVideoChats(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanManageVideoChats
		params.CanManageVideoChats = value

		return WithPromoteChatMemberCanManageVideoChats(previous)
	}
}

// WithPromoteChatMemberCanRestrictMembers sets the CanRestrictMembers field.
//
// Pass True if the administrator can restrict, ban or unban chat members, or access supergroup statistics.
// For backward compatibility, defaults to True for promotions of channel administrators
func WithPromoteChatMemberCanRestrictMembers(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanRestrictMembers
		params.CanRestrictMembers = value

		return WithPromoteChatMemberCanRestrictMembers(previous)
	}
}

// WithPromoteChatMemberCanPromoteMembers sets the CanPromoteMembers field.
//
// Pass True if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by him)
func WithPromoteChatMemberCanPromoteMembers(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanPromoteMembers
		params.CanPromoteMembers = value

		return WithPromoteChatMemberCanPromoteMembers(previous)
	}
}

// WithPromoteChatMemberCanChangeInfo sets the CanChangeInfo field.
//
// Pass True if the administrator can change chat title, photo and other settings
func WithPromoteChatMemberCanChangeInfo(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanChangeInfo
		params.CanChangeInfo = value

		return WithPromoteChatMemberCanChangeInfo(previous)
	}
}

// WithPromoteChatMemberCanInviteUsers sets the CanInviteUsers field.
//
// Pass True if the administrator can invite new users to the chat
func WithPromoteChatMemberCanInviteUsers(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanInviteUsers
		params.CanInviteUsers = value

		return WithPromoteChatMemberCanInviteUsers(previous)
	}
}

// WithPromoteChatMemberCanPostStories sets the CanPostStories field.
//
// Pass True if the administrator can post stories to the chat
func WithPromoteChatMemberCanPostStories(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanPostStories
		params.CanPostStories = value

		return WithPromoteChatMemberCanPostStories(previous)
	}
}

// WithPromoteChatMemberCanEditStories sets the CanEditStories field.
//
// Pass True if the administrator can edit stories posted by other users, post stories to the chat page, pin chat stories, and access the chat's story archive
func WithPromoteChatMemberCanEditStories(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanEditStories
		params.CanEditStories = value

		return WithPromoteChatMemberCanEditStories(previous)
	}
}

// WithPromoteChatMemberCanDeleteStories sets the CanDeleteStories field.
//
// Pass True if the administrator can delete stories posted by other users
func WithPromoteChatMemberCanDeleteStories(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanDeleteStories
		params.CanDeleteStories = value

		return WithPromoteChatMemberCanDeleteStories(previous)
	}
}

// WithPromoteChatMemberCanPostMessages sets the CanPostMessages field.
//
// Pass True if the administrator can post messages in the channel, approve suggested posts, or access channel statistics; for channels only
func WithPromoteChatMemberCanPostMessages(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanPostMessages
		params.CanPostMessages = value

		return WithPromoteChatMemberCanPostMessages(previous)
	}
}

// WithPromoteChatMemberCanEditMessages sets the CanEditMessages field.
//
// Pass True if the administrator can edit messages of other users and can pin messages; for channels only
func WithPromoteChatMemberCanEditMessages(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanEditMessages
		params.CanEditMessages = value

		return WithPromoteChatMemberCanEditMessages(previous)
	}
}

// WithPromoteChatMemberCanPinMessages sets the CanPinMessages field.
//
// Pass True if the administrator can pin messages; for supergroups only
func WithPromoteChatMemberCanPinMessages(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanPinMessages
		params.CanPinMessages = value

		return WithPromoteChatMemberCanPinMessages(previous)
	}
}

// WithPromoteChatMemberCanManageTopics sets the CanManageTopics field.
//
// Pass True if the user is allowed to create, rename, close, and reopen forum topics; for supergroups only
func WithPromoteChatMemberCanManageTopics(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanManageTopics
		params.CanManageTopics = value

		return WithPromoteChatMemberCanManageTopics(previous)
	}
}

// WithPromoteChatMemberCanManageDirectMessages sets the CanManageDirectMessages field.
//
// Pass True if the administrator can manage direct messages within the channel and decline suggested posts; for channels only
func WithPromoteChatMemberCanManageDirectMessages(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanManageDirectMessages
		params.CanManageDirectMessages = value

		return WithPromoteChatMemberCanManageDirectMessages(previous)
	}
}

// WithPromoteChatMemberCanManageTags sets the CanManageTags field.
//
// Pass True if the administrator can edit the tags of regular members; for groups and supergroups only
func WithPromoteChatMemberCanManageTags(value bool) PromoteChatMemberOption {
	return func(params *PromoteChatMemberParams) PromoteChatMemberOption {
		previous := params.CanManageTags
		params.CanManageTags = value

		return WithPromoteChatMemberCanManageTags(previous)
	}
}

// PromoteChatMember calls the promoteChatMember Telegram Bot API method.
//
// Use this method to promote or demote a user in a supergroup or a channel.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// Pass False for all boolean parameters to demote a user.
// Returns True on success.
func (c *Client) PromoteChatMember(params *PromoteChatMemberParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("promoteChatMember", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// ReadBusinessMessageParams contains parameters for Client.ReadBusinessMessage.
type ReadBusinessMessageParams struct {
	// Unique identifier of the business connection on behalf of which to read the message
	BusinessConnectionID string `json:"business_connection_id"`

	// Unique identifier of the chat in which the message was received.
	// The chat must have been active in the last 24 hours.
	ChatID int64 `json:"chat_id"`

	// Unique identifier of the message to mark as read
	MessageID int64 `json:"message_id"`
}

// ReadBusinessMessageOption configures ReadBusinessMessageParams.
type ReadBusinessMessageOption func(params *ReadBusinessMessageParams) ReadBusinessMessageOption

// Option applies one or more ReadBusinessMessageOption values and returns the last rollback option.
func (r *ReadBusinessMessageParams) Option(opts ...ReadBusinessMessageOption) (previous ReadBusinessMessageOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithReadBusinessMessageBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which to read the message
func WithReadBusinessMessageBusinessConnectionID(value string) ReadBusinessMessageOption {
	return func(params *ReadBusinessMessageParams) ReadBusinessMessageOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithReadBusinessMessageBusinessConnectionID(previous)
	}
}

// WithReadBusinessMessageChatID sets the ChatID field.
//
// Unique identifier of the chat in which the message was received.
// The chat must have been active in the last 24 hours.
func WithReadBusinessMessageChatID(value int64) ReadBusinessMessageOption {
	return func(params *ReadBusinessMessageParams) ReadBusinessMessageOption {
		previous := params.ChatID
		params.ChatID = value

		return WithReadBusinessMessageChatID(previous)
	}
}

// WithReadBusinessMessageMessageID sets the MessageID field.
//
// Unique identifier of the message to mark as read
func WithReadBusinessMessageMessageID(value int64) ReadBusinessMessageOption {
	return func(params *ReadBusinessMessageParams) ReadBusinessMessageOption {
		previous := params.MessageID
		params.MessageID = value

		return WithReadBusinessMessageMessageID(previous)
	}
}

// ReadBusinessMessage calls the readBusinessMessage Telegram Bot API method.
//
// Marks incoming message as read on behalf of a business account.
// Requires the can_read_messages business bot right.
// Returns True on success.
func (c *Client) ReadBusinessMessage(params *ReadBusinessMessageParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("readBusinessMessage", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// RefundStarPaymentParams contains parameters for Client.RefundStarPayment.
type RefundStarPaymentParams struct {
	// Identifier of the user whose payment will be refunded
	UserID int64 `json:"user_id"`

	// Telegram payment identifier
	TelegramPaymentChargeID string `json:"telegram_payment_charge_id"`
}

// RefundStarPaymentOption configures RefundStarPaymentParams.
type RefundStarPaymentOption func(params *RefundStarPaymentParams) RefundStarPaymentOption

// Option applies one or more RefundStarPaymentOption values and returns the last rollback option.
func (r *RefundStarPaymentParams) Option(opts ...RefundStarPaymentOption) (previous RefundStarPaymentOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithRefundStarPaymentUserID sets the UserID field.
//
// Identifier of the user whose payment will be refunded
func WithRefundStarPaymentUserID(value int64) RefundStarPaymentOption {
	return func(params *RefundStarPaymentParams) RefundStarPaymentOption {
		previous := params.UserID
		params.UserID = value

		return WithRefundStarPaymentUserID(previous)
	}
}

// WithRefundStarPaymentTelegramPaymentChargeID sets the TelegramPaymentChargeID field.
//
// Telegram payment identifier
func WithRefundStarPaymentTelegramPaymentChargeID(value string) RefundStarPaymentOption {
	return func(params *RefundStarPaymentParams) RefundStarPaymentOption {
		previous := params.TelegramPaymentChargeID
		params.TelegramPaymentChargeID = value

		return WithRefundStarPaymentTelegramPaymentChargeID(previous)
	}
}

// RefundStarPayment calls the refundStarPayment Telegram Bot API method.
//
// Refunds a successful payment in [Telegram Stars].
// Returns True on success.
//
// [Telegram Stars]: https://t.me/BotNews/90
func (c *Client) RefundStarPayment(params *RefundStarPaymentParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("refundStarPayment", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// RemoveBusinessAccountProfilePhotoParams contains parameters for Client.RemoveBusinessAccountProfilePhoto.
type RemoveBusinessAccountProfilePhotoParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// Pass True to remove the public photo, which is visible even if the main photo is hidden by the business account's privacy settings.
	// After the main photo is removed, the previous profile photo (if present) becomes the main photo.
	IsPublic bool `json:"is_public,omitempty"`
}

// RemoveBusinessAccountProfilePhotoOption configures RemoveBusinessAccountProfilePhotoParams.
type RemoveBusinessAccountProfilePhotoOption func(params *RemoveBusinessAccountProfilePhotoParams) RemoveBusinessAccountProfilePhotoOption

// Option applies one or more RemoveBusinessAccountProfilePhotoOption values and returns the last rollback option.
func (r *RemoveBusinessAccountProfilePhotoParams) Option(opts ...RemoveBusinessAccountProfilePhotoOption) (previous RemoveBusinessAccountProfilePhotoOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithRemoveBusinessAccountProfilePhotoBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithRemoveBusinessAccountProfilePhotoBusinessConnectionID(value string) RemoveBusinessAccountProfilePhotoOption {
	return func(params *RemoveBusinessAccountProfilePhotoParams) RemoveBusinessAccountProfilePhotoOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithRemoveBusinessAccountProfilePhotoBusinessConnectionID(previous)
	}
}

// WithRemoveBusinessAccountProfilePhotoIsPublic sets the IsPublic field.
//
// Pass True to remove the public photo, which is visible even if the main photo is hidden by the business account's privacy settings.
// After the main photo is removed, the previous profile photo (if present) becomes the main photo.
func WithRemoveBusinessAccountProfilePhotoIsPublic(value bool) RemoveBusinessAccountProfilePhotoOption {
	return func(params *RemoveBusinessAccountProfilePhotoParams) RemoveBusinessAccountProfilePhotoOption {
		previous := params.IsPublic
		params.IsPublic = value

		return WithRemoveBusinessAccountProfilePhotoIsPublic(previous)
	}
}

// RemoveBusinessAccountProfilePhoto calls the removeBusinessAccountProfilePhoto Telegram Bot API method.
//
// Removes the current profile photo of a managed business account.
// Requires the can_edit_profile_photo business bot right.
// Returns True on success.
func (c *Client) RemoveBusinessAccountProfilePhoto(params *RemoveBusinessAccountProfilePhotoParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("removeBusinessAccountProfilePhoto", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// RemoveChatVerificationParams contains parameters for Client.RemoveChatVerification.
type RemoveChatVerificationParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`
}

// RemoveChatVerificationOption configures RemoveChatVerificationParams.
type RemoveChatVerificationOption func(params *RemoveChatVerificationParams) RemoveChatVerificationOption

// Option applies one or more RemoveChatVerificationOption values and returns the last rollback option.
func (r *RemoveChatVerificationParams) Option(opts ...RemoveChatVerificationOption) (previous RemoveChatVerificationOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithRemoveChatVerificationChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithRemoveChatVerificationChatID(value string) RemoveChatVerificationOption {
	return func(params *RemoveChatVerificationParams) RemoveChatVerificationOption {
		previous := params.ChatID
		params.ChatID = value

		return WithRemoveChatVerificationChatID(previous)
	}
}

// RemoveChatVerification calls the removeChatVerification Telegram Bot API method.
//
// Removes verification from a chat that is currently verified [on behalf of the organization] represented by the bot.
// Returns True on success.
//
// [on behalf of the organization]: https://telegram.org/verify#third-party-verification
func (c *Client) RemoveChatVerification(params *RemoveChatVerificationParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("removeChatVerification", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// RemoveMyProfilePhotoParams contains parameters for Client.RemoveMyProfilePhoto.
type RemoveMyProfilePhotoParams struct {
}

// RemoveMyProfilePhotoOption configures RemoveMyProfilePhotoParams.
type RemoveMyProfilePhotoOption func(params *RemoveMyProfilePhotoParams) RemoveMyProfilePhotoOption

// Option applies one or more RemoveMyProfilePhotoOption values and returns the last rollback option.
func (r *RemoveMyProfilePhotoParams) Option(opts ...RemoveMyProfilePhotoOption) (previous RemoveMyProfilePhotoOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// RemoveMyProfilePhoto calls the removeMyProfilePhoto Telegram Bot API method.
//
// Removes the profile photo of the bot.
// Requires no parameters.
// Returns True on success.
func (c *Client) RemoveMyProfilePhoto(params *RemoveMyProfilePhotoParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("removeMyProfilePhoto", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// RemoveUserVerificationParams contains parameters for Client.RemoveUserVerification.
type RemoveUserVerificationParams struct {
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`
}

// RemoveUserVerificationOption configures RemoveUserVerificationParams.
type RemoveUserVerificationOption func(params *RemoveUserVerificationParams) RemoveUserVerificationOption

// Option applies one or more RemoveUserVerificationOption values and returns the last rollback option.
func (r *RemoveUserVerificationParams) Option(opts ...RemoveUserVerificationOption) (previous RemoveUserVerificationOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithRemoveUserVerificationUserID sets the UserID field.
//
// Unique identifier of the target user
func WithRemoveUserVerificationUserID(value int64) RemoveUserVerificationOption {
	return func(params *RemoveUserVerificationParams) RemoveUserVerificationOption {
		previous := params.UserID
		params.UserID = value

		return WithRemoveUserVerificationUserID(previous)
	}
}

// RemoveUserVerification calls the removeUserVerification Telegram Bot API method.
//
// Removes verification from a user who is currently verified [on behalf of the organization] represented by the bot.
// Returns True on success.
//
// [on behalf of the organization]: https://telegram.org/verify#third-party-verification
func (c *Client) RemoveUserVerification(params *RemoveUserVerificationParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("removeUserVerification", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// ReopenForumTopicParams contains parameters for Client.ReopenForumTopic.
type ReopenForumTopicParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread of the forum topic
	MessageThreadID int64 `json:"message_thread_id"`
}

// ReopenForumTopicOption configures ReopenForumTopicParams.
type ReopenForumTopicOption func(params *ReopenForumTopicParams) ReopenForumTopicOption

// Option applies one or more ReopenForumTopicOption values and returns the last rollback option.
func (r *ReopenForumTopicParams) Option(opts ...ReopenForumTopicOption) (previous ReopenForumTopicOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithReopenForumTopicChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithReopenForumTopicChatID(value string) ReopenForumTopicOption {
	return func(params *ReopenForumTopicParams) ReopenForumTopicOption {
		previous := params.ChatID
		params.ChatID = value

		return WithReopenForumTopicChatID(previous)
	}
}

// WithReopenForumTopicMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread of the forum topic
func WithReopenForumTopicMessageThreadID(value int64) ReopenForumTopicOption {
	return func(params *ReopenForumTopicParams) ReopenForumTopicOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithReopenForumTopicMessageThreadID(previous)
	}
}

// ReopenForumTopic calls the reopenForumTopic Telegram Bot API method.
//
// Use this method to reopen a closed topic in a forum supergroup chat.
// The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights, unless it is the creator of the topic.
// Returns True on success.
func (c *Client) ReopenForumTopic(params *ReopenForumTopicParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("reopenForumTopic", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// ReopenGeneralForumTopicParams contains parameters for Client.ReopenGeneralForumTopic.
type ReopenGeneralForumTopicParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`
}

// ReopenGeneralForumTopicOption configures ReopenGeneralForumTopicParams.
type ReopenGeneralForumTopicOption func(params *ReopenGeneralForumTopicParams) ReopenGeneralForumTopicOption

// Option applies one or more ReopenGeneralForumTopicOption values and returns the last rollback option.
func (r *ReopenGeneralForumTopicParams) Option(opts ...ReopenGeneralForumTopicOption) (previous ReopenGeneralForumTopicOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithReopenGeneralForumTopicChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithReopenGeneralForumTopicChatID(value string) ReopenGeneralForumTopicOption {
	return func(params *ReopenGeneralForumTopicParams) ReopenGeneralForumTopicOption {
		previous := params.ChatID
		params.ChatID = value

		return WithReopenGeneralForumTopicChatID(previous)
	}
}

// ReopenGeneralForumTopic calls the reopenGeneralForumTopic Telegram Bot API method.
//
// Use this method to reopen a closed 'General' topic in a forum supergroup chat.
// The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.
// The topic will be automatically unhidden if it was hidden.
// Returns True on success.
func (c *Client) ReopenGeneralForumTopic(params *ReopenGeneralForumTopicParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("reopenGeneralForumTopic", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// ReplaceStickerInSetParams contains parameters for Client.ReplaceStickerInSet.
type ReplaceStickerInSetParams struct {
	// User identifier of the sticker set owner
	UserID int64 `json:"user_id"`

	// Sticker set name
	Name string `json:"name"`

	// File identifier of the replaced sticker
	OldSticker string `json:"old_sticker"`

	// A JSON-serialized object with information about the added sticker.
	// If exactly the same sticker had already been added to the set, then the set remains unchanged.
	Sticker InputSticker `json:"sticker"`
}

// ReplaceStickerInSetOption configures ReplaceStickerInSetParams.
type ReplaceStickerInSetOption func(params *ReplaceStickerInSetParams) ReplaceStickerInSetOption

// Option applies one or more ReplaceStickerInSetOption values and returns the last rollback option.
func (r *ReplaceStickerInSetParams) Option(opts ...ReplaceStickerInSetOption) (previous ReplaceStickerInSetOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithReplaceStickerInSetUserID sets the UserID field.
//
// User identifier of the sticker set owner
func WithReplaceStickerInSetUserID(value int64) ReplaceStickerInSetOption {
	return func(params *ReplaceStickerInSetParams) ReplaceStickerInSetOption {
		previous := params.UserID
		params.UserID = value

		return WithReplaceStickerInSetUserID(previous)
	}
}

// WithReplaceStickerInSetName sets the Name field.
//
// Sticker set name
func WithReplaceStickerInSetName(value string) ReplaceStickerInSetOption {
	return func(params *ReplaceStickerInSetParams) ReplaceStickerInSetOption {
		previous := params.Name
		params.Name = value

		return WithReplaceStickerInSetName(previous)
	}
}

// WithReplaceStickerInSetOldSticker sets the OldSticker field.
//
// File identifier of the replaced sticker
func WithReplaceStickerInSetOldSticker(value string) ReplaceStickerInSetOption {
	return func(params *ReplaceStickerInSetParams) ReplaceStickerInSetOption {
		previous := params.OldSticker
		params.OldSticker = value

		return WithReplaceStickerInSetOldSticker(previous)
	}
}

// WithReplaceStickerInSetSticker sets the Sticker field.
//
// A JSON-serialized object with information about the added sticker.
// If exactly the same sticker had already been added to the set, then the set remains unchanged.
func WithReplaceStickerInSetSticker(value InputSticker) ReplaceStickerInSetOption {
	return func(params *ReplaceStickerInSetParams) ReplaceStickerInSetOption {
		previous := params.Sticker
		params.Sticker = value

		return WithReplaceStickerInSetSticker(previous)
	}
}

// ReplaceStickerInSet calls the replaceStickerInSet Telegram Bot API method.
//
// Use this method to replace an existing sticker in a sticker set with a new one.
// The method is equivalent to calling [deleteStickerFromSet], then [addStickerToSet], then [setStickerPositionInSet].
// Returns True on success.
//
// [deleteStickerFromSet]: https://core.telegram.org/bots/api#deletestickerfromset
// [addStickerToSet]: https://core.telegram.org/bots/api#addstickertoset
// [setStickerPositionInSet]: https://core.telegram.org/bots/api#setstickerpositioninset
func (c *Client) ReplaceStickerInSet(params *ReplaceStickerInSetParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("replaceStickerInSet", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// RepostStoryParams contains parameters for Client.RepostStory.
type RepostStoryParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// Unique identifier of the chat which posted the story that should be reposted
	FromChatID int64 `json:"from_chat_id"`

	// Unique identifier of the story that should be reposted
	FromStoryID int64 `json:"from_story_id"`

	// Period after which the story is moved to the archive, in seconds; must be one of 6 * 3600, 12 * 3600, 86400, or 2 * 86400
	ActivePeriod int64 `json:"active_period"`

	// Pass True to keep the story accessible after it expires
	PostToChatPage bool `json:"post_to_chat_page,omitempty"`

	// Pass True if the content of the story must be protected from forwarding and screenshotting
	ProtectContent bool `json:"protect_content,omitempty"`
}

// RepostStoryOption configures RepostStoryParams.
type RepostStoryOption func(params *RepostStoryParams) RepostStoryOption

// Option applies one or more RepostStoryOption values and returns the last rollback option.
func (r *RepostStoryParams) Option(opts ...RepostStoryOption) (previous RepostStoryOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithRepostStoryBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithRepostStoryBusinessConnectionID(value string) RepostStoryOption {
	return func(params *RepostStoryParams) RepostStoryOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithRepostStoryBusinessConnectionID(previous)
	}
}

// WithRepostStoryFromChatID sets the FromChatID field.
//
// Unique identifier of the chat which posted the story that should be reposted
func WithRepostStoryFromChatID(value int64) RepostStoryOption {
	return func(params *RepostStoryParams) RepostStoryOption {
		previous := params.FromChatID
		params.FromChatID = value

		return WithRepostStoryFromChatID(previous)
	}
}

// WithRepostStoryFromStoryID sets the FromStoryID field.
//
// Unique identifier of the story that should be reposted
func WithRepostStoryFromStoryID(value int64) RepostStoryOption {
	return func(params *RepostStoryParams) RepostStoryOption {
		previous := params.FromStoryID
		params.FromStoryID = value

		return WithRepostStoryFromStoryID(previous)
	}
}

// WithRepostStoryActivePeriod sets the ActivePeriod field.
//
// Period after which the story is moved to the archive, in seconds; must be one of 6 * 3600, 12 * 3600, 86400, or 2 * 86400
func WithRepostStoryActivePeriod(value int64) RepostStoryOption {
	return func(params *RepostStoryParams) RepostStoryOption {
		previous := params.ActivePeriod
		params.ActivePeriod = value

		return WithRepostStoryActivePeriod(previous)
	}
}

// WithRepostStoryPostToChatPage sets the PostToChatPage field.
//
// Pass True to keep the story accessible after it expires
func WithRepostStoryPostToChatPage(value bool) RepostStoryOption {
	return func(params *RepostStoryParams) RepostStoryOption {
		previous := params.PostToChatPage
		params.PostToChatPage = value

		return WithRepostStoryPostToChatPage(previous)
	}
}

// WithRepostStoryProtectContent sets the ProtectContent field.
//
// Pass True if the content of the story must be protected from forwarding and screenshotting
func WithRepostStoryProtectContent(value bool) RepostStoryOption {
	return func(params *RepostStoryParams) RepostStoryOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithRepostStoryProtectContent(previous)
	}
}

// RepostStory calls the repostStory Telegram Bot API method.
//
// Reposts a story on behalf of a business account from another business account.
// Both business accounts must be managed by the same bot, and the story on the source account must have been posted (or reposted) by the bot.
// Requires the can_manage_stories business bot right for both business accounts.
// Returns [Story] on success.
//
// [Story]: https://core.telegram.org/bots/api#story
func (c *Client) RepostStory(params *RepostStoryParams) (ret *Story, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("repostStory", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Story)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// RestrictChatMemberParams contains parameters for Client.RestrictChatMember.
type RestrictChatMemberParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int64 `json:"user_id"`

	// A JSON-serialized object for new user permissions
	Permissions ChatPermissions `json:"permissions"`

	// Pass True if chat permissions are set independently.
	// Otherwise, the can_send_other_messages and can_add_web_page_previews permissions will imply the can_send_messages, can_send_audios, can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, and can_send_voice_notes permissions; the can_send_polls permission will imply the can_send_messages permission.
	UseIndependentChatPermissions bool `json:"use_independent_chat_permissions,omitempty"`

	// Date when restrictions will be lifted for the user; Unix time.
	// If user is restricted for more than 366 days or less than 30 seconds from the current time, they are considered to be restricted forever
	UntilDate int64 `json:"until_date,omitempty"`
}

// RestrictChatMemberOption configures RestrictChatMemberParams.
type RestrictChatMemberOption func(params *RestrictChatMemberParams) RestrictChatMemberOption

// Option applies one or more RestrictChatMemberOption values and returns the last rollback option.
func (r *RestrictChatMemberParams) Option(opts ...RestrictChatMemberOption) (previous RestrictChatMemberOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithRestrictChatMemberChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithRestrictChatMemberChatID(value string) RestrictChatMemberOption {
	return func(params *RestrictChatMemberParams) RestrictChatMemberOption {
		previous := params.ChatID
		params.ChatID = value

		return WithRestrictChatMemberChatID(previous)
	}
}

// WithRestrictChatMemberUserID sets the UserID field.
//
// Unique identifier of the target user
func WithRestrictChatMemberUserID(value int64) RestrictChatMemberOption {
	return func(params *RestrictChatMemberParams) RestrictChatMemberOption {
		previous := params.UserID
		params.UserID = value

		return WithRestrictChatMemberUserID(previous)
	}
}

// WithRestrictChatMemberPermissions sets the Permissions field.
//
// A JSON-serialized object for new user permissions
func WithRestrictChatMemberPermissions(value ChatPermissions) RestrictChatMemberOption {
	return func(params *RestrictChatMemberParams) RestrictChatMemberOption {
		previous := params.Permissions
		params.Permissions = value

		return WithRestrictChatMemberPermissions(previous)
	}
}

// WithRestrictChatMemberUseIndependentChatPermissions sets the UseIndependentChatPermissions field.
//
// Pass True if chat permissions are set independently.
// Otherwise, the can_send_other_messages and can_add_web_page_previews permissions will imply the can_send_messages, can_send_audios, can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, and can_send_voice_notes permissions; the can_send_polls permission will imply the can_send_messages permission.
func WithRestrictChatMemberUseIndependentChatPermissions(value bool) RestrictChatMemberOption {
	return func(params *RestrictChatMemberParams) RestrictChatMemberOption {
		previous := params.UseIndependentChatPermissions
		params.UseIndependentChatPermissions = value

		return WithRestrictChatMemberUseIndependentChatPermissions(previous)
	}
}

// WithRestrictChatMemberUntilDate sets the UntilDate field.
//
// Date when restrictions will be lifted for the user; Unix time.
// If user is restricted for more than 366 days or less than 30 seconds from the current time, they are considered to be restricted forever
func WithRestrictChatMemberUntilDate(value int64) RestrictChatMemberOption {
	return func(params *RestrictChatMemberParams) RestrictChatMemberOption {
		previous := params.UntilDate
		params.UntilDate = value

		return WithRestrictChatMemberUntilDate(previous)
	}
}

// RestrictChatMember calls the restrictChatMember Telegram Bot API method.
//
// Use this method to restrict a user in a supergroup.
// The bot must be an administrator in the supergroup for this to work and must have the appropriate administrator rights.
// Pass True for all permissions to lift restrictions from a user.
// Returns True on success.
func (c *Client) RestrictChatMember(params *RestrictChatMemberParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("restrictChatMember", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// RevokeChatInviteLinkParams contains parameters for Client.RevokeChatInviteLink.
type RevokeChatInviteLinkParams struct {
	// Unique identifier of the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// The invite link to revoke
	InviteLink string `json:"invite_link"`
}

// RevokeChatInviteLinkOption configures RevokeChatInviteLinkParams.
type RevokeChatInviteLinkOption func(params *RevokeChatInviteLinkParams) RevokeChatInviteLinkOption

// Option applies one or more RevokeChatInviteLinkOption values and returns the last rollback option.
func (r *RevokeChatInviteLinkParams) Option(opts ...RevokeChatInviteLinkOption) (previous RevokeChatInviteLinkOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithRevokeChatInviteLinkChatID sets the ChatID field.
//
// Unique identifier of the target chat or username of the target channel (in the format @channelusername)
func WithRevokeChatInviteLinkChatID(value string) RevokeChatInviteLinkOption {
	return func(params *RevokeChatInviteLinkParams) RevokeChatInviteLinkOption {
		previous := params.ChatID
		params.ChatID = value

		return WithRevokeChatInviteLinkChatID(previous)
	}
}

// WithRevokeChatInviteLinkInviteLink sets the InviteLink field.
//
// The invite link to revoke
func WithRevokeChatInviteLinkInviteLink(value string) RevokeChatInviteLinkOption {
	return func(params *RevokeChatInviteLinkParams) RevokeChatInviteLinkOption {
		previous := params.InviteLink
		params.InviteLink = value

		return WithRevokeChatInviteLinkInviteLink(previous)
	}
}

// RevokeChatInviteLink calls the revokeChatInviteLink Telegram Bot API method.
//
// Use this method to revoke an invite link created by the bot.
// If the primary link is revoked, a new link is automatically generated.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns the revoked invite link as [ChatInviteLink] object.
//
// [ChatInviteLink]: https://core.telegram.org/bots/api#chatinvitelink
func (c *Client) RevokeChatInviteLink(params *RevokeChatInviteLinkParams) (ret *ChatInviteLink, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("revokeChatInviteLink", reader, contentType)
	if err != nil {
		return
	}

	ret = new(ChatInviteLink)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SavePreparedInlineMessageParams contains parameters for Client.SavePreparedInlineMessage.
type SavePreparedInlineMessageParams struct {
	// Unique identifier of the target user that can use the prepared message
	UserID int64 `json:"user_id"`

	// A JSON-serialized object describing the message to be sent
	Result InlineQueryResult `json:"result"`

	// Pass True if the message can be sent to private chats with users
	AllowUserChats bool `json:"allow_user_chats,omitempty"`

	// Pass True if the message can be sent to private chats with bots
	AllowBotChats bool `json:"allow_bot_chats,omitempty"`

	// Pass True if the message can be sent to group and supergroup chats
	AllowGroupChats bool `json:"allow_group_chats,omitempty"`

	// Pass True if the message can be sent to channel chats
	AllowChannelChats bool `json:"allow_channel_chats,omitempty"`
}

// SavePreparedInlineMessageOption configures SavePreparedInlineMessageParams.
type SavePreparedInlineMessageOption func(params *SavePreparedInlineMessageParams) SavePreparedInlineMessageOption

// Option applies one or more SavePreparedInlineMessageOption values and returns the last rollback option.
func (r *SavePreparedInlineMessageParams) Option(opts ...SavePreparedInlineMessageOption) (previous SavePreparedInlineMessageOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSavePreparedInlineMessageUserID sets the UserID field.
//
// Unique identifier of the target user that can use the prepared message
func WithSavePreparedInlineMessageUserID(value int64) SavePreparedInlineMessageOption {
	return func(params *SavePreparedInlineMessageParams) SavePreparedInlineMessageOption {
		previous := params.UserID
		params.UserID = value

		return WithSavePreparedInlineMessageUserID(previous)
	}
}

// WithSavePreparedInlineMessageResult sets the Result field.
//
// A JSON-serialized object describing the message to be sent
func WithSavePreparedInlineMessageResult(value InlineQueryResult) SavePreparedInlineMessageOption {
	return func(params *SavePreparedInlineMessageParams) SavePreparedInlineMessageOption {
		previous := params.Result
		params.Result = value

		return WithSavePreparedInlineMessageResult(previous)
	}
}

// WithSavePreparedInlineMessageAllowUserChats sets the AllowUserChats field.
//
// Pass True if the message can be sent to private chats with users
func WithSavePreparedInlineMessageAllowUserChats(value bool) SavePreparedInlineMessageOption {
	return func(params *SavePreparedInlineMessageParams) SavePreparedInlineMessageOption {
		previous := params.AllowUserChats
		params.AllowUserChats = value

		return WithSavePreparedInlineMessageAllowUserChats(previous)
	}
}

// WithSavePreparedInlineMessageAllowBotChats sets the AllowBotChats field.
//
// Pass True if the message can be sent to private chats with bots
func WithSavePreparedInlineMessageAllowBotChats(value bool) SavePreparedInlineMessageOption {
	return func(params *SavePreparedInlineMessageParams) SavePreparedInlineMessageOption {
		previous := params.AllowBotChats
		params.AllowBotChats = value

		return WithSavePreparedInlineMessageAllowBotChats(previous)
	}
}

// WithSavePreparedInlineMessageAllowGroupChats sets the AllowGroupChats field.
//
// Pass True if the message can be sent to group and supergroup chats
func WithSavePreparedInlineMessageAllowGroupChats(value bool) SavePreparedInlineMessageOption {
	return func(params *SavePreparedInlineMessageParams) SavePreparedInlineMessageOption {
		previous := params.AllowGroupChats
		params.AllowGroupChats = value

		return WithSavePreparedInlineMessageAllowGroupChats(previous)
	}
}

// WithSavePreparedInlineMessageAllowChannelChats sets the AllowChannelChats field.
//
// Pass True if the message can be sent to channel chats
func WithSavePreparedInlineMessageAllowChannelChats(value bool) SavePreparedInlineMessageOption {
	return func(params *SavePreparedInlineMessageParams) SavePreparedInlineMessageOption {
		previous := params.AllowChannelChats
		params.AllowChannelChats = value

		return WithSavePreparedInlineMessageAllowChannelChats(previous)
	}
}

// SavePreparedInlineMessage calls the savePreparedInlineMessage Telegram Bot API method.
//
// Stores a message that can be sent by a user of a Mini App.
// Returns a [PreparedInlineMessage] object.
//
// [PreparedInlineMessage]: https://core.telegram.org/bots/api#preparedinlinemessage
func (c *Client) SavePreparedInlineMessage(params *SavePreparedInlineMessageParams) (ret *PreparedInlineMessage, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("savePreparedInlineMessage", reader, contentType)
	if err != nil {
		return
	}

	ret = new(PreparedInlineMessage)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendAnimationParams contains parameters for Client.SendAnimation.
type SendAnimationParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Animation to send.
	// Pass a file_id as String to send an animation that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get an animation from the Internet, or upload a new animation using multipart/form-data.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Animation InputFile `json:"animation"`

	// Duration of sent animation in seconds
	Duration int64 `json:"duration,omitempty"`

	// Animation width
	Width int64 `json:"width,omitempty"`

	// Animation height
	Height int64 `json:"height,omitempty"`

	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side.
	// The thumbnail should be in JPEG format and less than 200 kB in size.
	// A thumbnail's width and height should not exceed 320.
	// Ignored if the file is not uploaded using multipart/form-data.
	// Thumbnails can't be reused and can be only uploaded as a new file, so you can pass “attach://<file_attach_name>” if the thumbnail was uploaded using multipart/form-data under <file_attach_name>.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Thumbnail *InputFile `json:"thumbnail,omitempty"`

	// Animation caption (may also be used when resending animation by file_id), 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Mode for parsing entities in the animation caption.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Pass True, if the caption must be shown above the message media
	ShowCaptionAboveMedia bool `json:"show_caption_above_media,omitempty"`

	// Pass True if the animation needs to be covered with a spoiler animation
	HasSpoiler bool `json:"has_spoiler,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendAnimationOption configures SendAnimationParams.
type SendAnimationOption func(params *SendAnimationParams) SendAnimationOption

// Option applies one or more SendAnimationOption values and returns the last rollback option.
func (r *SendAnimationParams) Option(opts ...SendAnimationOption) (previous SendAnimationOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendAnimationBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendAnimationBusinessConnectionID(value string) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendAnimationBusinessConnectionID(previous)
	}
}

// WithSendAnimationChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendAnimationChatID(value string) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendAnimationChatID(previous)
	}
}

// WithSendAnimationMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendAnimationMessageThreadID(value int64) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendAnimationMessageThreadID(previous)
	}
}

// WithSendAnimationDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendAnimationDirectMessagesTopicID(value int64) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendAnimationDirectMessagesTopicID(previous)
	}
}

// WithSendAnimationAnimation sets the Animation field.
//
// Animation to send.
// Pass a file_id as String to send an animation that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get an animation from the Internet, or upload a new animation using multipart/form-data.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendAnimationAnimation(value InputFile) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.Animation
		params.Animation = value

		return WithSendAnimationAnimation(previous)
	}
}

// WithSendAnimationDuration sets the Duration field.
//
// Duration of sent animation in seconds
func WithSendAnimationDuration(value int64) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.Duration
		params.Duration = value

		return WithSendAnimationDuration(previous)
	}
}

// WithSendAnimationWidth sets the Width field.
//
// Animation width
func WithSendAnimationWidth(value int64) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.Width
		params.Width = value

		return WithSendAnimationWidth(previous)
	}
}

// WithSendAnimationHeight sets the Height field.
//
// Animation height
func WithSendAnimationHeight(value int64) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.Height
		params.Height = value

		return WithSendAnimationHeight(previous)
	}
}

// WithSendAnimationThumbnail sets the Thumbnail field.
//
// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side.
// The thumbnail should be in JPEG format and less than 200 kB in size.
// A thumbnail's width and height should not exceed 320.
// Ignored if the file is not uploaded using multipart/form-data.
// Thumbnails can't be reused and can be only uploaded as a new file, so you can pass “attach://<file_attach_name>” if the thumbnail was uploaded using multipart/form-data under <file_attach_name>.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendAnimationThumbnail(value *InputFile) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.Thumbnail
		params.Thumbnail = value

		return WithSendAnimationThumbnail(previous)
	}
}

// WithSendAnimationCaption sets the Caption field.
//
// Animation caption (may also be used when resending animation by file_id), 0-1024 characters after entities parsing
func WithSendAnimationCaption(value string) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.Caption
		params.Caption = value

		return WithSendAnimationCaption(previous)
	}
}

// WithSendAnimationParseMode sets the ParseMode field.
//
// Mode for parsing entities in the animation caption.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendAnimationParseMode(value string) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithSendAnimationParseMode(previous)
	}
}

// WithSendAnimationCaptionEntities sets the CaptionEntities field.
//
// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
func WithSendAnimationCaptionEntities(value []MessageEntity) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.CaptionEntities
		params.CaptionEntities = value

		return WithSendAnimationCaptionEntities(previous)
	}
}

// WithSendAnimationShowCaptionAboveMedia sets the ShowCaptionAboveMedia field.
//
// Pass True, if the caption must be shown above the message media
func WithSendAnimationShowCaptionAboveMedia(value bool) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.ShowCaptionAboveMedia
		params.ShowCaptionAboveMedia = value

		return WithSendAnimationShowCaptionAboveMedia(previous)
	}
}

// WithSendAnimationHasSpoiler sets the HasSpoiler field.
//
// Pass True if the animation needs to be covered with a spoiler animation
func WithSendAnimationHasSpoiler(value bool) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.HasSpoiler
		params.HasSpoiler = value

		return WithSendAnimationHasSpoiler(previous)
	}
}

// WithSendAnimationDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendAnimationDisableNotification(value bool) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendAnimationDisableNotification(previous)
	}
}

// WithSendAnimationProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendAnimationProtectContent(value bool) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendAnimationProtectContent(previous)
	}
}

// WithSendAnimationAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendAnimationAllowPaidBroadcast(value bool) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendAnimationAllowPaidBroadcast(previous)
	}
}

// WithSendAnimationMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendAnimationMessageEffectID(value string) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendAnimationMessageEffectID(previous)
	}
}

// WithSendAnimationSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendAnimationSuggestedPostParameters(value *SuggestedPostParameters) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendAnimationSuggestedPostParameters(previous)
	}
}

// WithSendAnimationReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendAnimationReplyParameters(value *ReplyParameters) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendAnimationReplyParameters(previous)
	}
}

// WithSendAnimationReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendAnimationReplyMarkup(value *ReplyMarkup) SendAnimationOption {
	return func(params *SendAnimationParams) SendAnimationOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendAnimationReplyMarkup(previous)
	}
}

// SendAnimation calls the sendAnimation Telegram Bot API method.
//
// Use this method to send animation files (GIF or H.264/MPEG-4 AVC video without sound).
// On success, the sent [Message] is returned.
// Bots can currently send animation files of up to 50 MB in size, this limit may be changed in the future.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendAnimation(params *SendAnimationParams) (ret *Message, err error) {
	var bs []byte

	reader, pw := io.Pipe()
	writer := multipart.NewWriter(pw)

	go func() {
		defer pw.Close()
		defer writer.Close()

		if params.BusinessConnectionID != "" {
			err = writer.WriteField("business_connection_id", params.BusinessConnectionID)
			if err != nil {
				return
			}
		}

		{
			err = writer.WriteField("chat_id", params.ChatID)
			if err != nil {
				return
			}
		}

		if params.MessageThreadID != 0 {
			v := strconv.FormatInt(params.MessageThreadID, 10)
			err = writer.WriteField("message_thread_id", v)
			if err != nil {
				return
			}
		}

		if params.DirectMessagesTopicID != 0 {
			v := strconv.FormatInt(params.DirectMessagesTopicID, 10)
			err = writer.WriteField("direct_messages_topic_id", v)
			if err != nil {
				return
			}
		}

		{
			if params.Animation.File != nil {
				var w io.Writer
				params.Animation.fieldName = "animation"

				w, err = writer.CreateFormFile(
					params.Animation.fieldName,
					params.Animation.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Animation.File)
				if err != nil {
					return
				}

				if closer, ok := params.Animation.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Animation)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("animation")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.Duration != 0 {
			v := strconv.FormatInt(params.Duration, 10)
			err = writer.WriteField("duration", v)
			if err != nil {
				return
			}
		}

		if params.Width != 0 {
			v := strconv.FormatInt(params.Width, 10)
			err = writer.WriteField("width", v)
			if err != nil {
				return
			}
		}

		if params.Height != 0 {
			v := strconv.FormatInt(params.Height, 10)
			err = writer.WriteField("height", v)
			if err != nil {
				return
			}
		}

		if params.Thumbnail != nil {
			if params.Thumbnail.File != nil {
				var w io.Writer
				params.Thumbnail.fieldName = "thumbnail"

				w, err = writer.CreateFormFile(
					params.Thumbnail.fieldName,
					params.Thumbnail.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Thumbnail.File)
				if err != nil {
					return
				}

				if closer, ok := params.Thumbnail.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Thumbnail)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("thumbnail")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.Caption != "" {
			err = writer.WriteField("caption", params.Caption)
			if err != nil {
				return
			}
		}

		if params.ParseMode != "" {
			err = writer.WriteField("parse_mode", params.ParseMode)
			if err != nil {
				return
			}
		}

		if params.CaptionEntities != nil {

			bs, err = json.Marshal(params.CaptionEntities)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("caption_entities")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ShowCaptionAboveMedia {
			v := strconv.FormatBool(params.ShowCaptionAboveMedia)
			err = writer.WriteField("show_caption_above_media", v)
			if err != nil {
				return
			}
		}

		if params.HasSpoiler {
			v := strconv.FormatBool(params.HasSpoiler)
			err = writer.WriteField("has_spoiler", v)
			if err != nil {
				return
			}
		}

		if params.DisableNotification {
			v := strconv.FormatBool(params.DisableNotification)
			err = writer.WriteField("disable_notification", v)
			if err != nil {
				return
			}
		}

		if params.ProtectContent {
			v := strconv.FormatBool(params.ProtectContent)
			err = writer.WriteField("protect_content", v)
			if err != nil {
				return
			}
		}

		if params.AllowPaidBroadcast {
			v := strconv.FormatBool(params.AllowPaidBroadcast)
			err = writer.WriteField("allow_paid_broadcast", v)
			if err != nil {
				return
			}
		}

		if params.MessageEffectID != "" {
			err = writer.WriteField("message_effect_id", params.MessageEffectID)
			if err != nil {
				return
			}
		}

		if params.SuggestedPostParameters != nil {

			bs, err = json.Marshal(params.SuggestedPostParameters)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("suggested_post_parameters")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ReplyParameters != nil {

			bs, err = json.Marshal(params.ReplyParameters)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("reply_parameters")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ReplyMarkup != nil {

			bs, err = json.Marshal(params.ReplyMarkup)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("reply_markup")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

	}()

	contentType := writer.FormDataContentType()

	var result json.RawMessage

	result, err = c.Raw("sendAnimation", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendAudioParams contains parameters for Client.SendAudio.
type SendAudioParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Audio file to send.
	// Pass a file_id as String to send an audio file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get an audio file from the Internet, or upload a new one using multipart/form-data.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Audio InputFile `json:"audio"`

	// Audio caption, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Mode for parsing entities in the audio caption.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Duration of the audio in seconds
	Duration int64 `json:"duration,omitempty"`

	// Performer
	Performer string `json:"performer,omitempty"`

	// Track name
	Title string `json:"title,omitempty"`

	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side.
	// The thumbnail should be in JPEG format and less than 200 kB in size.
	// A thumbnail's width and height should not exceed 320.
	// Ignored if the file is not uploaded using multipart/form-data.
	// Thumbnails can't be reused and can be only uploaded as a new file, so you can pass “attach://<file_attach_name>” if the thumbnail was uploaded using multipart/form-data under <file_attach_name>.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Thumbnail *InputFile `json:"thumbnail,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendAudioOption configures SendAudioParams.
type SendAudioOption func(params *SendAudioParams) SendAudioOption

// Option applies one or more SendAudioOption values and returns the last rollback option.
func (r *SendAudioParams) Option(opts ...SendAudioOption) (previous SendAudioOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendAudioBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendAudioBusinessConnectionID(value string) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendAudioBusinessConnectionID(previous)
	}
}

// WithSendAudioChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendAudioChatID(value string) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendAudioChatID(previous)
	}
}

// WithSendAudioMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendAudioMessageThreadID(value int64) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendAudioMessageThreadID(previous)
	}
}

// WithSendAudioDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendAudioDirectMessagesTopicID(value int64) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendAudioDirectMessagesTopicID(previous)
	}
}

// WithSendAudioAudio sets the Audio field.
//
// Audio file to send.
// Pass a file_id as String to send an audio file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get an audio file from the Internet, or upload a new one using multipart/form-data.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendAudioAudio(value InputFile) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.Audio
		params.Audio = value

		return WithSendAudioAudio(previous)
	}
}

// WithSendAudioCaption sets the Caption field.
//
// Audio caption, 0-1024 characters after entities parsing
func WithSendAudioCaption(value string) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.Caption
		params.Caption = value

		return WithSendAudioCaption(previous)
	}
}

// WithSendAudioParseMode sets the ParseMode field.
//
// Mode for parsing entities in the audio caption.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendAudioParseMode(value string) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithSendAudioParseMode(previous)
	}
}

// WithSendAudioCaptionEntities sets the CaptionEntities field.
//
// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
func WithSendAudioCaptionEntities(value []MessageEntity) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.CaptionEntities
		params.CaptionEntities = value

		return WithSendAudioCaptionEntities(previous)
	}
}

// WithSendAudioDuration sets the Duration field.
//
// Duration of the audio in seconds
func WithSendAudioDuration(value int64) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.Duration
		params.Duration = value

		return WithSendAudioDuration(previous)
	}
}

// WithSendAudioPerformer sets the Performer field.
//
// Performer
func WithSendAudioPerformer(value string) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.Performer
		params.Performer = value

		return WithSendAudioPerformer(previous)
	}
}

// WithSendAudioTitle sets the Title field.
//
// Track name
func WithSendAudioTitle(value string) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.Title
		params.Title = value

		return WithSendAudioTitle(previous)
	}
}

// WithSendAudioThumbnail sets the Thumbnail field.
//
// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side.
// The thumbnail should be in JPEG format and less than 200 kB in size.
// A thumbnail's width and height should not exceed 320.
// Ignored if the file is not uploaded using multipart/form-data.
// Thumbnails can't be reused and can be only uploaded as a new file, so you can pass “attach://<file_attach_name>” if the thumbnail was uploaded using multipart/form-data under <file_attach_name>.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendAudioThumbnail(value *InputFile) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.Thumbnail
		params.Thumbnail = value

		return WithSendAudioThumbnail(previous)
	}
}

// WithSendAudioDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendAudioDisableNotification(value bool) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendAudioDisableNotification(previous)
	}
}

// WithSendAudioProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendAudioProtectContent(value bool) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendAudioProtectContent(previous)
	}
}

// WithSendAudioAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendAudioAllowPaidBroadcast(value bool) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendAudioAllowPaidBroadcast(previous)
	}
}

// WithSendAudioMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendAudioMessageEffectID(value string) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendAudioMessageEffectID(previous)
	}
}

// WithSendAudioSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendAudioSuggestedPostParameters(value *SuggestedPostParameters) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendAudioSuggestedPostParameters(previous)
	}
}

// WithSendAudioReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendAudioReplyParameters(value *ReplyParameters) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendAudioReplyParameters(previous)
	}
}

// WithSendAudioReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendAudioReplyMarkup(value *ReplyMarkup) SendAudioOption {
	return func(params *SendAudioParams) SendAudioOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendAudioReplyMarkup(previous)
	}
}

// SendAudio calls the sendAudio Telegram Bot API method.
//
// Use this method to send audio files, if you want Telegram clients to display them in the music player.
// Your audio must be in the .MP3 or .M4A format.
// On success, the sent [Message] is returned.
// Bots can currently send audio files of up to 50 MB in size, this limit may be changed in the future.
// For sending voice messages, use the [sendVoice] method instead.
//
// [Message]: https://core.telegram.org/bots/api#message
// [sendVoice]: https://core.telegram.org/bots/api#sendvoice
func (c *Client) SendAudio(params *SendAudioParams) (ret *Message, err error) {
	var bs []byte

	reader, pw := io.Pipe()
	writer := multipart.NewWriter(pw)

	go func() {
		defer pw.Close()
		defer writer.Close()

		if params.BusinessConnectionID != "" {
			err = writer.WriteField("business_connection_id", params.BusinessConnectionID)
			if err != nil {
				return
			}
		}

		{
			err = writer.WriteField("chat_id", params.ChatID)
			if err != nil {
				return
			}
		}

		if params.MessageThreadID != 0 {
			v := strconv.FormatInt(params.MessageThreadID, 10)
			err = writer.WriteField("message_thread_id", v)
			if err != nil {
				return
			}
		}

		if params.DirectMessagesTopicID != 0 {
			v := strconv.FormatInt(params.DirectMessagesTopicID, 10)
			err = writer.WriteField("direct_messages_topic_id", v)
			if err != nil {
				return
			}
		}

		{
			if params.Audio.File != nil {
				var w io.Writer
				params.Audio.fieldName = "audio"

				w, err = writer.CreateFormFile(
					params.Audio.fieldName,
					params.Audio.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Audio.File)
				if err != nil {
					return
				}

				if closer, ok := params.Audio.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Audio)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("audio")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.Caption != "" {
			err = writer.WriteField("caption", params.Caption)
			if err != nil {
				return
			}
		}

		if params.ParseMode != "" {
			err = writer.WriteField("parse_mode", params.ParseMode)
			if err != nil {
				return
			}
		}

		if params.CaptionEntities != nil {

			bs, err = json.Marshal(params.CaptionEntities)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("caption_entities")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.Duration != 0 {
			v := strconv.FormatInt(params.Duration, 10)
			err = writer.WriteField("duration", v)
			if err != nil {
				return
			}
		}

		if params.Performer != "" {
			err = writer.WriteField("performer", params.Performer)
			if err != nil {
				return
			}
		}

		if params.Title != "" {
			err = writer.WriteField("title", params.Title)
			if err != nil {
				return
			}
		}

		if params.Thumbnail != nil {
			if params.Thumbnail.File != nil {
				var w io.Writer
				params.Thumbnail.fieldName = "thumbnail"

				w, err = writer.CreateFormFile(
					params.Thumbnail.fieldName,
					params.Thumbnail.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Thumbnail.File)
				if err != nil {
					return
				}

				if closer, ok := params.Thumbnail.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Thumbnail)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("thumbnail")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.DisableNotification {
			v := strconv.FormatBool(params.DisableNotification)
			err = writer.WriteField("disable_notification", v)
			if err != nil {
				return
			}
		}

		if params.ProtectContent {
			v := strconv.FormatBool(params.ProtectContent)
			err = writer.WriteField("protect_content", v)
			if err != nil {
				return
			}
		}

		if params.AllowPaidBroadcast {
			v := strconv.FormatBool(params.AllowPaidBroadcast)
			err = writer.WriteField("allow_paid_broadcast", v)
			if err != nil {
				return
			}
		}

		if params.MessageEffectID != "" {
			err = writer.WriteField("message_effect_id", params.MessageEffectID)
			if err != nil {
				return
			}
		}

		if params.SuggestedPostParameters != nil {

			bs, err = json.Marshal(params.SuggestedPostParameters)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("suggested_post_parameters")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ReplyParameters != nil {

			bs, err = json.Marshal(params.ReplyParameters)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("reply_parameters")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ReplyMarkup != nil {

			bs, err = json.Marshal(params.ReplyMarkup)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("reply_markup")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

	}()

	contentType := writer.FormDataContentType()

	var result json.RawMessage

	result, err = c.Raw("sendAudio", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendChatActionParams contains parameters for Client.SendChatAction.
type SendChatActionParams struct {
	// Unique identifier of the business connection on behalf of which the action will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername).
	// Channel chats and channel direct messages chats aren't supported.
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread or topic of a forum; for supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Type of action to broadcast.
	// Choose one, depending on what the user is about to receive: typing for [text messages], upload_photo for [photos], record_video or upload_video for [videos], record_voice or upload_voice for [voice notes], upload_document for [general files], choose_sticker for [stickers], find_location for [location data], record_video_note or upload_video_note for [video notes].
	//
	// [text messages]: https://core.telegram.org/bots/api#sendmessage
	// [photos]: https://core.telegram.org/bots/api#sendphoto
	// [videos]: https://core.telegram.org/bots/api#sendvideo
	// [voice notes]: https://core.telegram.org/bots/api#sendvoice
	// [general files]: https://core.telegram.org/bots/api#senddocument
	// [stickers]: https://core.telegram.org/bots/api#sendsticker
	// [location data]: https://core.telegram.org/bots/api#sendlocation
	// [video notes]: https://core.telegram.org/bots/api#sendvideonote
	Action string `json:"action"`
}

// SendChatActionOption configures SendChatActionParams.
type SendChatActionOption func(params *SendChatActionParams) SendChatActionOption

// Option applies one or more SendChatActionOption values and returns the last rollback option.
func (r *SendChatActionParams) Option(opts ...SendChatActionOption) (previous SendChatActionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendChatActionBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the action will be sent
func WithSendChatActionBusinessConnectionID(value string) SendChatActionOption {
	return func(params *SendChatActionParams) SendChatActionOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendChatActionBusinessConnectionID(previous)
	}
}

// WithSendChatActionChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername).
// Channel chats and channel direct messages chats aren't supported.
func WithSendChatActionChatID(value string) SendChatActionOption {
	return func(params *SendChatActionParams) SendChatActionOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendChatActionChatID(previous)
	}
}

// WithSendChatActionMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread or topic of a forum; for supergroups and private chats of bots with forum topic mode enabled only
func WithSendChatActionMessageThreadID(value int64) SendChatActionOption {
	return func(params *SendChatActionParams) SendChatActionOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendChatActionMessageThreadID(previous)
	}
}

// WithSendChatActionAction sets the Action field.
//
// Type of action to broadcast.
// Choose one, depending on what the user is about to receive: typing for [text messages], upload_photo for [photos], record_video or upload_video for [videos], record_voice or upload_voice for [voice notes], upload_document for [general files], choose_sticker for [stickers], find_location for [location data], record_video_note or upload_video_note for [video notes].
//
// [text messages]: https://core.telegram.org/bots/api#sendmessage
// [photos]: https://core.telegram.org/bots/api#sendphoto
// [videos]: https://core.telegram.org/bots/api#sendvideo
// [voice notes]: https://core.telegram.org/bots/api#sendvoice
// [general files]: https://core.telegram.org/bots/api#senddocument
// [stickers]: https://core.telegram.org/bots/api#sendsticker
// [location data]: https://core.telegram.org/bots/api#sendlocation
// [video notes]: https://core.telegram.org/bots/api#sendvideonote
func WithSendChatActionAction(value string) SendChatActionOption {
	return func(params *SendChatActionParams) SendChatActionOption {
		previous := params.Action
		params.Action = value

		return WithSendChatActionAction(previous)
	}
}

// SendChatAction calls the sendChatAction Telegram Bot API method.
//
// Use this method when you need to tell the user that something is happening on the bot's side.
// The status is set for 5 seconds or less (when a message arrives from your bot, Telegram clients clear its typing status).
// Returns True on success.
// We only recommend using this method when a response from the bot will take a noticeable amount of time to arrive.
func (c *Client) SendChatAction(params *SendChatActionParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendChatAction", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendChecklistParams contains parameters for Client.SendChecklist.
type SendChecklistParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id"`

	// Unique identifier for the target chat
	ChatID int64 `json:"chat_id"`

	// A JSON-serialized object for the checklist to send
	Checklist InputChecklist `json:"checklist"`

	// Sends the message silently.
	// Users will receive a notification with no sound.
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Unique identifier of the message effect to be added to the message
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object for description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// A JSON-serialized object for an [inline keyboard]
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// SendChecklistOption configures SendChecklistParams.
type SendChecklistOption func(params *SendChecklistParams) SendChecklistOption

// Option applies one or more SendChecklistOption values and returns the last rollback option.
func (r *SendChecklistParams) Option(opts ...SendChecklistOption) (previous SendChecklistOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendChecklistBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendChecklistBusinessConnectionID(value string) SendChecklistOption {
	return func(params *SendChecklistParams) SendChecklistOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendChecklistBusinessConnectionID(previous)
	}
}

// WithSendChecklistChatID sets the ChatID field.
//
// Unique identifier for the target chat
func WithSendChecklistChatID(value int64) SendChecklistOption {
	return func(params *SendChecklistParams) SendChecklistOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendChecklistChatID(previous)
	}
}

// WithSendChecklistChecklist sets the Checklist field.
//
// A JSON-serialized object for the checklist to send
func WithSendChecklistChecklist(value InputChecklist) SendChecklistOption {
	return func(params *SendChecklistParams) SendChecklistOption {
		previous := params.Checklist
		params.Checklist = value

		return WithSendChecklistChecklist(previous)
	}
}

// WithSendChecklistDisableNotification sets the DisableNotification field.
//
// Sends the message silently.
// Users will receive a notification with no sound.
func WithSendChecklistDisableNotification(value bool) SendChecklistOption {
	return func(params *SendChecklistParams) SendChecklistOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendChecklistDisableNotification(previous)
	}
}

// WithSendChecklistProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendChecklistProtectContent(value bool) SendChecklistOption {
	return func(params *SendChecklistParams) SendChecklistOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendChecklistProtectContent(previous)
	}
}

// WithSendChecklistMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message
func WithSendChecklistMessageEffectID(value string) SendChecklistOption {
	return func(params *SendChecklistParams) SendChecklistOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendChecklistMessageEffectID(previous)
	}
}

// WithSendChecklistReplyParameters sets the ReplyParameters field.
//
// A JSON-serialized object for description of the message to reply to
func WithSendChecklistReplyParameters(value *ReplyParameters) SendChecklistOption {
	return func(params *SendChecklistParams) SendChecklistOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendChecklistReplyParameters(previous)
	}
}

// WithSendChecklistReplyMarkup sets the ReplyMarkup field.
//
// A JSON-serialized object for an [inline keyboard]
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
func WithSendChecklistReplyMarkup(value *InlineKeyboardMarkup) SendChecklistOption {
	return func(params *SendChecklistParams) SendChecklistOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendChecklistReplyMarkup(previous)
	}
}

// SendChecklist calls the sendChecklist Telegram Bot API method.
//
// Use this method to send a checklist on behalf of a connected business account.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendChecklist(params *SendChecklistParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendChecklist", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendContactParams contains parameters for Client.SendContact.
type SendContactParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Contact's phone number
	PhoneNumber string `json:"phone_number"`

	// Contact's first name
	FirstName string `json:"first_name"`

	// Contact's last name
	LastName string `json:"last_name,omitempty"`

	// Additional data about the contact in the form of a [vCard], 0-2048 bytes
	//
	// [vCard]: https://en.wikipedia.org/wiki/VCard
	Vcard string `json:"vcard,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendContactOption configures SendContactParams.
type SendContactOption func(params *SendContactParams) SendContactOption

// Option applies one or more SendContactOption values and returns the last rollback option.
func (r *SendContactParams) Option(opts ...SendContactOption) (previous SendContactOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendContactBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendContactBusinessConnectionID(value string) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendContactBusinessConnectionID(previous)
	}
}

// WithSendContactChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendContactChatID(value string) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendContactChatID(previous)
	}
}

// WithSendContactMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendContactMessageThreadID(value int64) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendContactMessageThreadID(previous)
	}
}

// WithSendContactDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendContactDirectMessagesTopicID(value int64) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendContactDirectMessagesTopicID(previous)
	}
}

// WithSendContactPhoneNumber sets the PhoneNumber field.
//
// Contact's phone number
func WithSendContactPhoneNumber(value string) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.PhoneNumber
		params.PhoneNumber = value

		return WithSendContactPhoneNumber(previous)
	}
}

// WithSendContactFirstName sets the FirstName field.
//
// Contact's first name
func WithSendContactFirstName(value string) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.FirstName
		params.FirstName = value

		return WithSendContactFirstName(previous)
	}
}

// WithSendContactLastName sets the LastName field.
//
// Contact's last name
func WithSendContactLastName(value string) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.LastName
		params.LastName = value

		return WithSendContactLastName(previous)
	}
}

// WithSendContactVcard sets the Vcard field.
//
// Additional data about the contact in the form of a [vCard], 0-2048 bytes
//
// [vCard]: https://en.wikipedia.org/wiki/VCard
func WithSendContactVcard(value string) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.Vcard
		params.Vcard = value

		return WithSendContactVcard(previous)
	}
}

// WithSendContactDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendContactDisableNotification(value bool) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendContactDisableNotification(previous)
	}
}

// WithSendContactProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendContactProtectContent(value bool) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendContactProtectContent(previous)
	}
}

// WithSendContactAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendContactAllowPaidBroadcast(value bool) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendContactAllowPaidBroadcast(previous)
	}
}

// WithSendContactMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendContactMessageEffectID(value string) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendContactMessageEffectID(previous)
	}
}

// WithSendContactSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendContactSuggestedPostParameters(value *SuggestedPostParameters) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendContactSuggestedPostParameters(previous)
	}
}

// WithSendContactReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendContactReplyParameters(value *ReplyParameters) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendContactReplyParameters(previous)
	}
}

// WithSendContactReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendContactReplyMarkup(value *ReplyMarkup) SendContactOption {
	return func(params *SendContactParams) SendContactOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendContactReplyMarkup(previous)
	}
}

// SendContact calls the sendContact Telegram Bot API method.
//
// Use this method to send phone contacts.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendContact(params *SendContactParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendContact", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendDiceParams contains parameters for Client.SendDice.
type SendDiceParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Emoji on which the dice throw animation is based.
	// Currently, must be one of “”, “”, “”, “”, “”, or “”.
	// Dice can have values 1-6 for “”, “” and “”, values 1-5 for “” and “”, and values 1-64 for “”.
	// Defaults to “”
	Emoji string `json:"emoji,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendDiceOption configures SendDiceParams.
type SendDiceOption func(params *SendDiceParams) SendDiceOption

// Option applies one or more SendDiceOption values and returns the last rollback option.
func (r *SendDiceParams) Option(opts ...SendDiceOption) (previous SendDiceOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendDiceBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendDiceBusinessConnectionID(value string) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendDiceBusinessConnectionID(previous)
	}
}

// WithSendDiceChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendDiceChatID(value string) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendDiceChatID(previous)
	}
}

// WithSendDiceMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendDiceMessageThreadID(value int64) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendDiceMessageThreadID(previous)
	}
}

// WithSendDiceDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendDiceDirectMessagesTopicID(value int64) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendDiceDirectMessagesTopicID(previous)
	}
}

// WithSendDiceEmoji sets the Emoji field.
//
// Emoji on which the dice throw animation is based.
// Currently, must be one of “”, “”, “”, “”, “”, or “”.
// Dice can have values 1-6 for “”, “” and “”, values 1-5 for “” and “”, and values 1-64 for “”.
// Defaults to “”
func WithSendDiceEmoji(value string) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.Emoji
		params.Emoji = value

		return WithSendDiceEmoji(previous)
	}
}

// WithSendDiceDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendDiceDisableNotification(value bool) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendDiceDisableNotification(previous)
	}
}

// WithSendDiceProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding
func WithSendDiceProtectContent(value bool) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendDiceProtectContent(previous)
	}
}

// WithSendDiceAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendDiceAllowPaidBroadcast(value bool) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendDiceAllowPaidBroadcast(previous)
	}
}

// WithSendDiceMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendDiceMessageEffectID(value string) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendDiceMessageEffectID(previous)
	}
}

// WithSendDiceSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendDiceSuggestedPostParameters(value *SuggestedPostParameters) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendDiceSuggestedPostParameters(previous)
	}
}

// WithSendDiceReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendDiceReplyParameters(value *ReplyParameters) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendDiceReplyParameters(previous)
	}
}

// WithSendDiceReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendDiceReplyMarkup(value *ReplyMarkup) SendDiceOption {
	return func(params *SendDiceParams) SendDiceOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendDiceReplyMarkup(previous)
	}
}

// SendDice calls the sendDice Telegram Bot API method.
//
// Use this method to send an animated emoji that will display a random value.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendDice(params *SendDiceParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendDice", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendDocumentParams contains parameters for Client.SendDocument.
type SendDocumentParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// File to send.
	// Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a file from the Internet, or upload a new one using multipart/form-data.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Document InputFile `json:"document"`

	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side.
	// The thumbnail should be in JPEG format and less than 200 kB in size.
	// A thumbnail's width and height should not exceed 320.
	// Ignored if the file is not uploaded using multipart/form-data.
	// Thumbnails can't be reused and can be only uploaded as a new file, so you can pass “attach://<file_attach_name>” if the thumbnail was uploaded using multipart/form-data under <file_attach_name>.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Thumbnail *InputFile `json:"thumbnail,omitempty"`

	// Document caption (may also be used when resending documents by file_id), 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Mode for parsing entities in the document caption.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Disables automatic server-side content type detection for files uploaded using multipart/form-data
	DisableContentTypeDetection bool `json:"disable_content_type_detection,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendDocumentOption configures SendDocumentParams.
type SendDocumentOption func(params *SendDocumentParams) SendDocumentOption

// Option applies one or more SendDocumentOption values and returns the last rollback option.
func (r *SendDocumentParams) Option(opts ...SendDocumentOption) (previous SendDocumentOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendDocumentBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendDocumentBusinessConnectionID(value string) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendDocumentBusinessConnectionID(previous)
	}
}

// WithSendDocumentChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendDocumentChatID(value string) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendDocumentChatID(previous)
	}
}

// WithSendDocumentMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendDocumentMessageThreadID(value int64) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendDocumentMessageThreadID(previous)
	}
}

// WithSendDocumentDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendDocumentDirectMessagesTopicID(value int64) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendDocumentDirectMessagesTopicID(previous)
	}
}

// WithSendDocumentDocument sets the Document field.
//
// File to send.
// Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a file from the Internet, or upload a new one using multipart/form-data.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendDocumentDocument(value InputFile) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.Document
		params.Document = value

		return WithSendDocumentDocument(previous)
	}
}

// WithSendDocumentThumbnail sets the Thumbnail field.
//
// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side.
// The thumbnail should be in JPEG format and less than 200 kB in size.
// A thumbnail's width and height should not exceed 320.
// Ignored if the file is not uploaded using multipart/form-data.
// Thumbnails can't be reused and can be only uploaded as a new file, so you can pass “attach://<file_attach_name>” if the thumbnail was uploaded using multipart/form-data under <file_attach_name>.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendDocumentThumbnail(value *InputFile) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.Thumbnail
		params.Thumbnail = value

		return WithSendDocumentThumbnail(previous)
	}
}

// WithSendDocumentCaption sets the Caption field.
//
// Document caption (may also be used when resending documents by file_id), 0-1024 characters after entities parsing
func WithSendDocumentCaption(value string) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.Caption
		params.Caption = value

		return WithSendDocumentCaption(previous)
	}
}

// WithSendDocumentParseMode sets the ParseMode field.
//
// Mode for parsing entities in the document caption.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendDocumentParseMode(value string) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithSendDocumentParseMode(previous)
	}
}

// WithSendDocumentCaptionEntities sets the CaptionEntities field.
//
// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
func WithSendDocumentCaptionEntities(value []MessageEntity) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.CaptionEntities
		params.CaptionEntities = value

		return WithSendDocumentCaptionEntities(previous)
	}
}

// WithSendDocumentDisableContentTypeDetection sets the DisableContentTypeDetection field.
//
// Disables automatic server-side content type detection for files uploaded using multipart/form-data
func WithSendDocumentDisableContentTypeDetection(value bool) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.DisableContentTypeDetection
		params.DisableContentTypeDetection = value

		return WithSendDocumentDisableContentTypeDetection(previous)
	}
}

// WithSendDocumentDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendDocumentDisableNotification(value bool) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendDocumentDisableNotification(previous)
	}
}

// WithSendDocumentProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendDocumentProtectContent(value bool) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendDocumentProtectContent(previous)
	}
}

// WithSendDocumentAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendDocumentAllowPaidBroadcast(value bool) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendDocumentAllowPaidBroadcast(previous)
	}
}

// WithSendDocumentMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendDocumentMessageEffectID(value string) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendDocumentMessageEffectID(previous)
	}
}

// WithSendDocumentSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendDocumentSuggestedPostParameters(value *SuggestedPostParameters) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendDocumentSuggestedPostParameters(previous)
	}
}

// WithSendDocumentReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendDocumentReplyParameters(value *ReplyParameters) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendDocumentReplyParameters(previous)
	}
}

// WithSendDocumentReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendDocumentReplyMarkup(value *ReplyMarkup) SendDocumentOption {
	return func(params *SendDocumentParams) SendDocumentOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendDocumentReplyMarkup(previous)
	}
}

// SendDocument calls the sendDocument Telegram Bot API method.
//
// Use this method to send general files.
// On success, the sent [Message] is returned.
// Bots can currently send files of any type of up to 50 MB in size, this limit may be changed in the future.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendDocument(params *SendDocumentParams) (ret *Message, err error) {
	var bs []byte

	reader, pw := io.Pipe()
	writer := multipart.NewWriter(pw)

	go func() {
		defer pw.Close()
		defer writer.Close()

		if params.BusinessConnectionID != "" {
			err = writer.WriteField("business_connection_id", params.BusinessConnectionID)
			if err != nil {
				return
			}
		}

		{
			err = writer.WriteField("chat_id", params.ChatID)
			if err != nil {
				return
			}
		}

		if params.MessageThreadID != 0 {
			v := strconv.FormatInt(params.MessageThreadID, 10)
			err = writer.WriteField("message_thread_id", v)
			if err != nil {
				return
			}
		}

		if params.DirectMessagesTopicID != 0 {
			v := strconv.FormatInt(params.DirectMessagesTopicID, 10)
			err = writer.WriteField("direct_messages_topic_id", v)
			if err != nil {
				return
			}
		}

		{
			if params.Document.File != nil {
				var w io.Writer
				params.Document.fieldName = "document"

				w, err = writer.CreateFormFile(
					params.Document.fieldName,
					params.Document.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Document.File)
				if err != nil {
					return
				}

				if closer, ok := params.Document.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Document)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("document")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.Thumbnail != nil {
			if params.Thumbnail.File != nil {
				var w io.Writer
				params.Thumbnail.fieldName = "thumbnail"

				w, err = writer.CreateFormFile(
					params.Thumbnail.fieldName,
					params.Thumbnail.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Thumbnail.File)
				if err != nil {
					return
				}

				if closer, ok := params.Thumbnail.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Thumbnail)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("thumbnail")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.Caption != "" {
			err = writer.WriteField("caption", params.Caption)
			if err != nil {
				return
			}
		}

		if params.ParseMode != "" {
			err = writer.WriteField("parse_mode", params.ParseMode)
			if err != nil {
				return
			}
		}

		if params.CaptionEntities != nil {

			bs, err = json.Marshal(params.CaptionEntities)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("caption_entities")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.DisableContentTypeDetection {
			v := strconv.FormatBool(params.DisableContentTypeDetection)
			err = writer.WriteField("disable_content_type_detection", v)
			if err != nil {
				return
			}
		}

		if params.DisableNotification {
			v := strconv.FormatBool(params.DisableNotification)
			err = writer.WriteField("disable_notification", v)
			if err != nil {
				return
			}
		}

		if params.ProtectContent {
			v := strconv.FormatBool(params.ProtectContent)
			err = writer.WriteField("protect_content", v)
			if err != nil {
				return
			}
		}

		if params.AllowPaidBroadcast {
			v := strconv.FormatBool(params.AllowPaidBroadcast)
			err = writer.WriteField("allow_paid_broadcast", v)
			if err != nil {
				return
			}
		}

		if params.MessageEffectID != "" {
			err = writer.WriteField("message_effect_id", params.MessageEffectID)
			if err != nil {
				return
			}
		}

		if params.SuggestedPostParameters != nil {

			bs, err = json.Marshal(params.SuggestedPostParameters)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("suggested_post_parameters")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ReplyParameters != nil {

			bs, err = json.Marshal(params.ReplyParameters)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("reply_parameters")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ReplyMarkup != nil {

			bs, err = json.Marshal(params.ReplyMarkup)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("reply_markup")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

	}()

	contentType := writer.FormDataContentType()

	var result json.RawMessage

	result, err = c.Raw("sendDocument", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendGameParams contains parameters for Client.SendGame.
type SendGameParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat.
	// Games can't be sent to channel direct messages chats and channel chats.
	ChatID int64 `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Short name of the game, serves as the unique identifier for the game.
	// Set up your games via [@BotFather].
	//
	// [@BotFather]: https://t.me/botfather
	GameShortName string `json:"game_short_name"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// A JSON-serialized object for an [inline keyboard].
	// If empty, one 'Play game_title' button will be shown.
	// If not empty, the first button must launch the game.
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// SendGameOption configures SendGameParams.
type SendGameOption func(params *SendGameParams) SendGameOption

// Option applies one or more SendGameOption values and returns the last rollback option.
func (r *SendGameParams) Option(opts ...SendGameOption) (previous SendGameOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendGameBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendGameBusinessConnectionID(value string) SendGameOption {
	return func(params *SendGameParams) SendGameOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendGameBusinessConnectionID(previous)
	}
}

// WithSendGameChatID sets the ChatID field.
//
// Unique identifier for the target chat.
// Games can't be sent to channel direct messages chats and channel chats.
func WithSendGameChatID(value int64) SendGameOption {
	return func(params *SendGameParams) SendGameOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendGameChatID(previous)
	}
}

// WithSendGameMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendGameMessageThreadID(value int64) SendGameOption {
	return func(params *SendGameParams) SendGameOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendGameMessageThreadID(previous)
	}
}

// WithSendGameGameShortName sets the GameShortName field.
//
// Short name of the game, serves as the unique identifier for the game.
// Set up your games via [@BotFather].
//
// [@BotFather]: https://t.me/botfather
func WithSendGameGameShortName(value string) SendGameOption {
	return func(params *SendGameParams) SendGameOption {
		previous := params.GameShortName
		params.GameShortName = value

		return WithSendGameGameShortName(previous)
	}
}

// WithSendGameDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendGameDisableNotification(value bool) SendGameOption {
	return func(params *SendGameParams) SendGameOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendGameDisableNotification(previous)
	}
}

// WithSendGameProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendGameProtectContent(value bool) SendGameOption {
	return func(params *SendGameParams) SendGameOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendGameProtectContent(previous)
	}
}

// WithSendGameAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendGameAllowPaidBroadcast(value bool) SendGameOption {
	return func(params *SendGameParams) SendGameOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendGameAllowPaidBroadcast(previous)
	}
}

// WithSendGameMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendGameMessageEffectID(value string) SendGameOption {
	return func(params *SendGameParams) SendGameOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendGameMessageEffectID(previous)
	}
}

// WithSendGameReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendGameReplyParameters(value *ReplyParameters) SendGameOption {
	return func(params *SendGameParams) SendGameOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendGameReplyParameters(previous)
	}
}

// WithSendGameReplyMarkup sets the ReplyMarkup field.
//
// A JSON-serialized object for an [inline keyboard].
// If empty, one 'Play game_title' button will be shown.
// If not empty, the first button must launch the game.
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
func WithSendGameReplyMarkup(value *InlineKeyboardMarkup) SendGameOption {
	return func(params *SendGameParams) SendGameOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendGameReplyMarkup(previous)
	}
}

// SendGame calls the sendGame Telegram Bot API method.
//
// Use this method to send a game.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendGame(params *SendGameParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendGame", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendGiftParams contains parameters for Client.SendGift.
type SendGiftParams struct {
	// Required if chat_id is not specified.
	// Unique identifier of the target user who will receive the gift.
	UserID int64 `json:"user_id,omitempty"`

	// Required if user_id is not specified.
	// Unique identifier for the chat or username of the channel (in the format @channelusername) that will receive the gift.
	ChatID string `json:"chat_id,omitempty"`

	// Identifier of the gift; limited gifts can't be sent to channel chats
	GiftID string `json:"gift_id"`

	// Pass True to pay for the gift upgrade from the bot's balance, thereby making the upgrade free for the receiver
	PayForUpgrade bool `json:"pay_for_upgrade,omitempty"`

	// Text that will be shown along with the gift; 0-128 characters
	Text string `json:"text,omitempty"`

	// Mode for parsing entities in the text.
	// See [formatting options] for more details.
	// Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom_emoji” are ignored.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	TextParseMode string `json:"text_parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the gift text.
	// It can be specified instead of text_parse_mode.
	// Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom_emoji” are ignored.
	TextEntities []MessageEntity `json:"text_entities,omitempty"`
}

// SendGiftOption configures SendGiftParams.
type SendGiftOption func(params *SendGiftParams) SendGiftOption

// Option applies one or more SendGiftOption values and returns the last rollback option.
func (r *SendGiftParams) Option(opts ...SendGiftOption) (previous SendGiftOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendGiftUserID sets the UserID field.
//
// Required if chat_id is not specified.
// Unique identifier of the target user who will receive the gift.
func WithSendGiftUserID(value int64) SendGiftOption {
	return func(params *SendGiftParams) SendGiftOption {
		previous := params.UserID
		params.UserID = value

		return WithSendGiftUserID(previous)
	}
}

// WithSendGiftChatID sets the ChatID field.
//
// Required if user_id is not specified.
// Unique identifier for the chat or username of the channel (in the format @channelusername) that will receive the gift.
func WithSendGiftChatID(value string) SendGiftOption {
	return func(params *SendGiftParams) SendGiftOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendGiftChatID(previous)
	}
}

// WithSendGiftGiftID sets the GiftID field.
//
// Identifier of the gift; limited gifts can't be sent to channel chats
func WithSendGiftGiftID(value string) SendGiftOption {
	return func(params *SendGiftParams) SendGiftOption {
		previous := params.GiftID
		params.GiftID = value

		return WithSendGiftGiftID(previous)
	}
}

// WithSendGiftPayForUpgrade sets the PayForUpgrade field.
//
// Pass True to pay for the gift upgrade from the bot's balance, thereby making the upgrade free for the receiver
func WithSendGiftPayForUpgrade(value bool) SendGiftOption {
	return func(params *SendGiftParams) SendGiftOption {
		previous := params.PayForUpgrade
		params.PayForUpgrade = value

		return WithSendGiftPayForUpgrade(previous)
	}
}

// WithSendGiftText sets the Text field.
//
// Text that will be shown along with the gift; 0-128 characters
func WithSendGiftText(value string) SendGiftOption {
	return func(params *SendGiftParams) SendGiftOption {
		previous := params.Text
		params.Text = value

		return WithSendGiftText(previous)
	}
}

// WithSendGiftTextParseMode sets the TextParseMode field.
//
// Mode for parsing entities in the text.
// See [formatting options] for more details.
// Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom_emoji” are ignored.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendGiftTextParseMode(value string) SendGiftOption {
	return func(params *SendGiftParams) SendGiftOption {
		previous := params.TextParseMode
		params.TextParseMode = value

		return WithSendGiftTextParseMode(previous)
	}
}

// WithSendGiftTextEntities sets the TextEntities field.
//
// A JSON-serialized list of special entities that appear in the gift text.
// It can be specified instead of text_parse_mode.
// Entities other than “bold”, “italic”, “underline”, “strikethrough”, “spoiler”, and “custom_emoji” are ignored.
func WithSendGiftTextEntities(value []MessageEntity) SendGiftOption {
	return func(params *SendGiftParams) SendGiftOption {
		previous := params.TextEntities
		params.TextEntities = value

		return WithSendGiftTextEntities(previous)
	}
}

// SendGift calls the sendGift Telegram Bot API method.
//
// Sends a gift to the given user or channel chat.
// The gift can't be converted to Telegram Stars by the receiver.
// Returns True on success.
func (c *Client) SendGift(params *SendGiftParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendGift", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendInvoiceParams contains parameters for Client.SendInvoice.
type SendInvoiceParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Product name, 1-32 characters
	Title string `json:"title"`

	// Product description, 1-255 characters
	Description string `json:"description"`

	// Bot-defined invoice payload, 1-128 bytes.
	// This will not be displayed to the user, use it for your internal processes.
	Payload string `json:"payload"`

	// Payment provider token, obtained via [@BotFather].
	// Pass an empty string for payments in [Telegram Stars].
	//
	// [@BotFather]: https://t.me/botfather
	// [Telegram Stars]: https://t.me/BotNews/90
	ProviderToken string `json:"provider_token,omitempty"`

	// Three-letter ISO 4217 currency code, see [more on currencies].
	// Pass “XTR” for payments in [Telegram Stars].
	//
	// [more on currencies]: https://core.telegram.org/bots/payments#supported-currencies
	// [Telegram Stars]: https://t.me/BotNews/90
	Currency string `json:"currency"`

	// Price breakdown, a JSON-serialized list of components (e.g.
	// product price, tax, discount, delivery cost, delivery tax, bonus, etc.).
	// Must contain exactly one item for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	Prices []LabeledPrice `json:"prices"`

	// The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double).
	// For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145.
	// See the exp parameter in [currencies.json], it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).
	// Defaults to 0.
	// Not supported for payments in [Telegram Stars].
	//
	// [currencies.json]: https://core.telegram.org/bots/payments/currencies.json
	// [Telegram Stars]: https://t.me/BotNews/90
	MaxTipAmount int64 `json:"max_tip_amount,omitempty"`

	// A JSON-serialized array of suggested amounts of tips in the smallest units of the currency (integer, not float/double).
	// At most 4 suggested tip amounts can be specified.
	// The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount.
	SuggestedTipAmounts []int64 `json:"suggested_tip_amounts,omitempty"`

	// Unique deep-linking parameter.
	// If left empty, forwarded copies of the sent message will have a Pay button, allowing multiple users to pay directly from the forwarded message, using the same invoice.
	// If non-empty, forwarded copies of the sent message will have a URL button with a deep link to the bot (instead of a Pay button), with the value used as the start parameter
	StartParameter string `json:"start_parameter,omitempty"`

	// JSON-serialized data about the invoice, which will be shared with the payment provider.
	// A detailed description of required fields should be provided by the payment provider.
	ProviderData string `json:"provider_data,omitempty"`

	// URL of the product photo for the invoice.
	// Can be a photo of the goods or a marketing image for a service.
	// People like it better when they see what they are paying for.
	PhotoUrl string `json:"photo_url,omitempty"`

	// Photo size in bytes
	PhotoSize int64 `json:"photo_size,omitempty"`

	// Photo width
	PhotoWidth int64 `json:"photo_width,omitempty"`

	// Photo height
	PhotoHeight int64 `json:"photo_height,omitempty"`

	// Pass True if you require the user's full name to complete the order.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	NeedName bool `json:"need_name,omitempty"`

	// Pass True if you require the user's phone number to complete the order.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	NeedPhoneNumber bool `json:"need_phone_number,omitempty"`

	// Pass True if you require the user's email address to complete the order.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	NeedEmail bool `json:"need_email,omitempty"`

	// Pass True if you require the user's shipping address to complete the order.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	NeedShippingAddress bool `json:"need_shipping_address,omitempty"`

	// Pass True if the user's phone number should be sent to the provider.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	SendPhoneNumberToProvider bool `json:"send_phone_number_to_provider,omitempty"`

	// Pass True if the user's email address should be sent to the provider.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	SendEmailToProvider bool `json:"send_email_to_provider,omitempty"`

	// Pass True if the final price depends on the shipping method.
	// Ignored for payments in [Telegram Stars].
	//
	// [Telegram Stars]: https://t.me/BotNews/90
	IsFlexible bool `json:"is_flexible,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// A JSON-serialized object for an [inline keyboard].
	// If empty, one 'Pay total price' button will be shown.
	// If not empty, the first button must be a Pay button.
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// SendInvoiceOption configures SendInvoiceParams.
type SendInvoiceOption func(params *SendInvoiceParams) SendInvoiceOption

// Option applies one or more SendInvoiceOption values and returns the last rollback option.
func (r *SendInvoiceParams) Option(opts ...SendInvoiceOption) (previous SendInvoiceOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendInvoiceChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendInvoiceChatID(value string) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendInvoiceChatID(previous)
	}
}

// WithSendInvoiceMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendInvoiceMessageThreadID(value int64) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendInvoiceMessageThreadID(previous)
	}
}

// WithSendInvoiceDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendInvoiceDirectMessagesTopicID(value int64) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendInvoiceDirectMessagesTopicID(previous)
	}
}

// WithSendInvoiceTitle sets the Title field.
//
// Product name, 1-32 characters
func WithSendInvoiceTitle(value string) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.Title
		params.Title = value

		return WithSendInvoiceTitle(previous)
	}
}

// WithSendInvoiceDescription sets the Description field.
//
// Product description, 1-255 characters
func WithSendInvoiceDescription(value string) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.Description
		params.Description = value

		return WithSendInvoiceDescription(previous)
	}
}

// WithSendInvoicePayload sets the Payload field.
//
// Bot-defined invoice payload, 1-128 bytes.
// This will not be displayed to the user, use it for your internal processes.
func WithSendInvoicePayload(value string) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.Payload
		params.Payload = value

		return WithSendInvoicePayload(previous)
	}
}

// WithSendInvoiceProviderToken sets the ProviderToken field.
//
// Payment provider token, obtained via [@BotFather].
// Pass an empty string for payments in [Telegram Stars].
//
// [@BotFather]: https://t.me/botfather
// [Telegram Stars]: https://t.me/BotNews/90
func WithSendInvoiceProviderToken(value string) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.ProviderToken
		params.ProviderToken = value

		return WithSendInvoiceProviderToken(previous)
	}
}

// WithSendInvoiceCurrency sets the Currency field.
//
// Three-letter ISO 4217 currency code, see [more on currencies].
// Pass “XTR” for payments in [Telegram Stars].
//
// [more on currencies]: https://core.telegram.org/bots/payments#supported-currencies
// [Telegram Stars]: https://t.me/BotNews/90
func WithSendInvoiceCurrency(value string) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.Currency
		params.Currency = value

		return WithSendInvoiceCurrency(previous)
	}
}

// WithSendInvoicePrices sets the Prices field.
//
// Price breakdown, a JSON-serialized list of components (e.g.
// product price, tax, discount, delivery cost, delivery tax, bonus, etc.).
// Must contain exactly one item for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithSendInvoicePrices(value []LabeledPrice) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.Prices
		params.Prices = value

		return WithSendInvoicePrices(previous)
	}
}

// WithSendInvoiceMaxTipAmount sets the MaxTipAmount field.
//
// The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double).
// For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145.
// See the exp parameter in [currencies.json], it shows the number of digits past the decimal point for each currency (2 for the majority of currencies).
// Defaults to 0.
// Not supported for payments in [Telegram Stars].
//
// [currencies.json]: https://core.telegram.org/bots/payments/currencies.json
// [Telegram Stars]: https://t.me/BotNews/90
func WithSendInvoiceMaxTipAmount(value int64) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.MaxTipAmount
		params.MaxTipAmount = value

		return WithSendInvoiceMaxTipAmount(previous)
	}
}

// WithSendInvoiceSuggestedTipAmounts sets the SuggestedTipAmounts field.
//
// A JSON-serialized array of suggested amounts of tips in the smallest units of the currency (integer, not float/double).
// At most 4 suggested tip amounts can be specified.
// The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount.
func WithSendInvoiceSuggestedTipAmounts(value []int64) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.SuggestedTipAmounts
		params.SuggestedTipAmounts = value

		return WithSendInvoiceSuggestedTipAmounts(previous)
	}
}

// WithSendInvoiceStartParameter sets the StartParameter field.
//
// Unique deep-linking parameter.
// If left empty, forwarded copies of the sent message will have a Pay button, allowing multiple users to pay directly from the forwarded message, using the same invoice.
// If non-empty, forwarded copies of the sent message will have a URL button with a deep link to the bot (instead of a Pay button), with the value used as the start parameter
func WithSendInvoiceStartParameter(value string) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.StartParameter
		params.StartParameter = value

		return WithSendInvoiceStartParameter(previous)
	}
}

// WithSendInvoiceProviderData sets the ProviderData field.
//
// JSON-serialized data about the invoice, which will be shared with the payment provider.
// A detailed description of required fields should be provided by the payment provider.
func WithSendInvoiceProviderData(value string) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.ProviderData
		params.ProviderData = value

		return WithSendInvoiceProviderData(previous)
	}
}

// WithSendInvoicePhotoUrl sets the PhotoUrl field.
//
// URL of the product photo for the invoice.
// Can be a photo of the goods or a marketing image for a service.
// People like it better when they see what they are paying for.
func WithSendInvoicePhotoUrl(value string) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.PhotoUrl
		params.PhotoUrl = value

		return WithSendInvoicePhotoUrl(previous)
	}
}

// WithSendInvoicePhotoSize sets the PhotoSize field.
//
// Photo size in bytes
func WithSendInvoicePhotoSize(value int64) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.PhotoSize
		params.PhotoSize = value

		return WithSendInvoicePhotoSize(previous)
	}
}

// WithSendInvoicePhotoWidth sets the PhotoWidth field.
//
// Photo width
func WithSendInvoicePhotoWidth(value int64) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.PhotoWidth
		params.PhotoWidth = value

		return WithSendInvoicePhotoWidth(previous)
	}
}

// WithSendInvoicePhotoHeight sets the PhotoHeight field.
//
// Photo height
func WithSendInvoicePhotoHeight(value int64) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.PhotoHeight
		params.PhotoHeight = value

		return WithSendInvoicePhotoHeight(previous)
	}
}

// WithSendInvoiceNeedName sets the NeedName field.
//
// Pass True if you require the user's full name to complete the order.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithSendInvoiceNeedName(value bool) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.NeedName
		params.NeedName = value

		return WithSendInvoiceNeedName(previous)
	}
}

// WithSendInvoiceNeedPhoneNumber sets the NeedPhoneNumber field.
//
// Pass True if you require the user's phone number to complete the order.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithSendInvoiceNeedPhoneNumber(value bool) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.NeedPhoneNumber
		params.NeedPhoneNumber = value

		return WithSendInvoiceNeedPhoneNumber(previous)
	}
}

// WithSendInvoiceNeedEmail sets the NeedEmail field.
//
// Pass True if you require the user's email address to complete the order.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithSendInvoiceNeedEmail(value bool) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.NeedEmail
		params.NeedEmail = value

		return WithSendInvoiceNeedEmail(previous)
	}
}

// WithSendInvoiceNeedShippingAddress sets the NeedShippingAddress field.
//
// Pass True if you require the user's shipping address to complete the order.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithSendInvoiceNeedShippingAddress(value bool) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.NeedShippingAddress
		params.NeedShippingAddress = value

		return WithSendInvoiceNeedShippingAddress(previous)
	}
}

// WithSendInvoiceSendPhoneNumberToProvider sets the SendPhoneNumberToProvider field.
//
// Pass True if the user's phone number should be sent to the provider.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithSendInvoiceSendPhoneNumberToProvider(value bool) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.SendPhoneNumberToProvider
		params.SendPhoneNumberToProvider = value

		return WithSendInvoiceSendPhoneNumberToProvider(previous)
	}
}

// WithSendInvoiceSendEmailToProvider sets the SendEmailToProvider field.
//
// Pass True if the user's email address should be sent to the provider.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithSendInvoiceSendEmailToProvider(value bool) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.SendEmailToProvider
		params.SendEmailToProvider = value

		return WithSendInvoiceSendEmailToProvider(previous)
	}
}

// WithSendInvoiceIsFlexible sets the IsFlexible field.
//
// Pass True if the final price depends on the shipping method.
// Ignored for payments in [Telegram Stars].
//
// [Telegram Stars]: https://t.me/BotNews/90
func WithSendInvoiceIsFlexible(value bool) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.IsFlexible
		params.IsFlexible = value

		return WithSendInvoiceIsFlexible(previous)
	}
}

// WithSendInvoiceDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendInvoiceDisableNotification(value bool) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendInvoiceDisableNotification(previous)
	}
}

// WithSendInvoiceProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendInvoiceProtectContent(value bool) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendInvoiceProtectContent(previous)
	}
}

// WithSendInvoiceAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendInvoiceAllowPaidBroadcast(value bool) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendInvoiceAllowPaidBroadcast(previous)
	}
}

// WithSendInvoiceMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendInvoiceMessageEffectID(value string) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendInvoiceMessageEffectID(previous)
	}
}

// WithSendInvoiceSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendInvoiceSuggestedPostParameters(value *SuggestedPostParameters) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendInvoiceSuggestedPostParameters(previous)
	}
}

// WithSendInvoiceReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendInvoiceReplyParameters(value *ReplyParameters) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendInvoiceReplyParameters(previous)
	}
}

// WithSendInvoiceReplyMarkup sets the ReplyMarkup field.
//
// A JSON-serialized object for an [inline keyboard].
// If empty, one 'Pay total price' button will be shown.
// If not empty, the first button must be a Pay button.
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
func WithSendInvoiceReplyMarkup(value *InlineKeyboardMarkup) SendInvoiceOption {
	return func(params *SendInvoiceParams) SendInvoiceOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendInvoiceReplyMarkup(previous)
	}
}

// SendInvoice calls the sendInvoice Telegram Bot API method.
//
// Use this method to send invoices.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendInvoice(params *SendInvoiceParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendInvoice", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendLocationParams contains parameters for Client.SendLocation.
type SendLocationParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Latitude of the location
	Latitude float64 `json:"latitude"`

	// Longitude of the location
	Longitude float64 `json:"longitude"`

	// The radius of uncertainty for the location, measured in meters; 0-1500
	HorizontalAccuracy float64 `json:"horizontal_accuracy,omitempty"`

	// Period in seconds during which the location will be updated (see [Live Locations], should be between 60 and 86400, or 0x7FFFFFFF for live locations that can be edited indefinitely.
	//
	// [Live Locations]: https://telegram.org/blog/live-locations
	LivePeriod int64 `json:"live_period,omitempty"`

	// For live locations, a direction in which the user is moving, in degrees.
	// Must be between 1 and 360 if specified.
	Heading int64 `json:"heading,omitempty"`

	// For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters.
	// Must be between 1 and 100000 if specified.
	ProximityAlertRadius int64 `json:"proximity_alert_radius,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendLocationOption configures SendLocationParams.
type SendLocationOption func(params *SendLocationParams) SendLocationOption

// Option applies one or more SendLocationOption values and returns the last rollback option.
func (r *SendLocationParams) Option(opts ...SendLocationOption) (previous SendLocationOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendLocationBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendLocationBusinessConnectionID(value string) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendLocationBusinessConnectionID(previous)
	}
}

// WithSendLocationChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendLocationChatID(value string) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendLocationChatID(previous)
	}
}

// WithSendLocationMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendLocationMessageThreadID(value int64) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendLocationMessageThreadID(previous)
	}
}

// WithSendLocationDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendLocationDirectMessagesTopicID(value int64) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendLocationDirectMessagesTopicID(previous)
	}
}

// WithSendLocationLatitude sets the Latitude field.
//
// Latitude of the location
func WithSendLocationLatitude(value float64) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.Latitude
		params.Latitude = value

		return WithSendLocationLatitude(previous)
	}
}

// WithSendLocationLongitude sets the Longitude field.
//
// Longitude of the location
func WithSendLocationLongitude(value float64) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.Longitude
		params.Longitude = value

		return WithSendLocationLongitude(previous)
	}
}

// WithSendLocationHorizontalAccuracy sets the HorizontalAccuracy field.
//
// The radius of uncertainty for the location, measured in meters; 0-1500
func WithSendLocationHorizontalAccuracy(value float64) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.HorizontalAccuracy
		params.HorizontalAccuracy = value

		return WithSendLocationHorizontalAccuracy(previous)
	}
}

// WithSendLocationLivePeriod sets the LivePeriod field.
//
// Period in seconds during which the location will be updated (see [Live Locations], should be between 60 and 86400, or 0x7FFFFFFF for live locations that can be edited indefinitely.
//
// [Live Locations]: https://telegram.org/blog/live-locations
func WithSendLocationLivePeriod(value int64) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.LivePeriod
		params.LivePeriod = value

		return WithSendLocationLivePeriod(previous)
	}
}

// WithSendLocationHeading sets the Heading field.
//
// For live locations, a direction in which the user is moving, in degrees.
// Must be between 1 and 360 if specified.
func WithSendLocationHeading(value int64) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.Heading
		params.Heading = value

		return WithSendLocationHeading(previous)
	}
}

// WithSendLocationProximityAlertRadius sets the ProximityAlertRadius field.
//
// For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters.
// Must be between 1 and 100000 if specified.
func WithSendLocationProximityAlertRadius(value int64) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.ProximityAlertRadius
		params.ProximityAlertRadius = value

		return WithSendLocationProximityAlertRadius(previous)
	}
}

// WithSendLocationDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendLocationDisableNotification(value bool) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendLocationDisableNotification(previous)
	}
}

// WithSendLocationProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendLocationProtectContent(value bool) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendLocationProtectContent(previous)
	}
}

// WithSendLocationAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendLocationAllowPaidBroadcast(value bool) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendLocationAllowPaidBroadcast(previous)
	}
}

// WithSendLocationMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendLocationMessageEffectID(value string) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendLocationMessageEffectID(previous)
	}
}

// WithSendLocationSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendLocationSuggestedPostParameters(value *SuggestedPostParameters) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendLocationSuggestedPostParameters(previous)
	}
}

// WithSendLocationReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendLocationReplyParameters(value *ReplyParameters) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendLocationReplyParameters(previous)
	}
}

// WithSendLocationReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendLocationReplyMarkup(value *ReplyMarkup) SendLocationOption {
	return func(params *SendLocationParams) SendLocationOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendLocationReplyMarkup(previous)
	}
}

// SendLocation calls the sendLocation Telegram Bot API method.
//
// Use this method to send point on the map.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendLocation(params *SendLocationParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendLocation", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendMediaGroupParams contains parameters for Client.SendMediaGroup.
type SendMediaGroupParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the messages will be sent; required if the messages are sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// A JSON-serialized array describing messages to be sent, must include 2-10 items
	Media []InputMedia `json:"media"`

	// Sends messages [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent messages from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`
}

// SendMediaGroupOption configures SendMediaGroupParams.
type SendMediaGroupOption func(params *SendMediaGroupParams) SendMediaGroupOption

// Option applies one or more SendMediaGroupOption values and returns the last rollback option.
func (r *SendMediaGroupParams) Option(opts ...SendMediaGroupOption) (previous SendMediaGroupOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendMediaGroupBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendMediaGroupBusinessConnectionID(value string) SendMediaGroupOption {
	return func(params *SendMediaGroupParams) SendMediaGroupOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendMediaGroupBusinessConnectionID(previous)
	}
}

// WithSendMediaGroupChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendMediaGroupChatID(value string) SendMediaGroupOption {
	return func(params *SendMediaGroupParams) SendMediaGroupOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendMediaGroupChatID(previous)
	}
}

// WithSendMediaGroupMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendMediaGroupMessageThreadID(value int64) SendMediaGroupOption {
	return func(params *SendMediaGroupParams) SendMediaGroupOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendMediaGroupMessageThreadID(previous)
	}
}

// WithSendMediaGroupDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the messages will be sent; required if the messages are sent to a direct messages chat
func WithSendMediaGroupDirectMessagesTopicID(value int64) SendMediaGroupOption {
	return func(params *SendMediaGroupParams) SendMediaGroupOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendMediaGroupDirectMessagesTopicID(previous)
	}
}

// WithSendMediaGroupMedia sets the Media field.
//
// A JSON-serialized array describing messages to be sent, must include 2-10 items
func WithSendMediaGroupMedia(value []InputMedia) SendMediaGroupOption {
	return func(params *SendMediaGroupParams) SendMediaGroupOption {
		previous := params.Media
		params.Media = value

		return WithSendMediaGroupMedia(previous)
	}
}

// WithSendMediaGroupDisableNotification sets the DisableNotification field.
//
// Sends messages [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendMediaGroupDisableNotification(value bool) SendMediaGroupOption {
	return func(params *SendMediaGroupParams) SendMediaGroupOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendMediaGroupDisableNotification(previous)
	}
}

// WithSendMediaGroupProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent messages from forwarding and saving
func WithSendMediaGroupProtectContent(value bool) SendMediaGroupOption {
	return func(params *SendMediaGroupParams) SendMediaGroupOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendMediaGroupProtectContent(previous)
	}
}

// WithSendMediaGroupAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendMediaGroupAllowPaidBroadcast(value bool) SendMediaGroupOption {
	return func(params *SendMediaGroupParams) SendMediaGroupOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendMediaGroupAllowPaidBroadcast(previous)
	}
}

// WithSendMediaGroupMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendMediaGroupMessageEffectID(value string) SendMediaGroupOption {
	return func(params *SendMediaGroupParams) SendMediaGroupOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendMediaGroupMessageEffectID(previous)
	}
}

// WithSendMediaGroupReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendMediaGroupReplyParameters(value *ReplyParameters) SendMediaGroupOption {
	return func(params *SendMediaGroupParams) SendMediaGroupOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendMediaGroupReplyParameters(previous)
	}
}

// SendMediaGroup calls the sendMediaGroup Telegram Bot API method.
//
// Use this method to send a group of photos, videos, documents or audios as an album.
// Documents and audio files can be only grouped in an album with messages of the same type.
// On success, an array of [Message] objects that were sent is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendMediaGroup(params *SendMediaGroupParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendMediaGroup", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendMessageParams contains parameters for Client.SendMessage.
type SendMessageParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Text of the message to be sent, 1-4096 characters after entities parsing
	Text string `json:"text"`

	// Mode for parsing entities in the message text.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in message text, which can be specified instead of parse_mode
	Entities []MessageEntity `json:"entities,omitempty"`

	// Link preview generation options for the message
	LinkPreviewOptions *LinkPreviewOptions `json:"link_preview_options,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendMessageOption configures SendMessageParams.
type SendMessageOption func(params *SendMessageParams) SendMessageOption

// Option applies one or more SendMessageOption values and returns the last rollback option.
func (r *SendMessageParams) Option(opts ...SendMessageOption) (previous SendMessageOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendMessageBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendMessageBusinessConnectionID(value string) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendMessageBusinessConnectionID(previous)
	}
}

// WithSendMessageChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendMessageChatID(value string) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendMessageChatID(previous)
	}
}

// WithSendMessageMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendMessageMessageThreadID(value int64) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendMessageMessageThreadID(previous)
	}
}

// WithSendMessageDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendMessageDirectMessagesTopicID(value int64) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendMessageDirectMessagesTopicID(previous)
	}
}

// WithSendMessageText sets the Text field.
//
// Text of the message to be sent, 1-4096 characters after entities parsing
func WithSendMessageText(value string) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.Text
		params.Text = value

		return WithSendMessageText(previous)
	}
}

// WithSendMessageParseMode sets the ParseMode field.
//
// Mode for parsing entities in the message text.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendMessageParseMode(value string) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithSendMessageParseMode(previous)
	}
}

// WithSendMessageEntities sets the Entities field.
//
// A JSON-serialized list of special entities that appear in message text, which can be specified instead of parse_mode
func WithSendMessageEntities(value []MessageEntity) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.Entities
		params.Entities = value

		return WithSendMessageEntities(previous)
	}
}

// WithSendMessageLinkPreviewOptions sets the LinkPreviewOptions field.
//
// Link preview generation options for the message
func WithSendMessageLinkPreviewOptions(value *LinkPreviewOptions) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.LinkPreviewOptions
		params.LinkPreviewOptions = value

		return WithSendMessageLinkPreviewOptions(previous)
	}
}

// WithSendMessageDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendMessageDisableNotification(value bool) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendMessageDisableNotification(previous)
	}
}

// WithSendMessageProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendMessageProtectContent(value bool) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendMessageProtectContent(previous)
	}
}

// WithSendMessageAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendMessageAllowPaidBroadcast(value bool) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendMessageAllowPaidBroadcast(previous)
	}
}

// WithSendMessageMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendMessageMessageEffectID(value string) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendMessageMessageEffectID(previous)
	}
}

// WithSendMessageSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendMessageSuggestedPostParameters(value *SuggestedPostParameters) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendMessageSuggestedPostParameters(previous)
	}
}

// WithSendMessageReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendMessageReplyParameters(value *ReplyParameters) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendMessageReplyParameters(previous)
	}
}

// WithSendMessageReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendMessageReplyMarkup(value *ReplyMarkup) SendMessageOption {
	return func(params *SendMessageParams) SendMessageOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendMessageReplyMarkup(previous)
	}
}

// SendMessage calls the sendMessage Telegram Bot API method.
//
// Use this method to send text messages.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendMessage(params *SendMessageParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendMessage", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendMessageDraftParams contains parameters for Client.SendMessageDraft.
type SendMessageDraftParams struct {
	// Unique identifier for the target private chat
	ChatID int64 `json:"chat_id"`

	// Unique identifier for the target message thread
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Unique identifier of the message draft; must be non-zero.
	// Changes of drafts with the same identifier are animated
	DraftID int64 `json:"draft_id"`

	// Text of the message to be sent, 1-4096 characters after entities parsing
	Text string `json:"text"`

	// Mode for parsing entities in the message text.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in message text, which can be specified instead of parse_mode
	Entities []MessageEntity `json:"entities,omitempty"`
}

// SendMessageDraftOption configures SendMessageDraftParams.
type SendMessageDraftOption func(params *SendMessageDraftParams) SendMessageDraftOption

// Option applies one or more SendMessageDraftOption values and returns the last rollback option.
func (r *SendMessageDraftParams) Option(opts ...SendMessageDraftOption) (previous SendMessageDraftOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendMessageDraftChatID sets the ChatID field.
//
// Unique identifier for the target private chat
func WithSendMessageDraftChatID(value int64) SendMessageDraftOption {
	return func(params *SendMessageDraftParams) SendMessageDraftOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendMessageDraftChatID(previous)
	}
}

// WithSendMessageDraftMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread
func WithSendMessageDraftMessageThreadID(value int64) SendMessageDraftOption {
	return func(params *SendMessageDraftParams) SendMessageDraftOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendMessageDraftMessageThreadID(previous)
	}
}

// WithSendMessageDraftDraftID sets the DraftID field.
//
// Unique identifier of the message draft; must be non-zero.
// Changes of drafts with the same identifier are animated
func WithSendMessageDraftDraftID(value int64) SendMessageDraftOption {
	return func(params *SendMessageDraftParams) SendMessageDraftOption {
		previous := params.DraftID
		params.DraftID = value

		return WithSendMessageDraftDraftID(previous)
	}
}

// WithSendMessageDraftText sets the Text field.
//
// Text of the message to be sent, 1-4096 characters after entities parsing
func WithSendMessageDraftText(value string) SendMessageDraftOption {
	return func(params *SendMessageDraftParams) SendMessageDraftOption {
		previous := params.Text
		params.Text = value

		return WithSendMessageDraftText(previous)
	}
}

// WithSendMessageDraftParseMode sets the ParseMode field.
//
// Mode for parsing entities in the message text.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendMessageDraftParseMode(value string) SendMessageDraftOption {
	return func(params *SendMessageDraftParams) SendMessageDraftOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithSendMessageDraftParseMode(previous)
	}
}

// WithSendMessageDraftEntities sets the Entities field.
//
// A JSON-serialized list of special entities that appear in message text, which can be specified instead of parse_mode
func WithSendMessageDraftEntities(value []MessageEntity) SendMessageDraftOption {
	return func(params *SendMessageDraftParams) SendMessageDraftOption {
		previous := params.Entities
		params.Entities = value

		return WithSendMessageDraftEntities(previous)
	}
}

// SendMessageDraft calls the sendMessageDraft Telegram Bot API method.
//
// Use this method to stream a partial message to a user while the message is being generated.
// Returns True on success.
func (c *Client) SendMessageDraft(params *SendMessageDraftParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendMessageDraft", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendPaidMediaParams contains parameters for Client.SendPaidMedia.
type SendPaidMediaParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername).
	// If the chat is a channel, all Telegram Star proceeds from this media will be credited to the chat's balance.
	// Otherwise, they will be credited to the bot's balance.
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// The number of Telegram Stars that must be paid to buy access to the media; 1-25000
	StarCount int64 `json:"star_count"`

	// A JSON-serialized array describing the media to be sent; up to 10 items
	Media []InputPaidMedia `json:"media"`

	// Bot-defined paid media payload, 0-128 bytes.
	// This will not be displayed to the user, use it for your internal processes.
	Payload string `json:"payload,omitempty"`

	// Media caption, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Mode for parsing entities in the media caption.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Pass True, if the caption must be shown above the message media
	ShowCaptionAboveMedia bool `json:"show_caption_above_media,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendPaidMediaOption configures SendPaidMediaParams.
type SendPaidMediaOption func(params *SendPaidMediaParams) SendPaidMediaOption

// Option applies one or more SendPaidMediaOption values and returns the last rollback option.
func (r *SendPaidMediaParams) Option(opts ...SendPaidMediaOption) (previous SendPaidMediaOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendPaidMediaBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendPaidMediaBusinessConnectionID(value string) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendPaidMediaBusinessConnectionID(previous)
	}
}

// WithSendPaidMediaChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername).
// If the chat is a channel, all Telegram Star proceeds from this media will be credited to the chat's balance.
// Otherwise, they will be credited to the bot's balance.
func WithSendPaidMediaChatID(value string) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendPaidMediaChatID(previous)
	}
}

// WithSendPaidMediaMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendPaidMediaMessageThreadID(value int64) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendPaidMediaMessageThreadID(previous)
	}
}

// WithSendPaidMediaDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendPaidMediaDirectMessagesTopicID(value int64) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendPaidMediaDirectMessagesTopicID(previous)
	}
}

// WithSendPaidMediaStarCount sets the StarCount field.
//
// The number of Telegram Stars that must be paid to buy access to the media; 1-25000
func WithSendPaidMediaStarCount(value int64) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.StarCount
		params.StarCount = value

		return WithSendPaidMediaStarCount(previous)
	}
}

// WithSendPaidMediaMedia sets the Media field.
//
// A JSON-serialized array describing the media to be sent; up to 10 items
func WithSendPaidMediaMedia(value []InputPaidMedia) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.Media
		params.Media = value

		return WithSendPaidMediaMedia(previous)
	}
}

// WithSendPaidMediaPayload sets the Payload field.
//
// Bot-defined paid media payload, 0-128 bytes.
// This will not be displayed to the user, use it for your internal processes.
func WithSendPaidMediaPayload(value string) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.Payload
		params.Payload = value

		return WithSendPaidMediaPayload(previous)
	}
}

// WithSendPaidMediaCaption sets the Caption field.
//
// Media caption, 0-1024 characters after entities parsing
func WithSendPaidMediaCaption(value string) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.Caption
		params.Caption = value

		return WithSendPaidMediaCaption(previous)
	}
}

// WithSendPaidMediaParseMode sets the ParseMode field.
//
// Mode for parsing entities in the media caption.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendPaidMediaParseMode(value string) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithSendPaidMediaParseMode(previous)
	}
}

// WithSendPaidMediaCaptionEntities sets the CaptionEntities field.
//
// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
func WithSendPaidMediaCaptionEntities(value []MessageEntity) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.CaptionEntities
		params.CaptionEntities = value

		return WithSendPaidMediaCaptionEntities(previous)
	}
}

// WithSendPaidMediaShowCaptionAboveMedia sets the ShowCaptionAboveMedia field.
//
// Pass True, if the caption must be shown above the message media
func WithSendPaidMediaShowCaptionAboveMedia(value bool) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.ShowCaptionAboveMedia
		params.ShowCaptionAboveMedia = value

		return WithSendPaidMediaShowCaptionAboveMedia(previous)
	}
}

// WithSendPaidMediaDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendPaidMediaDisableNotification(value bool) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendPaidMediaDisableNotification(previous)
	}
}

// WithSendPaidMediaProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendPaidMediaProtectContent(value bool) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendPaidMediaProtectContent(previous)
	}
}

// WithSendPaidMediaAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendPaidMediaAllowPaidBroadcast(value bool) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendPaidMediaAllowPaidBroadcast(previous)
	}
}

// WithSendPaidMediaSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendPaidMediaSuggestedPostParameters(value *SuggestedPostParameters) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendPaidMediaSuggestedPostParameters(previous)
	}
}

// WithSendPaidMediaReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendPaidMediaReplyParameters(value *ReplyParameters) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendPaidMediaReplyParameters(previous)
	}
}

// WithSendPaidMediaReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendPaidMediaReplyMarkup(value *ReplyMarkup) SendPaidMediaOption {
	return func(params *SendPaidMediaParams) SendPaidMediaOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendPaidMediaReplyMarkup(previous)
	}
}

// SendPaidMedia calls the sendPaidMedia Telegram Bot API method.
//
// Use this method to send paid media.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendPaidMedia(params *SendPaidMediaParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendPaidMedia", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendPhotoParams contains parameters for Client.SendPhoto.
type SendPhotoParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Photo to send.
	// Pass a file_id as String to send a photo that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a photo from the Internet, or upload a new photo using multipart/form-data.
	// The photo must be at most 10 MB in size.
	// The photo's width and height must not exceed 10000 in total.
	// Width and height ratio must be at most 20.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Photo InputFile `json:"photo"`

	// Photo caption (may also be used when resending photos by file_id), 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Mode for parsing entities in the photo caption.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Pass True, if the caption must be shown above the message media
	ShowCaptionAboveMedia bool `json:"show_caption_above_media,omitempty"`

	// Pass True if the photo needs to be covered with a spoiler animation
	HasSpoiler bool `json:"has_spoiler,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendPhotoOption configures SendPhotoParams.
type SendPhotoOption func(params *SendPhotoParams) SendPhotoOption

// Option applies one or more SendPhotoOption values and returns the last rollback option.
func (r *SendPhotoParams) Option(opts ...SendPhotoOption) (previous SendPhotoOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendPhotoBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendPhotoBusinessConnectionID(value string) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendPhotoBusinessConnectionID(previous)
	}
}

// WithSendPhotoChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendPhotoChatID(value string) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendPhotoChatID(previous)
	}
}

// WithSendPhotoMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendPhotoMessageThreadID(value int64) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendPhotoMessageThreadID(previous)
	}
}

// WithSendPhotoDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendPhotoDirectMessagesTopicID(value int64) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendPhotoDirectMessagesTopicID(previous)
	}
}

// WithSendPhotoPhoto sets the Photo field.
//
// Photo to send.
// Pass a file_id as String to send a photo that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a photo from the Internet, or upload a new photo using multipart/form-data.
// The photo must be at most 10 MB in size.
// The photo's width and height must not exceed 10000 in total.
// Width and height ratio must be at most 20.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendPhotoPhoto(value InputFile) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.Photo
		params.Photo = value

		return WithSendPhotoPhoto(previous)
	}
}

// WithSendPhotoCaption sets the Caption field.
//
// Photo caption (may also be used when resending photos by file_id), 0-1024 characters after entities parsing
func WithSendPhotoCaption(value string) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.Caption
		params.Caption = value

		return WithSendPhotoCaption(previous)
	}
}

// WithSendPhotoParseMode sets the ParseMode field.
//
// Mode for parsing entities in the photo caption.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendPhotoParseMode(value string) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithSendPhotoParseMode(previous)
	}
}

// WithSendPhotoCaptionEntities sets the CaptionEntities field.
//
// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
func WithSendPhotoCaptionEntities(value []MessageEntity) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.CaptionEntities
		params.CaptionEntities = value

		return WithSendPhotoCaptionEntities(previous)
	}
}

// WithSendPhotoShowCaptionAboveMedia sets the ShowCaptionAboveMedia field.
//
// Pass True, if the caption must be shown above the message media
func WithSendPhotoShowCaptionAboveMedia(value bool) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.ShowCaptionAboveMedia
		params.ShowCaptionAboveMedia = value

		return WithSendPhotoShowCaptionAboveMedia(previous)
	}
}

// WithSendPhotoHasSpoiler sets the HasSpoiler field.
//
// Pass True if the photo needs to be covered with a spoiler animation
func WithSendPhotoHasSpoiler(value bool) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.HasSpoiler
		params.HasSpoiler = value

		return WithSendPhotoHasSpoiler(previous)
	}
}

// WithSendPhotoDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendPhotoDisableNotification(value bool) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendPhotoDisableNotification(previous)
	}
}

// WithSendPhotoProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendPhotoProtectContent(value bool) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendPhotoProtectContent(previous)
	}
}

// WithSendPhotoAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendPhotoAllowPaidBroadcast(value bool) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendPhotoAllowPaidBroadcast(previous)
	}
}

// WithSendPhotoMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendPhotoMessageEffectID(value string) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendPhotoMessageEffectID(previous)
	}
}

// WithSendPhotoSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendPhotoSuggestedPostParameters(value *SuggestedPostParameters) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendPhotoSuggestedPostParameters(previous)
	}
}

// WithSendPhotoReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendPhotoReplyParameters(value *ReplyParameters) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendPhotoReplyParameters(previous)
	}
}

// WithSendPhotoReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendPhotoReplyMarkup(value *ReplyMarkup) SendPhotoOption {
	return func(params *SendPhotoParams) SendPhotoOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendPhotoReplyMarkup(previous)
	}
}

// SendPhoto calls the sendPhoto Telegram Bot API method.
//
// Use this method to send photos.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendPhoto(params *SendPhotoParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendPhoto", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendPollParams contains parameters for Client.SendPoll.
type SendPollParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername).
	// Polls can't be sent to channel direct messages chats.
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Poll question, 1-300 characters
	Question string `json:"question"`

	// Mode for parsing entities in the question.
	// See [formatting options] for more details.
	// Currently, only custom emoji entities are allowed
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	QuestionParseMode string `json:"question_parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the poll question.
	// It can be specified instead of question_parse_mode
	QuestionEntities []MessageEntity `json:"question_entities,omitempty"`

	// A JSON-serialized list of 2-12 answer options
	Options []InputPollOption `json:"options"`

	// True, if the poll needs to be anonymous, defaults to True
	IsAnonymous bool `json:"is_anonymous,omitempty"`

	// Poll type, “quiz” or “regular”, defaults to “regular”
	Type string `json:"type,omitempty"`

	// True, if the poll allows multiple answers, ignored for polls in quiz mode, defaults to False
	AllowsMultipleAnswers bool `json:"allows_multiple_answers,omitempty"`

	// 0-based identifier of the correct answer option, required for polls in quiz mode
	CorrectOptionID int64 `json:"correct_option_id,omitempty"`

	// Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters with at most 2 line feeds after entities parsing
	Explanation string `json:"explanation,omitempty"`

	// Mode for parsing entities in the explanation.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ExplanationParseMode string `json:"explanation_parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the poll explanation.
	// It can be specified instead of explanation_parse_mode
	ExplanationEntities []MessageEntity `json:"explanation_entities,omitempty"`

	// Amount of time in seconds the poll will be active after creation, 5-600.
	// Can't be used together with close_date.
	OpenPeriod int64 `json:"open_period,omitempty"`

	// Point in time (Unix timestamp) when the poll will be automatically closed.
	// Must be at least 5 and no more than 600 seconds in the future.
	// Can't be used together with open_period.
	CloseDate int64 `json:"close_date,omitempty"`

	// Pass True if the poll needs to be immediately closed.
	// This can be useful for poll preview.
	IsClosed bool `json:"is_closed,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendPollOption configures SendPollParams.
type SendPollOption func(params *SendPollParams) SendPollOption

// Option applies one or more SendPollOption values and returns the last rollback option.
func (r *SendPollParams) Option(opts ...SendPollOption) (previous SendPollOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendPollBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendPollBusinessConnectionID(value string) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendPollBusinessConnectionID(previous)
	}
}

// WithSendPollChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername).
// Polls can't be sent to channel direct messages chats.
func WithSendPollChatID(value string) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendPollChatID(previous)
	}
}

// WithSendPollMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendPollMessageThreadID(value int64) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendPollMessageThreadID(previous)
	}
}

// WithSendPollQuestion sets the Question field.
//
// Poll question, 1-300 characters
func WithSendPollQuestion(value string) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.Question
		params.Question = value

		return WithSendPollQuestion(previous)
	}
}

// WithSendPollQuestionParseMode sets the QuestionParseMode field.
//
// Mode for parsing entities in the question.
// See [formatting options] for more details.
// Currently, only custom emoji entities are allowed
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendPollQuestionParseMode(value string) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.QuestionParseMode
		params.QuestionParseMode = value

		return WithSendPollQuestionParseMode(previous)
	}
}

// WithSendPollQuestionEntities sets the QuestionEntities field.
//
// A JSON-serialized list of special entities that appear in the poll question.
// It can be specified instead of question_parse_mode
func WithSendPollQuestionEntities(value []MessageEntity) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.QuestionEntities
		params.QuestionEntities = value

		return WithSendPollQuestionEntities(previous)
	}
}

// WithSendPollOptions sets the Options field.
//
// A JSON-serialized list of 2-12 answer options
func WithSendPollOptions(value []InputPollOption) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.Options
		params.Options = value

		return WithSendPollOptions(previous)
	}
}

// WithSendPollIsAnonymous sets the IsAnonymous field.
//
// True, if the poll needs to be anonymous, defaults to True
func WithSendPollIsAnonymous(value bool) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.IsAnonymous
		params.IsAnonymous = value

		return WithSendPollIsAnonymous(previous)
	}
}

// WithSendPollType sets the Type field.
//
// Poll type, “quiz” or “regular”, defaults to “regular”
func WithSendPollType(value string) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.Type
		params.Type = value

		return WithSendPollType(previous)
	}
}

// WithSendPollAllowsMultipleAnswers sets the AllowsMultipleAnswers field.
//
// True, if the poll allows multiple answers, ignored for polls in quiz mode, defaults to False
func WithSendPollAllowsMultipleAnswers(value bool) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.AllowsMultipleAnswers
		params.AllowsMultipleAnswers = value

		return WithSendPollAllowsMultipleAnswers(previous)
	}
}

// WithSendPollCorrectOptionID sets the CorrectOptionID field.
//
// 0-based identifier of the correct answer option, required for polls in quiz mode
func WithSendPollCorrectOptionID(value int64) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.CorrectOptionID
		params.CorrectOptionID = value

		return WithSendPollCorrectOptionID(previous)
	}
}

// WithSendPollExplanation sets the Explanation field.
//
// Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters with at most 2 line feeds after entities parsing
func WithSendPollExplanation(value string) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.Explanation
		params.Explanation = value

		return WithSendPollExplanation(previous)
	}
}

// WithSendPollExplanationParseMode sets the ExplanationParseMode field.
//
// Mode for parsing entities in the explanation.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendPollExplanationParseMode(value string) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.ExplanationParseMode
		params.ExplanationParseMode = value

		return WithSendPollExplanationParseMode(previous)
	}
}

// WithSendPollExplanationEntities sets the ExplanationEntities field.
//
// A JSON-serialized list of special entities that appear in the poll explanation.
// It can be specified instead of explanation_parse_mode
func WithSendPollExplanationEntities(value []MessageEntity) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.ExplanationEntities
		params.ExplanationEntities = value

		return WithSendPollExplanationEntities(previous)
	}
}

// WithSendPollOpenPeriod sets the OpenPeriod field.
//
// Amount of time in seconds the poll will be active after creation, 5-600.
// Can't be used together with close_date.
func WithSendPollOpenPeriod(value int64) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.OpenPeriod
		params.OpenPeriod = value

		return WithSendPollOpenPeriod(previous)
	}
}

// WithSendPollCloseDate sets the CloseDate field.
//
// Point in time (Unix timestamp) when the poll will be automatically closed.
// Must be at least 5 and no more than 600 seconds in the future.
// Can't be used together with open_period.
func WithSendPollCloseDate(value int64) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.CloseDate
		params.CloseDate = value

		return WithSendPollCloseDate(previous)
	}
}

// WithSendPollIsClosed sets the IsClosed field.
//
// Pass True if the poll needs to be immediately closed.
// This can be useful for poll preview.
func WithSendPollIsClosed(value bool) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.IsClosed
		params.IsClosed = value

		return WithSendPollIsClosed(previous)
	}
}

// WithSendPollDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendPollDisableNotification(value bool) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendPollDisableNotification(previous)
	}
}

// WithSendPollProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendPollProtectContent(value bool) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendPollProtectContent(previous)
	}
}

// WithSendPollAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendPollAllowPaidBroadcast(value bool) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendPollAllowPaidBroadcast(previous)
	}
}

// WithSendPollMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendPollMessageEffectID(value string) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendPollMessageEffectID(previous)
	}
}

// WithSendPollReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendPollReplyParameters(value *ReplyParameters) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendPollReplyParameters(previous)
	}
}

// WithSendPollReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendPollReplyMarkup(value *ReplyMarkup) SendPollOption {
	return func(params *SendPollParams) SendPollOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendPollReplyMarkup(previous)
	}
}

// SendPoll calls the sendPoll Telegram Bot API method.
//
// Use this method to send a native poll.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendPoll(params *SendPollParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendPoll", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendStickerParams contains parameters for Client.SendSticker.
type SendStickerParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Sticker to send.
	// Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a .WEBP sticker from the Internet, or upload a new .WEBP, .TGS, or .WEBM sticker using multipart/form-data.
	// [More information on Sending Files »].
	// Video and animated stickers can't be sent via an HTTP URL.
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Sticker InputFile `json:"sticker"`

	// Emoji associated with the sticker; only for just uploaded stickers
	Emoji string `json:"emoji,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendStickerOption configures SendStickerParams.
type SendStickerOption func(params *SendStickerParams) SendStickerOption

// Option applies one or more SendStickerOption values and returns the last rollback option.
func (r *SendStickerParams) Option(opts ...SendStickerOption) (previous SendStickerOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendStickerBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendStickerBusinessConnectionID(value string) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendStickerBusinessConnectionID(previous)
	}
}

// WithSendStickerChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendStickerChatID(value string) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendStickerChatID(previous)
	}
}

// WithSendStickerMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendStickerMessageThreadID(value int64) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendStickerMessageThreadID(previous)
	}
}

// WithSendStickerDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendStickerDirectMessagesTopicID(value int64) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendStickerDirectMessagesTopicID(previous)
	}
}

// WithSendStickerSticker sets the Sticker field.
//
// Sticker to send.
// Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a .WEBP sticker from the Internet, or upload a new .WEBP, .TGS, or .WEBM sticker using multipart/form-data.
// [More information on Sending Files »].
// Video and animated stickers can't be sent via an HTTP URL.
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendStickerSticker(value InputFile) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.Sticker
		params.Sticker = value

		return WithSendStickerSticker(previous)
	}
}

// WithSendStickerEmoji sets the Emoji field.
//
// Emoji associated with the sticker; only for just uploaded stickers
func WithSendStickerEmoji(value string) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.Emoji
		params.Emoji = value

		return WithSendStickerEmoji(previous)
	}
}

// WithSendStickerDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendStickerDisableNotification(value bool) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendStickerDisableNotification(previous)
	}
}

// WithSendStickerProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendStickerProtectContent(value bool) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendStickerProtectContent(previous)
	}
}

// WithSendStickerAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendStickerAllowPaidBroadcast(value bool) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendStickerAllowPaidBroadcast(previous)
	}
}

// WithSendStickerMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendStickerMessageEffectID(value string) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendStickerMessageEffectID(previous)
	}
}

// WithSendStickerSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendStickerSuggestedPostParameters(value *SuggestedPostParameters) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendStickerSuggestedPostParameters(previous)
	}
}

// WithSendStickerReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendStickerReplyParameters(value *ReplyParameters) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendStickerReplyParameters(previous)
	}
}

// WithSendStickerReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendStickerReplyMarkup(value *ReplyMarkup) SendStickerOption {
	return func(params *SendStickerParams) SendStickerOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendStickerReplyMarkup(previous)
	}
}

// SendSticker calls the sendSticker Telegram Bot API method.
//
// Use this method to send static .WEBP, [animated] .TGS, or [video] .WEBM stickers.
// On success, the sent [Message] is returned.
//
// [animated]: https://telegram.org/blog/animated-stickers
// [video]: https://telegram.org/blog/video-stickers-better-reactions
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendSticker(params *SendStickerParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendSticker", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendVenueParams contains parameters for Client.SendVenue.
type SendVenueParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Latitude of the venue
	Latitude float64 `json:"latitude"`

	// Longitude of the venue
	Longitude float64 `json:"longitude"`

	// Name of the venue
	Title string `json:"title"`

	// Address of the venue
	Address string `json:"address"`

	// Foursquare identifier of the venue
	FoursquareID string `json:"foursquare_id,omitempty"`

	// Foursquare type of the venue, if known.
	// (For example, “arts_entertainment/default”, “arts_entertainment/aquarium” or “food/icecream”.)
	FoursquareType string `json:"foursquare_type,omitempty"`

	// Google Places identifier of the venue
	GooglePlaceID string `json:"google_place_id,omitempty"`

	// Google Places type of the venue.
	// (See [supported types].)
	//
	// [supported types]: https://developers.google.com/places/web-service/supported_types
	GooglePlaceType string `json:"google_place_type,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendVenueOption configures SendVenueParams.
type SendVenueOption func(params *SendVenueParams) SendVenueOption

// Option applies one or more SendVenueOption values and returns the last rollback option.
func (r *SendVenueParams) Option(opts ...SendVenueOption) (previous SendVenueOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendVenueBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendVenueBusinessConnectionID(value string) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendVenueBusinessConnectionID(previous)
	}
}

// WithSendVenueChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendVenueChatID(value string) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendVenueChatID(previous)
	}
}

// WithSendVenueMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendVenueMessageThreadID(value int64) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendVenueMessageThreadID(previous)
	}
}

// WithSendVenueDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendVenueDirectMessagesTopicID(value int64) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendVenueDirectMessagesTopicID(previous)
	}
}

// WithSendVenueLatitude sets the Latitude field.
//
// Latitude of the venue
func WithSendVenueLatitude(value float64) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.Latitude
		params.Latitude = value

		return WithSendVenueLatitude(previous)
	}
}

// WithSendVenueLongitude sets the Longitude field.
//
// Longitude of the venue
func WithSendVenueLongitude(value float64) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.Longitude
		params.Longitude = value

		return WithSendVenueLongitude(previous)
	}
}

// WithSendVenueTitle sets the Title field.
//
// Name of the venue
func WithSendVenueTitle(value string) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.Title
		params.Title = value

		return WithSendVenueTitle(previous)
	}
}

// WithSendVenueAddress sets the Address field.
//
// Address of the venue
func WithSendVenueAddress(value string) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.Address
		params.Address = value

		return WithSendVenueAddress(previous)
	}
}

// WithSendVenueFoursquareID sets the FoursquareID field.
//
// Foursquare identifier of the venue
func WithSendVenueFoursquareID(value string) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.FoursquareID
		params.FoursquareID = value

		return WithSendVenueFoursquareID(previous)
	}
}

// WithSendVenueFoursquareType sets the FoursquareType field.
//
// Foursquare type of the venue, if known.
// (For example, “arts_entertainment/default”, “arts_entertainment/aquarium” or “food/icecream”.)
func WithSendVenueFoursquareType(value string) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.FoursquareType
		params.FoursquareType = value

		return WithSendVenueFoursquareType(previous)
	}
}

// WithSendVenueGooglePlaceID sets the GooglePlaceID field.
//
// Google Places identifier of the venue
func WithSendVenueGooglePlaceID(value string) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.GooglePlaceID
		params.GooglePlaceID = value

		return WithSendVenueGooglePlaceID(previous)
	}
}

// WithSendVenueGooglePlaceType sets the GooglePlaceType field.
//
// Google Places type of the venue.
// (See [supported types].)
//
// [supported types]: https://developers.google.com/places/web-service/supported_types
func WithSendVenueGooglePlaceType(value string) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.GooglePlaceType
		params.GooglePlaceType = value

		return WithSendVenueGooglePlaceType(previous)
	}
}

// WithSendVenueDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendVenueDisableNotification(value bool) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendVenueDisableNotification(previous)
	}
}

// WithSendVenueProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendVenueProtectContent(value bool) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendVenueProtectContent(previous)
	}
}

// WithSendVenueAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendVenueAllowPaidBroadcast(value bool) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendVenueAllowPaidBroadcast(previous)
	}
}

// WithSendVenueMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendVenueMessageEffectID(value string) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendVenueMessageEffectID(previous)
	}
}

// WithSendVenueSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendVenueSuggestedPostParameters(value *SuggestedPostParameters) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendVenueSuggestedPostParameters(previous)
	}
}

// WithSendVenueReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendVenueReplyParameters(value *ReplyParameters) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendVenueReplyParameters(previous)
	}
}

// WithSendVenueReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendVenueReplyMarkup(value *ReplyMarkup) SendVenueOption {
	return func(params *SendVenueParams) SendVenueOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendVenueReplyMarkup(previous)
	}
}

// SendVenue calls the sendVenue Telegram Bot API method.
//
// Use this method to send information about a venue.
// On success, the sent [Message] is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendVenue(params *SendVenueParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendVenue", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendVideoParams contains parameters for Client.SendVideo.
type SendVideoParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Video to send.
	// Pass a file_id as String to send a video that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a video from the Internet, or upload a new video using multipart/form-data.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Video InputFile `json:"video"`

	// Duration of sent video in seconds
	Duration int64 `json:"duration,omitempty"`

	// Video width
	Width int64 `json:"width,omitempty"`

	// Video height
	Height int64 `json:"height,omitempty"`

	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side.
	// The thumbnail should be in JPEG format and less than 200 kB in size.
	// A thumbnail's width and height should not exceed 320.
	// Ignored if the file is not uploaded using multipart/form-data.
	// Thumbnails can't be reused and can be only uploaded as a new file, so you can pass “attach://<file_attach_name>” if the thumbnail was uploaded using multipart/form-data under <file_attach_name>.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Thumbnail *InputFile `json:"thumbnail,omitempty"`

	// Cover for the video in the message.
	// Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass “attach://<file_attach_name>” to upload a new one using multipart/form-data under <file_attach_name> name.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Cover *InputFile `json:"cover,omitempty"`

	// Start timestamp for the video in the message
	StartTimestamp int64 `json:"start_timestamp,omitempty"`

	// Video caption (may also be used when resending videos by file_id), 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Mode for parsing entities in the video caption.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Pass True, if the caption must be shown above the message media
	ShowCaptionAboveMedia bool `json:"show_caption_above_media,omitempty"`

	// Pass True if the video needs to be covered with a spoiler animation
	HasSpoiler bool `json:"has_spoiler,omitempty"`

	// Pass True if the uploaded video is suitable for streaming
	SupportsStreaming bool `json:"supports_streaming,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendVideoOption configures SendVideoParams.
type SendVideoOption func(params *SendVideoParams) SendVideoOption

// Option applies one or more SendVideoOption values and returns the last rollback option.
func (r *SendVideoParams) Option(opts ...SendVideoOption) (previous SendVideoOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendVideoBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendVideoBusinessConnectionID(value string) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendVideoBusinessConnectionID(previous)
	}
}

// WithSendVideoChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendVideoChatID(value string) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendVideoChatID(previous)
	}
}

// WithSendVideoMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendVideoMessageThreadID(value int64) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendVideoMessageThreadID(previous)
	}
}

// WithSendVideoDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendVideoDirectMessagesTopicID(value int64) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendVideoDirectMessagesTopicID(previous)
	}
}

// WithSendVideoVideo sets the Video field.
//
// Video to send.
// Pass a file_id as String to send a video that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a video from the Internet, or upload a new video using multipart/form-data.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendVideoVideo(value InputFile) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.Video
		params.Video = value

		return WithSendVideoVideo(previous)
	}
}

// WithSendVideoDuration sets the Duration field.
//
// Duration of sent video in seconds
func WithSendVideoDuration(value int64) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.Duration
		params.Duration = value

		return WithSendVideoDuration(previous)
	}
}

// WithSendVideoWidth sets the Width field.
//
// Video width
func WithSendVideoWidth(value int64) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.Width
		params.Width = value

		return WithSendVideoWidth(previous)
	}
}

// WithSendVideoHeight sets the Height field.
//
// Video height
func WithSendVideoHeight(value int64) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.Height
		params.Height = value

		return WithSendVideoHeight(previous)
	}
}

// WithSendVideoThumbnail sets the Thumbnail field.
//
// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side.
// The thumbnail should be in JPEG format and less than 200 kB in size.
// A thumbnail's width and height should not exceed 320.
// Ignored if the file is not uploaded using multipart/form-data.
// Thumbnails can't be reused and can be only uploaded as a new file, so you can pass “attach://<file_attach_name>” if the thumbnail was uploaded using multipart/form-data under <file_attach_name>.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendVideoThumbnail(value *InputFile) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.Thumbnail
		params.Thumbnail = value

		return WithSendVideoThumbnail(previous)
	}
}

// WithSendVideoCover sets the Cover field.
//
// Cover for the video in the message.
// Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass “attach://<file_attach_name>” to upload a new one using multipart/form-data under <file_attach_name> name.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendVideoCover(value *InputFile) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.Cover
		params.Cover = value

		return WithSendVideoCover(previous)
	}
}

// WithSendVideoStartTimestamp sets the StartTimestamp field.
//
// Start timestamp for the video in the message
func WithSendVideoStartTimestamp(value int64) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.StartTimestamp
		params.StartTimestamp = value

		return WithSendVideoStartTimestamp(previous)
	}
}

// WithSendVideoCaption sets the Caption field.
//
// Video caption (may also be used when resending videos by file_id), 0-1024 characters after entities parsing
func WithSendVideoCaption(value string) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.Caption
		params.Caption = value

		return WithSendVideoCaption(previous)
	}
}

// WithSendVideoParseMode sets the ParseMode field.
//
// Mode for parsing entities in the video caption.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendVideoParseMode(value string) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithSendVideoParseMode(previous)
	}
}

// WithSendVideoCaptionEntities sets the CaptionEntities field.
//
// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
func WithSendVideoCaptionEntities(value []MessageEntity) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.CaptionEntities
		params.CaptionEntities = value

		return WithSendVideoCaptionEntities(previous)
	}
}

// WithSendVideoShowCaptionAboveMedia sets the ShowCaptionAboveMedia field.
//
// Pass True, if the caption must be shown above the message media
func WithSendVideoShowCaptionAboveMedia(value bool) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.ShowCaptionAboveMedia
		params.ShowCaptionAboveMedia = value

		return WithSendVideoShowCaptionAboveMedia(previous)
	}
}

// WithSendVideoHasSpoiler sets the HasSpoiler field.
//
// Pass True if the video needs to be covered with a spoiler animation
func WithSendVideoHasSpoiler(value bool) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.HasSpoiler
		params.HasSpoiler = value

		return WithSendVideoHasSpoiler(previous)
	}
}

// WithSendVideoSupportsStreaming sets the SupportsStreaming field.
//
// Pass True if the uploaded video is suitable for streaming
func WithSendVideoSupportsStreaming(value bool) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.SupportsStreaming
		params.SupportsStreaming = value

		return WithSendVideoSupportsStreaming(previous)
	}
}

// WithSendVideoDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendVideoDisableNotification(value bool) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendVideoDisableNotification(previous)
	}
}

// WithSendVideoProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendVideoProtectContent(value bool) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendVideoProtectContent(previous)
	}
}

// WithSendVideoAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendVideoAllowPaidBroadcast(value bool) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendVideoAllowPaidBroadcast(previous)
	}
}

// WithSendVideoMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendVideoMessageEffectID(value string) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendVideoMessageEffectID(previous)
	}
}

// WithSendVideoSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendVideoSuggestedPostParameters(value *SuggestedPostParameters) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendVideoSuggestedPostParameters(previous)
	}
}

// WithSendVideoReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendVideoReplyParameters(value *ReplyParameters) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendVideoReplyParameters(previous)
	}
}

// WithSendVideoReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendVideoReplyMarkup(value *ReplyMarkup) SendVideoOption {
	return func(params *SendVideoParams) SendVideoOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendVideoReplyMarkup(previous)
	}
}

// SendVideo calls the sendVideo Telegram Bot API method.
//
// Use this method to send video files, Telegram clients support MPEG4 videos (other formats may be sent as [Document]).
// On success, the sent [Message] is returned.
// Bots can currently send video files of up to 50 MB in size, this limit may be changed in the future.
//
// [Document]: https://core.telegram.org/bots/api#document
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendVideo(params *SendVideoParams) (ret *Message, err error) {
	var bs []byte

	reader, pw := io.Pipe()
	writer := multipart.NewWriter(pw)

	go func() {
		defer pw.Close()
		defer writer.Close()

		if params.BusinessConnectionID != "" {
			err = writer.WriteField("business_connection_id", params.BusinessConnectionID)
			if err != nil {
				return
			}
		}

		{
			err = writer.WriteField("chat_id", params.ChatID)
			if err != nil {
				return
			}
		}

		if params.MessageThreadID != 0 {
			v := strconv.FormatInt(params.MessageThreadID, 10)
			err = writer.WriteField("message_thread_id", v)
			if err != nil {
				return
			}
		}

		if params.DirectMessagesTopicID != 0 {
			v := strconv.FormatInt(params.DirectMessagesTopicID, 10)
			err = writer.WriteField("direct_messages_topic_id", v)
			if err != nil {
				return
			}
		}

		{
			if params.Video.File != nil {
				var w io.Writer
				params.Video.fieldName = "video"

				w, err = writer.CreateFormFile(
					params.Video.fieldName,
					params.Video.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Video.File)
				if err != nil {
					return
				}

				if closer, ok := params.Video.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Video)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("video")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.Duration != 0 {
			v := strconv.FormatInt(params.Duration, 10)
			err = writer.WriteField("duration", v)
			if err != nil {
				return
			}
		}

		if params.Width != 0 {
			v := strconv.FormatInt(params.Width, 10)
			err = writer.WriteField("width", v)
			if err != nil {
				return
			}
		}

		if params.Height != 0 {
			v := strconv.FormatInt(params.Height, 10)
			err = writer.WriteField("height", v)
			if err != nil {
				return
			}
		}

		if params.Thumbnail != nil {
			if params.Thumbnail.File != nil {
				var w io.Writer
				params.Thumbnail.fieldName = "thumbnail"

				w, err = writer.CreateFormFile(
					params.Thumbnail.fieldName,
					params.Thumbnail.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Thumbnail.File)
				if err != nil {
					return
				}

				if closer, ok := params.Thumbnail.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Thumbnail)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("thumbnail")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.Cover != nil {
			if params.Cover.File != nil {
				var w io.Writer
				params.Cover.fieldName = "cover"

				w, err = writer.CreateFormFile(
					params.Cover.fieldName,
					params.Cover.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Cover.File)
				if err != nil {
					return
				}

				if closer, ok := params.Cover.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Cover)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("cover")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.StartTimestamp != 0 {
			v := strconv.FormatInt(params.StartTimestamp, 10)
			err = writer.WriteField("start_timestamp", v)
			if err != nil {
				return
			}
		}

		if params.Caption != "" {
			err = writer.WriteField("caption", params.Caption)
			if err != nil {
				return
			}
		}

		if params.ParseMode != "" {
			err = writer.WriteField("parse_mode", params.ParseMode)
			if err != nil {
				return
			}
		}

		if params.CaptionEntities != nil {

			bs, err = json.Marshal(params.CaptionEntities)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("caption_entities")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ShowCaptionAboveMedia {
			v := strconv.FormatBool(params.ShowCaptionAboveMedia)
			err = writer.WriteField("show_caption_above_media", v)
			if err != nil {
				return
			}
		}

		if params.HasSpoiler {
			v := strconv.FormatBool(params.HasSpoiler)
			err = writer.WriteField("has_spoiler", v)
			if err != nil {
				return
			}
		}

		if params.SupportsStreaming {
			v := strconv.FormatBool(params.SupportsStreaming)
			err = writer.WriteField("supports_streaming", v)
			if err != nil {
				return
			}
		}

		if params.DisableNotification {
			v := strconv.FormatBool(params.DisableNotification)
			err = writer.WriteField("disable_notification", v)
			if err != nil {
				return
			}
		}

		if params.ProtectContent {
			v := strconv.FormatBool(params.ProtectContent)
			err = writer.WriteField("protect_content", v)
			if err != nil {
				return
			}
		}

		if params.AllowPaidBroadcast {
			v := strconv.FormatBool(params.AllowPaidBroadcast)
			err = writer.WriteField("allow_paid_broadcast", v)
			if err != nil {
				return
			}
		}

		if params.MessageEffectID != "" {
			err = writer.WriteField("message_effect_id", params.MessageEffectID)
			if err != nil {
				return
			}
		}

		if params.SuggestedPostParameters != nil {

			bs, err = json.Marshal(params.SuggestedPostParameters)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("suggested_post_parameters")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ReplyParameters != nil {

			bs, err = json.Marshal(params.ReplyParameters)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("reply_parameters")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ReplyMarkup != nil {

			bs, err = json.Marshal(params.ReplyMarkup)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("reply_markup")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

	}()

	contentType := writer.FormDataContentType()

	var result json.RawMessage

	result, err = c.Raw("sendVideo", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendVideoNoteParams contains parameters for Client.SendVideoNote.
type SendVideoNoteParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Video note to send.
	// Pass a file_id as String to send a video note that exists on the Telegram servers (recommended) or upload a new video using multipart/form-data.
	// [More information on Sending Files »].
	// Sending video notes by a URL is currently unsupported
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	VideoNote InputFile `json:"video_note"`

	// Duration of sent video in seconds
	Duration int64 `json:"duration,omitempty"`

	// Video width and height, i.e.
	// diameter of the video message
	Length int64 `json:"length,omitempty"`

	// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side.
	// The thumbnail should be in JPEG format and less than 200 kB in size.
	// A thumbnail's width and height should not exceed 320.
	// Ignored if the file is not uploaded using multipart/form-data.
	// Thumbnails can't be reused and can be only uploaded as a new file, so you can pass “attach://<file_attach_name>” if the thumbnail was uploaded using multipart/form-data under <file_attach_name>.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Thumbnail *InputFile `json:"thumbnail,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendVideoNoteOption configures SendVideoNoteParams.
type SendVideoNoteOption func(params *SendVideoNoteParams) SendVideoNoteOption

// Option applies one or more SendVideoNoteOption values and returns the last rollback option.
func (r *SendVideoNoteParams) Option(opts ...SendVideoNoteOption) (previous SendVideoNoteOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendVideoNoteBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendVideoNoteBusinessConnectionID(value string) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendVideoNoteBusinessConnectionID(previous)
	}
}

// WithSendVideoNoteChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendVideoNoteChatID(value string) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendVideoNoteChatID(previous)
	}
}

// WithSendVideoNoteMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendVideoNoteMessageThreadID(value int64) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendVideoNoteMessageThreadID(previous)
	}
}

// WithSendVideoNoteDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendVideoNoteDirectMessagesTopicID(value int64) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendVideoNoteDirectMessagesTopicID(previous)
	}
}

// WithSendVideoNoteVideoNote sets the VideoNote field.
//
// Video note to send.
// Pass a file_id as String to send a video note that exists on the Telegram servers (recommended) or upload a new video using multipart/form-data.
// [More information on Sending Files »].
// Sending video notes by a URL is currently unsupported
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendVideoNoteVideoNote(value InputFile) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.VideoNote
		params.VideoNote = value

		return WithSendVideoNoteVideoNote(previous)
	}
}

// WithSendVideoNoteDuration sets the Duration field.
//
// Duration of sent video in seconds
func WithSendVideoNoteDuration(value int64) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.Duration
		params.Duration = value

		return WithSendVideoNoteDuration(previous)
	}
}

// WithSendVideoNoteLength sets the Length field.
//
// Video width and height, i.e.
// diameter of the video message
func WithSendVideoNoteLength(value int64) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.Length
		params.Length = value

		return WithSendVideoNoteLength(previous)
	}
}

// WithSendVideoNoteThumbnail sets the Thumbnail field.
//
// Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side.
// The thumbnail should be in JPEG format and less than 200 kB in size.
// A thumbnail's width and height should not exceed 320.
// Ignored if the file is not uploaded using multipart/form-data.
// Thumbnails can't be reused and can be only uploaded as a new file, so you can pass “attach://<file_attach_name>” if the thumbnail was uploaded using multipart/form-data under <file_attach_name>.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendVideoNoteThumbnail(value *InputFile) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.Thumbnail
		params.Thumbnail = value

		return WithSendVideoNoteThumbnail(previous)
	}
}

// WithSendVideoNoteDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendVideoNoteDisableNotification(value bool) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendVideoNoteDisableNotification(previous)
	}
}

// WithSendVideoNoteProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendVideoNoteProtectContent(value bool) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendVideoNoteProtectContent(previous)
	}
}

// WithSendVideoNoteAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendVideoNoteAllowPaidBroadcast(value bool) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendVideoNoteAllowPaidBroadcast(previous)
	}
}

// WithSendVideoNoteMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendVideoNoteMessageEffectID(value string) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendVideoNoteMessageEffectID(previous)
	}
}

// WithSendVideoNoteSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendVideoNoteSuggestedPostParameters(value *SuggestedPostParameters) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendVideoNoteSuggestedPostParameters(previous)
	}
}

// WithSendVideoNoteReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendVideoNoteReplyParameters(value *ReplyParameters) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendVideoNoteReplyParameters(previous)
	}
}

// WithSendVideoNoteReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendVideoNoteReplyMarkup(value *ReplyMarkup) SendVideoNoteOption {
	return func(params *SendVideoNoteParams) SendVideoNoteOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendVideoNoteReplyMarkup(previous)
	}
}

// SendVideoNote calls the sendVideoNote Telegram Bot API method.
//
// As of [v.4.0], Telegram clients support rounded square MPEG4 videos of up to 1 minute long.
// Use this method to send video messages.
// On success, the sent [Message] is returned.
//
// [v.4.0]: https://telegram.org/blog/video-messages-and-telescope
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendVideoNote(params *SendVideoNoteParams) (ret *Message, err error) {
	var bs []byte

	reader, pw := io.Pipe()
	writer := multipart.NewWriter(pw)

	go func() {
		defer pw.Close()
		defer writer.Close()

		if params.BusinessConnectionID != "" {
			err = writer.WriteField("business_connection_id", params.BusinessConnectionID)
			if err != nil {
				return
			}
		}

		{
			err = writer.WriteField("chat_id", params.ChatID)
			if err != nil {
				return
			}
		}

		if params.MessageThreadID != 0 {
			v := strconv.FormatInt(params.MessageThreadID, 10)
			err = writer.WriteField("message_thread_id", v)
			if err != nil {
				return
			}
		}

		if params.DirectMessagesTopicID != 0 {
			v := strconv.FormatInt(params.DirectMessagesTopicID, 10)
			err = writer.WriteField("direct_messages_topic_id", v)
			if err != nil {
				return
			}
		}

		{
			if params.VideoNote.File != nil {
				var w io.Writer
				params.VideoNote.fieldName = "video_note"

				w, err = writer.CreateFormFile(
					params.VideoNote.fieldName,
					params.VideoNote.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.VideoNote.File)
				if err != nil {
					return
				}

				if closer, ok := params.VideoNote.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.VideoNote)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("video_note")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.Duration != 0 {
			v := strconv.FormatInt(params.Duration, 10)
			err = writer.WriteField("duration", v)
			if err != nil {
				return
			}
		}

		if params.Length != 0 {
			v := strconv.FormatInt(params.Length, 10)
			err = writer.WriteField("length", v)
			if err != nil {
				return
			}
		}

		if params.Thumbnail != nil {
			if params.Thumbnail.File != nil {
				var w io.Writer
				params.Thumbnail.fieldName = "thumbnail"

				w, err = writer.CreateFormFile(
					params.Thumbnail.fieldName,
					params.Thumbnail.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Thumbnail.File)
				if err != nil {
					return
				}

				if closer, ok := params.Thumbnail.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Thumbnail)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("thumbnail")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.DisableNotification {
			v := strconv.FormatBool(params.DisableNotification)
			err = writer.WriteField("disable_notification", v)
			if err != nil {
				return
			}
		}

		if params.ProtectContent {
			v := strconv.FormatBool(params.ProtectContent)
			err = writer.WriteField("protect_content", v)
			if err != nil {
				return
			}
		}

		if params.AllowPaidBroadcast {
			v := strconv.FormatBool(params.AllowPaidBroadcast)
			err = writer.WriteField("allow_paid_broadcast", v)
			if err != nil {
				return
			}
		}

		if params.MessageEffectID != "" {
			err = writer.WriteField("message_effect_id", params.MessageEffectID)
			if err != nil {
				return
			}
		}

		if params.SuggestedPostParameters != nil {

			bs, err = json.Marshal(params.SuggestedPostParameters)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("suggested_post_parameters")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ReplyParameters != nil {

			bs, err = json.Marshal(params.ReplyParameters)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("reply_parameters")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.ReplyMarkup != nil {

			bs, err = json.Marshal(params.ReplyMarkup)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("reply_markup")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

	}()

	contentType := writer.FormDataContentType()

	var result json.RawMessage

	result, err = c.Raw("sendVideoNote", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SendVoiceParams contains parameters for Client.SendVoice.
type SendVoiceParams struct {
	// Unique identifier of the business connection on behalf of which the message will be sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
	MessageThreadID int64 `json:"message_thread_id,omitempty"`

	// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
	DirectMessagesTopicID int64 `json:"direct_messages_topic_id,omitempty"`

	// Audio file to send.
	// Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a file from the Internet, or upload a new one using multipart/form-data.
	// [More information on Sending Files »]
	//
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Voice InputFile `json:"voice"`

	// Voice message caption, 0-1024 characters after entities parsing
	Caption string `json:"caption,omitempty"`

	// Mode for parsing entities in the voice message caption.
	// See [formatting options] for more details.
	//
	// [formatting options]: https://core.telegram.org/bots/api#formatting-options
	ParseMode string `json:"parse_mode,omitempty"`

	// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
	CaptionEntities []MessageEntity `json:"caption_entities,omitempty"`

	// Duration of the voice message in seconds
	Duration int64 `json:"duration,omitempty"`

	// Sends the message [silently].
	// Users will receive a notification with no sound.
	//
	// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
	DisableNotification bool `json:"disable_notification,omitempty"`

	// Protects the contents of the sent message from forwarding and saving
	ProtectContent bool `json:"protect_content,omitempty"`

	// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
	// The relevant Stars will be withdrawn from the bot's balance
	//
	// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
	AllowPaidBroadcast bool `json:"allow_paid_broadcast,omitempty"`

	// Unique identifier of the message effect to be added to the message; for private chats only
	MessageEffectID string `json:"message_effect_id,omitempty"`

	// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
	// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
	SuggestedPostParameters *SuggestedPostParameters `json:"suggested_post_parameters,omitempty"`

	// Description of the message to reply to
	ReplyParameters *ReplyParameters `json:"reply_parameters,omitempty"`

	// Additional interface options.
	// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
	ReplyMarkup *ReplyMarkup `json:"reply_markup,omitempty"`
}

// SendVoiceOption configures SendVoiceParams.
type SendVoiceOption func(params *SendVoiceParams) SendVoiceOption

// Option applies one or more SendVoiceOption values and returns the last rollback option.
func (r *SendVoiceParams) Option(opts ...SendVoiceOption) (previous SendVoiceOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSendVoiceBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be sent
func WithSendVoiceBusinessConnectionID(value string) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSendVoiceBusinessConnectionID(previous)
	}
}

// WithSendVoiceChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSendVoiceChatID(value string) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSendVoiceChatID(previous)
	}
}

// WithSendVoiceMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread (topic) of a forum; for forum supergroups and private chats of bots with forum topic mode enabled only
func WithSendVoiceMessageThreadID(value int64) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithSendVoiceMessageThreadID(previous)
	}
}

// WithSendVoiceDirectMessagesTopicID sets the DirectMessagesTopicID field.
//
// Identifier of the direct messages topic to which the message will be sent; required if the message is sent to a direct messages chat
func WithSendVoiceDirectMessagesTopicID(value int64) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.DirectMessagesTopicID
		params.DirectMessagesTopicID = value

		return WithSendVoiceDirectMessagesTopicID(previous)
	}
}

// WithSendVoiceVoice sets the Voice field.
//
// Audio file to send.
// Pass a file_id as String to send a file that exists on the Telegram servers (recommended), pass an HTTP URL as a String for Telegram to get a file from the Internet, or upload a new one using multipart/form-data.
// [More information on Sending Files »]
//
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSendVoiceVoice(value InputFile) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.Voice
		params.Voice = value

		return WithSendVoiceVoice(previous)
	}
}

// WithSendVoiceCaption sets the Caption field.
//
// Voice message caption, 0-1024 characters after entities parsing
func WithSendVoiceCaption(value string) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.Caption
		params.Caption = value

		return WithSendVoiceCaption(previous)
	}
}

// WithSendVoiceParseMode sets the ParseMode field.
//
// Mode for parsing entities in the voice message caption.
// See [formatting options] for more details.
//
// [formatting options]: https://core.telegram.org/bots/api#formatting-options
func WithSendVoiceParseMode(value string) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.ParseMode
		params.ParseMode = value

		return WithSendVoiceParseMode(previous)
	}
}

// WithSendVoiceCaptionEntities sets the CaptionEntities field.
//
// A JSON-serialized list of special entities that appear in the caption, which can be specified instead of parse_mode
func WithSendVoiceCaptionEntities(value []MessageEntity) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.CaptionEntities
		params.CaptionEntities = value

		return WithSendVoiceCaptionEntities(previous)
	}
}

// WithSendVoiceDuration sets the Duration field.
//
// Duration of the voice message in seconds
func WithSendVoiceDuration(value int64) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.Duration
		params.Duration = value

		return WithSendVoiceDuration(previous)
	}
}

// WithSendVoiceDisableNotification sets the DisableNotification field.
//
// Sends the message [silently].
// Users will receive a notification with no sound.
//
// [silently]: https://telegram.org/blog/channels-2-0#silent-messages
func WithSendVoiceDisableNotification(value bool) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.DisableNotification
		params.DisableNotification = value

		return WithSendVoiceDisableNotification(previous)
	}
}

// WithSendVoiceProtectContent sets the ProtectContent field.
//
// Protects the contents of the sent message from forwarding and saving
func WithSendVoiceProtectContent(value bool) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.ProtectContent
		params.ProtectContent = value

		return WithSendVoiceProtectContent(previous)
	}
}

// WithSendVoiceAllowPaidBroadcast sets the AllowPaidBroadcast field.
//
// Pass True to allow up to 1000 messages per second, ignoring [broadcasting limits] for a fee of 0.1 Telegram Stars per message.
// The relevant Stars will be withdrawn from the bot's balance
//
// [broadcasting limits]: https://core.telegram.org/bots/faq#how-can-i-message-all-of-my-bot-39s-subscribers-at-once
func WithSendVoiceAllowPaidBroadcast(value bool) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.AllowPaidBroadcast
		params.AllowPaidBroadcast = value

		return WithSendVoiceAllowPaidBroadcast(previous)
	}
}

// WithSendVoiceMessageEffectID sets the MessageEffectID field.
//
// Unique identifier of the message effect to be added to the message; for private chats only
func WithSendVoiceMessageEffectID(value string) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.MessageEffectID
		params.MessageEffectID = value

		return WithSendVoiceMessageEffectID(previous)
	}
}

// WithSendVoiceSuggestedPostParameters sets the SuggestedPostParameters field.
//
// A JSON-serialized object containing the parameters of the suggested post to send; for direct messages chats only.
// If the message is sent as a reply to another suggested post, then that suggested post is automatically declined.
func WithSendVoiceSuggestedPostParameters(value *SuggestedPostParameters) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.SuggestedPostParameters
		params.SuggestedPostParameters = value

		return WithSendVoiceSuggestedPostParameters(previous)
	}
}

// WithSendVoiceReplyParameters sets the ReplyParameters field.
//
// Description of the message to reply to
func WithSendVoiceReplyParameters(value *ReplyParameters) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.ReplyParameters
		params.ReplyParameters = value

		return WithSendVoiceReplyParameters(previous)
	}
}

// WithSendVoiceReplyMarkup sets the ReplyMarkup field.
//
// Additional interface options.
// A JSON-serialized object for an [inline keyboard], [custom reply keyboard], instructions to remove a reply keyboard or to force a reply from the user
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
// [custom reply keyboard]: https://core.telegram.org/bots/features#keyboards
func WithSendVoiceReplyMarkup(value *ReplyMarkup) SendVoiceOption {
	return func(params *SendVoiceParams) SendVoiceOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithSendVoiceReplyMarkup(previous)
	}
}

// SendVoice calls the sendVoice Telegram Bot API method.
//
// Use this method to send audio files, if you want Telegram clients to display the file as a playable voice message.
// For this to work, your audio must be in an .OGG file encoded with OPUS, or in .MP3 format, or in .M4A format (other formats may be sent as [Audio] or [Document]).
// On success, the sent [Message] is returned.
// Bots can currently send voice messages of up to 50 MB in size, this limit may be changed in the future.
//
// [Audio]: https://core.telegram.org/bots/api#audio
// [Document]: https://core.telegram.org/bots/api#document
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SendVoice(params *SendVoiceParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("sendVoice", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetBusinessAccountBioParams contains parameters for Client.SetBusinessAccountBio.
type SetBusinessAccountBioParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// The new value of the bio for the business account; 0-140 characters
	Bio string `json:"bio,omitempty"`
}

// SetBusinessAccountBioOption configures SetBusinessAccountBioParams.
type SetBusinessAccountBioOption func(params *SetBusinessAccountBioParams) SetBusinessAccountBioOption

// Option applies one or more SetBusinessAccountBioOption values and returns the last rollback option.
func (r *SetBusinessAccountBioParams) Option(opts ...SetBusinessAccountBioOption) (previous SetBusinessAccountBioOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetBusinessAccountBioBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithSetBusinessAccountBioBusinessConnectionID(value string) SetBusinessAccountBioOption {
	return func(params *SetBusinessAccountBioParams) SetBusinessAccountBioOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSetBusinessAccountBioBusinessConnectionID(previous)
	}
}

// WithSetBusinessAccountBioBio sets the Bio field.
//
// The new value of the bio for the business account; 0-140 characters
func WithSetBusinessAccountBioBio(value string) SetBusinessAccountBioOption {
	return func(params *SetBusinessAccountBioParams) SetBusinessAccountBioOption {
		previous := params.Bio
		params.Bio = value

		return WithSetBusinessAccountBioBio(previous)
	}
}

// SetBusinessAccountBio calls the setBusinessAccountBio Telegram Bot API method.
//
// Changes the bio of a managed business account.
// Requires the can_change_bio business bot right.
// Returns True on success.
func (c *Client) SetBusinessAccountBio(params *SetBusinessAccountBioParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setBusinessAccountBio", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetBusinessAccountGiftSettingsParams contains parameters for Client.SetBusinessAccountGiftSettings.
type SetBusinessAccountGiftSettingsParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// Pass True, if a button for sending a gift to the user or by the business account must always be shown in the input field
	ShowGiftButton bool `json:"show_gift_button"`

	// Types of gifts accepted by the business account
	AcceptedGiftTypes AcceptedGiftTypes `json:"accepted_gift_types"`
}

// SetBusinessAccountGiftSettingsOption configures SetBusinessAccountGiftSettingsParams.
type SetBusinessAccountGiftSettingsOption func(params *SetBusinessAccountGiftSettingsParams) SetBusinessAccountGiftSettingsOption

// Option applies one or more SetBusinessAccountGiftSettingsOption values and returns the last rollback option.
func (r *SetBusinessAccountGiftSettingsParams) Option(opts ...SetBusinessAccountGiftSettingsOption) (previous SetBusinessAccountGiftSettingsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetBusinessAccountGiftSettingsBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithSetBusinessAccountGiftSettingsBusinessConnectionID(value string) SetBusinessAccountGiftSettingsOption {
	return func(params *SetBusinessAccountGiftSettingsParams) SetBusinessAccountGiftSettingsOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSetBusinessAccountGiftSettingsBusinessConnectionID(previous)
	}
}

// WithSetBusinessAccountGiftSettingsShowGiftButton sets the ShowGiftButton field.
//
// Pass True, if a button for sending a gift to the user or by the business account must always be shown in the input field
func WithSetBusinessAccountGiftSettingsShowGiftButton(value bool) SetBusinessAccountGiftSettingsOption {
	return func(params *SetBusinessAccountGiftSettingsParams) SetBusinessAccountGiftSettingsOption {
		previous := params.ShowGiftButton
		params.ShowGiftButton = value

		return WithSetBusinessAccountGiftSettingsShowGiftButton(previous)
	}
}

// WithSetBusinessAccountGiftSettingsAcceptedGiftTypes sets the AcceptedGiftTypes field.
//
// Types of gifts accepted by the business account
func WithSetBusinessAccountGiftSettingsAcceptedGiftTypes(value AcceptedGiftTypes) SetBusinessAccountGiftSettingsOption {
	return func(params *SetBusinessAccountGiftSettingsParams) SetBusinessAccountGiftSettingsOption {
		previous := params.AcceptedGiftTypes
		params.AcceptedGiftTypes = value

		return WithSetBusinessAccountGiftSettingsAcceptedGiftTypes(previous)
	}
}

// SetBusinessAccountGiftSettings calls the setBusinessAccountGiftSettings Telegram Bot API method.
//
// Changes the privacy settings pertaining to incoming gifts in a managed business account.
// Requires the can_change_gift_settings business bot right.
// Returns True on success.
func (c *Client) SetBusinessAccountGiftSettings(params *SetBusinessAccountGiftSettingsParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setBusinessAccountGiftSettings", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetBusinessAccountNameParams contains parameters for Client.SetBusinessAccountName.
type SetBusinessAccountNameParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// The new value of the first name for the business account; 1-64 characters
	FirstName string `json:"first_name"`

	// The new value of the last name for the business account; 0-64 characters
	LastName string `json:"last_name,omitempty"`
}

// SetBusinessAccountNameOption configures SetBusinessAccountNameParams.
type SetBusinessAccountNameOption func(params *SetBusinessAccountNameParams) SetBusinessAccountNameOption

// Option applies one or more SetBusinessAccountNameOption values and returns the last rollback option.
func (r *SetBusinessAccountNameParams) Option(opts ...SetBusinessAccountNameOption) (previous SetBusinessAccountNameOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetBusinessAccountNameBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithSetBusinessAccountNameBusinessConnectionID(value string) SetBusinessAccountNameOption {
	return func(params *SetBusinessAccountNameParams) SetBusinessAccountNameOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSetBusinessAccountNameBusinessConnectionID(previous)
	}
}

// WithSetBusinessAccountNameFirstName sets the FirstName field.
//
// The new value of the first name for the business account; 1-64 characters
func WithSetBusinessAccountNameFirstName(value string) SetBusinessAccountNameOption {
	return func(params *SetBusinessAccountNameParams) SetBusinessAccountNameOption {
		previous := params.FirstName
		params.FirstName = value

		return WithSetBusinessAccountNameFirstName(previous)
	}
}

// WithSetBusinessAccountNameLastName sets the LastName field.
//
// The new value of the last name for the business account; 0-64 characters
func WithSetBusinessAccountNameLastName(value string) SetBusinessAccountNameOption {
	return func(params *SetBusinessAccountNameParams) SetBusinessAccountNameOption {
		previous := params.LastName
		params.LastName = value

		return WithSetBusinessAccountNameLastName(previous)
	}
}

// SetBusinessAccountName calls the setBusinessAccountName Telegram Bot API method.
//
// Changes the first and last name of a managed business account.
// Requires the can_change_name business bot right.
// Returns True on success.
func (c *Client) SetBusinessAccountName(params *SetBusinessAccountNameParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setBusinessAccountName", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetBusinessAccountProfilePhotoParams contains parameters for Client.SetBusinessAccountProfilePhoto.
type SetBusinessAccountProfilePhotoParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// The new profile photo to set
	Photo InputProfilePhoto `json:"photo"`

	// Pass True to set the public photo, which will be visible even if the main photo is hidden by the business account's privacy settings.
	// An account can have only one public photo.
	IsPublic bool `json:"is_public,omitempty"`
}

// SetBusinessAccountProfilePhotoOption configures SetBusinessAccountProfilePhotoParams.
type SetBusinessAccountProfilePhotoOption func(params *SetBusinessAccountProfilePhotoParams) SetBusinessAccountProfilePhotoOption

// Option applies one or more SetBusinessAccountProfilePhotoOption values and returns the last rollback option.
func (r *SetBusinessAccountProfilePhotoParams) Option(opts ...SetBusinessAccountProfilePhotoOption) (previous SetBusinessAccountProfilePhotoOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetBusinessAccountProfilePhotoBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithSetBusinessAccountProfilePhotoBusinessConnectionID(value string) SetBusinessAccountProfilePhotoOption {
	return func(params *SetBusinessAccountProfilePhotoParams) SetBusinessAccountProfilePhotoOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSetBusinessAccountProfilePhotoBusinessConnectionID(previous)
	}
}

// WithSetBusinessAccountProfilePhotoPhoto sets the Photo field.
//
// The new profile photo to set
func WithSetBusinessAccountProfilePhotoPhoto(value InputProfilePhoto) SetBusinessAccountProfilePhotoOption {
	return func(params *SetBusinessAccountProfilePhotoParams) SetBusinessAccountProfilePhotoOption {
		previous := params.Photo
		params.Photo = value

		return WithSetBusinessAccountProfilePhotoPhoto(previous)
	}
}

// WithSetBusinessAccountProfilePhotoIsPublic sets the IsPublic field.
//
// Pass True to set the public photo, which will be visible even if the main photo is hidden by the business account's privacy settings.
// An account can have only one public photo.
func WithSetBusinessAccountProfilePhotoIsPublic(value bool) SetBusinessAccountProfilePhotoOption {
	return func(params *SetBusinessAccountProfilePhotoParams) SetBusinessAccountProfilePhotoOption {
		previous := params.IsPublic
		params.IsPublic = value

		return WithSetBusinessAccountProfilePhotoIsPublic(previous)
	}
}

// SetBusinessAccountProfilePhoto calls the setBusinessAccountProfilePhoto Telegram Bot API method.
//
// Changes the profile photo of a managed business account.
// Requires the can_edit_profile_photo business bot right.
// Returns True on success.
func (c *Client) SetBusinessAccountProfilePhoto(params *SetBusinessAccountProfilePhotoParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setBusinessAccountProfilePhoto", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetBusinessAccountUsernameParams contains parameters for Client.SetBusinessAccountUsername.
type SetBusinessAccountUsernameParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// The new value of the username for the business account; 0-32 characters
	Username string `json:"username,omitempty"`
}

// SetBusinessAccountUsernameOption configures SetBusinessAccountUsernameParams.
type SetBusinessAccountUsernameOption func(params *SetBusinessAccountUsernameParams) SetBusinessAccountUsernameOption

// Option applies one or more SetBusinessAccountUsernameOption values and returns the last rollback option.
func (r *SetBusinessAccountUsernameParams) Option(opts ...SetBusinessAccountUsernameOption) (previous SetBusinessAccountUsernameOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetBusinessAccountUsernameBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithSetBusinessAccountUsernameBusinessConnectionID(value string) SetBusinessAccountUsernameOption {
	return func(params *SetBusinessAccountUsernameParams) SetBusinessAccountUsernameOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithSetBusinessAccountUsernameBusinessConnectionID(previous)
	}
}

// WithSetBusinessAccountUsernameUsername sets the Username field.
//
// The new value of the username for the business account; 0-32 characters
func WithSetBusinessAccountUsernameUsername(value string) SetBusinessAccountUsernameOption {
	return func(params *SetBusinessAccountUsernameParams) SetBusinessAccountUsernameOption {
		previous := params.Username
		params.Username = value

		return WithSetBusinessAccountUsernameUsername(previous)
	}
}

// SetBusinessAccountUsername calls the setBusinessAccountUsername Telegram Bot API method.
//
// Changes the username of a managed business account.
// Requires the can_change_username business bot right.
// Returns True on success.
func (c *Client) SetBusinessAccountUsername(params *SetBusinessAccountUsernameParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setBusinessAccountUsername", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetChatAdministratorCustomTitleParams contains parameters for Client.SetChatAdministratorCustomTitle.
type SetChatAdministratorCustomTitleParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int64 `json:"user_id"`

	// New custom title for the administrator; 0-16 characters, emoji are not allowed
	CustomTitle string `json:"custom_title"`
}

// SetChatAdministratorCustomTitleOption configures SetChatAdministratorCustomTitleParams.
type SetChatAdministratorCustomTitleOption func(params *SetChatAdministratorCustomTitleParams) SetChatAdministratorCustomTitleOption

// Option applies one or more SetChatAdministratorCustomTitleOption values and returns the last rollback option.
func (r *SetChatAdministratorCustomTitleParams) Option(opts ...SetChatAdministratorCustomTitleOption) (previous SetChatAdministratorCustomTitleOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetChatAdministratorCustomTitleChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithSetChatAdministratorCustomTitleChatID(value string) SetChatAdministratorCustomTitleOption {
	return func(params *SetChatAdministratorCustomTitleParams) SetChatAdministratorCustomTitleOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSetChatAdministratorCustomTitleChatID(previous)
	}
}

// WithSetChatAdministratorCustomTitleUserID sets the UserID field.
//
// Unique identifier of the target user
func WithSetChatAdministratorCustomTitleUserID(value int64) SetChatAdministratorCustomTitleOption {
	return func(params *SetChatAdministratorCustomTitleParams) SetChatAdministratorCustomTitleOption {
		previous := params.UserID
		params.UserID = value

		return WithSetChatAdministratorCustomTitleUserID(previous)
	}
}

// WithSetChatAdministratorCustomTitleCustomTitle sets the CustomTitle field.
//
// New custom title for the administrator; 0-16 characters, emoji are not allowed
func WithSetChatAdministratorCustomTitleCustomTitle(value string) SetChatAdministratorCustomTitleOption {
	return func(params *SetChatAdministratorCustomTitleParams) SetChatAdministratorCustomTitleOption {
		previous := params.CustomTitle
		params.CustomTitle = value

		return WithSetChatAdministratorCustomTitleCustomTitle(previous)
	}
}

// SetChatAdministratorCustomTitle calls the setChatAdministratorCustomTitle Telegram Bot API method.
//
// Use this method to set a custom title for an administrator in a supergroup promoted by the bot.
// Returns True on success.
func (c *Client) SetChatAdministratorCustomTitle(params *SetChatAdministratorCustomTitleParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setChatAdministratorCustomTitle", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetChatDescriptionParams contains parameters for Client.SetChatDescription.
type SetChatDescriptionParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// New chat description, 0-255 characters
	Description string `json:"description,omitempty"`
}

// SetChatDescriptionOption configures SetChatDescriptionParams.
type SetChatDescriptionOption func(params *SetChatDescriptionParams) SetChatDescriptionOption

// Option applies one or more SetChatDescriptionOption values and returns the last rollback option.
func (r *SetChatDescriptionParams) Option(opts ...SetChatDescriptionOption) (previous SetChatDescriptionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetChatDescriptionChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSetChatDescriptionChatID(value string) SetChatDescriptionOption {
	return func(params *SetChatDescriptionParams) SetChatDescriptionOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSetChatDescriptionChatID(previous)
	}
}

// WithSetChatDescriptionDescription sets the Description field.
//
// New chat description, 0-255 characters
func WithSetChatDescriptionDescription(value string) SetChatDescriptionOption {
	return func(params *SetChatDescriptionParams) SetChatDescriptionOption {
		previous := params.Description
		params.Description = value

		return WithSetChatDescriptionDescription(previous)
	}
}

// SetChatDescription calls the setChatDescription Telegram Bot API method.
//
// Use this method to change the description of a group, a supergroup or a channel.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns True on success.
func (c *Client) SetChatDescription(params *SetChatDescriptionParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setChatDescription", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetChatMemberTagParams contains parameters for Client.SetChatMemberTag.
type SetChatMemberTagParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int64 `json:"user_id"`

	// New tag for the member; 0-16 characters, emoji are not allowed
	Tag string `json:"tag,omitempty"`
}

// SetChatMemberTagOption configures SetChatMemberTagParams.
type SetChatMemberTagOption func(params *SetChatMemberTagParams) SetChatMemberTagOption

// Option applies one or more SetChatMemberTagOption values and returns the last rollback option.
func (r *SetChatMemberTagParams) Option(opts ...SetChatMemberTagOption) (previous SetChatMemberTagOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetChatMemberTagChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithSetChatMemberTagChatID(value string) SetChatMemberTagOption {
	return func(params *SetChatMemberTagParams) SetChatMemberTagOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSetChatMemberTagChatID(previous)
	}
}

// WithSetChatMemberTagUserID sets the UserID field.
//
// Unique identifier of the target user
func WithSetChatMemberTagUserID(value int64) SetChatMemberTagOption {
	return func(params *SetChatMemberTagParams) SetChatMemberTagOption {
		previous := params.UserID
		params.UserID = value

		return WithSetChatMemberTagUserID(previous)
	}
}

// WithSetChatMemberTagTag sets the Tag field.
//
// New tag for the member; 0-16 characters, emoji are not allowed
func WithSetChatMemberTagTag(value string) SetChatMemberTagOption {
	return func(params *SetChatMemberTagParams) SetChatMemberTagOption {
		previous := params.Tag
		params.Tag = value

		return WithSetChatMemberTagTag(previous)
	}
}

// SetChatMemberTag calls the setChatMemberTag Telegram Bot API method.
//
// Use this method to set a tag for a regular member in a group or a supergroup.
// The bot must be an administrator in the chat for this to work and must have the can_manage_tags administrator right.
// Returns True on success.
func (c *Client) SetChatMemberTag(params *SetChatMemberTagParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setChatMemberTag", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetChatMenuButtonParams contains parameters for Client.SetChatMenuButton.
type SetChatMenuButtonParams struct {
	// Unique identifier for the target private chat.
	// If not specified, default bot's menu button will be changed
	ChatID int64 `json:"chat_id,omitempty"`

	// A JSON-serialized object for the bot's new menu button.
	// Defaults to [MenuButtonDefault]
	//
	// [MenuButtonDefault]: https://core.telegram.org/bots/api#menubuttondefault
	MenuButton *MenuButton `json:"menu_button,omitempty"`
}

// SetChatMenuButtonOption configures SetChatMenuButtonParams.
type SetChatMenuButtonOption func(params *SetChatMenuButtonParams) SetChatMenuButtonOption

// Option applies one or more SetChatMenuButtonOption values and returns the last rollback option.
func (r *SetChatMenuButtonParams) Option(opts ...SetChatMenuButtonOption) (previous SetChatMenuButtonOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetChatMenuButtonChatID sets the ChatID field.
//
// Unique identifier for the target private chat.
// If not specified, default bot's menu button will be changed
func WithSetChatMenuButtonChatID(value int64) SetChatMenuButtonOption {
	return func(params *SetChatMenuButtonParams) SetChatMenuButtonOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSetChatMenuButtonChatID(previous)
	}
}

// WithSetChatMenuButtonMenuButton sets the MenuButton field.
//
// A JSON-serialized object for the bot's new menu button.
// Defaults to [MenuButtonDefault]
//
// [MenuButtonDefault]: https://core.telegram.org/bots/api#menubuttondefault
func WithSetChatMenuButtonMenuButton(value *MenuButton) SetChatMenuButtonOption {
	return func(params *SetChatMenuButtonParams) SetChatMenuButtonOption {
		previous := params.MenuButton
		params.MenuButton = value

		return WithSetChatMenuButtonMenuButton(previous)
	}
}

// SetChatMenuButton calls the setChatMenuButton Telegram Bot API method.
//
// Use this method to change the bot's menu button in a private chat, or the default menu button.
// Returns True on success.
func (c *Client) SetChatMenuButton(params *SetChatMenuButtonParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setChatMenuButton", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetChatPermissionsParams contains parameters for Client.SetChatPermissions.
type SetChatPermissionsParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// A JSON-serialized object for new default chat permissions
	Permissions ChatPermissions `json:"permissions"`

	// Pass True if chat permissions are set independently.
	// Otherwise, the can_send_other_messages and can_add_web_page_previews permissions will imply the can_send_messages, can_send_audios, can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, and can_send_voice_notes permissions; the can_send_polls permission will imply the can_send_messages permission.
	UseIndependentChatPermissions bool `json:"use_independent_chat_permissions,omitempty"`
}

// SetChatPermissionsOption configures SetChatPermissionsParams.
type SetChatPermissionsOption func(params *SetChatPermissionsParams) SetChatPermissionsOption

// Option applies one or more SetChatPermissionsOption values and returns the last rollback option.
func (r *SetChatPermissionsParams) Option(opts ...SetChatPermissionsOption) (previous SetChatPermissionsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetChatPermissionsChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithSetChatPermissionsChatID(value string) SetChatPermissionsOption {
	return func(params *SetChatPermissionsParams) SetChatPermissionsOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSetChatPermissionsChatID(previous)
	}
}

// WithSetChatPermissionsPermissions sets the Permissions field.
//
// A JSON-serialized object for new default chat permissions
func WithSetChatPermissionsPermissions(value ChatPermissions) SetChatPermissionsOption {
	return func(params *SetChatPermissionsParams) SetChatPermissionsOption {
		previous := params.Permissions
		params.Permissions = value

		return WithSetChatPermissionsPermissions(previous)
	}
}

// WithSetChatPermissionsUseIndependentChatPermissions sets the UseIndependentChatPermissions field.
//
// Pass True if chat permissions are set independently.
// Otherwise, the can_send_other_messages and can_add_web_page_previews permissions will imply the can_send_messages, can_send_audios, can_send_documents, can_send_photos, can_send_videos, can_send_video_notes, and can_send_voice_notes permissions; the can_send_polls permission will imply the can_send_messages permission.
func WithSetChatPermissionsUseIndependentChatPermissions(value bool) SetChatPermissionsOption {
	return func(params *SetChatPermissionsParams) SetChatPermissionsOption {
		previous := params.UseIndependentChatPermissions
		params.UseIndependentChatPermissions = value

		return WithSetChatPermissionsUseIndependentChatPermissions(previous)
	}
}

// SetChatPermissions calls the setChatPermissions Telegram Bot API method.
//
// Use this method to set default chat permissions for all members.
// The bot must be an administrator in the group or a supergroup for this to work and must have the can_restrict_members administrator rights.
// Returns True on success.
func (c *Client) SetChatPermissions(params *SetChatPermissionsParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setChatPermissions", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetChatPhotoParams contains parameters for Client.SetChatPhoto.
type SetChatPhotoParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// New chat photo, uploaded using multipart/form-data
	Photo InputFile `json:"photo"`
}

// SetChatPhotoOption configures SetChatPhotoParams.
type SetChatPhotoOption func(params *SetChatPhotoParams) SetChatPhotoOption

// Option applies one or more SetChatPhotoOption values and returns the last rollback option.
func (r *SetChatPhotoParams) Option(opts ...SetChatPhotoOption) (previous SetChatPhotoOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetChatPhotoChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSetChatPhotoChatID(value string) SetChatPhotoOption {
	return func(params *SetChatPhotoParams) SetChatPhotoOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSetChatPhotoChatID(previous)
	}
}

// WithSetChatPhotoPhoto sets the Photo field.
//
// New chat photo, uploaded using multipart/form-data
func WithSetChatPhotoPhoto(value InputFile) SetChatPhotoOption {
	return func(params *SetChatPhotoParams) SetChatPhotoOption {
		previous := params.Photo
		params.Photo = value

		return WithSetChatPhotoPhoto(previous)
	}
}

// SetChatPhoto calls the setChatPhoto Telegram Bot API method.
//
// Use this method to set a new profile photo for the chat.
// Photos can't be changed for private chats.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns True on success.
func (c *Client) SetChatPhoto(params *SetChatPhotoParams) (ret bool, err error) {
	var bs []byte

	reader, pw := io.Pipe()
	writer := multipart.NewWriter(pw)

	go func() {
		defer pw.Close()
		defer writer.Close()

		{
			err = writer.WriteField("chat_id", params.ChatID)
			if err != nil {
				return
			}
		}

		{
			if params.Photo.File != nil {
				var w io.Writer
				params.Photo.fieldName = "photo"

				w, err = writer.CreateFormFile(
					params.Photo.fieldName,
					params.Photo.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Photo.File)
				if err != nil {
					return
				}

				if closer, ok := params.Photo.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Photo)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("photo")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

	}()

	contentType := writer.FormDataContentType()

	var result json.RawMessage

	result, err = c.Raw("setChatPhoto", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetChatStickerSetParams contains parameters for Client.SetChatStickerSet.
type SetChatStickerSetParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Name of the sticker set to be set as the group sticker set
	StickerSetName string `json:"sticker_set_name"`
}

// SetChatStickerSetOption configures SetChatStickerSetParams.
type SetChatStickerSetOption func(params *SetChatStickerSetParams) SetChatStickerSetOption

// Option applies one or more SetChatStickerSetOption values and returns the last rollback option.
func (r *SetChatStickerSetParams) Option(opts ...SetChatStickerSetOption) (previous SetChatStickerSetOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetChatStickerSetChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithSetChatStickerSetChatID(value string) SetChatStickerSetOption {
	return func(params *SetChatStickerSetParams) SetChatStickerSetOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSetChatStickerSetChatID(previous)
	}
}

// WithSetChatStickerSetStickerSetName sets the StickerSetName field.
//
// Name of the sticker set to be set as the group sticker set
func WithSetChatStickerSetStickerSetName(value string) SetChatStickerSetOption {
	return func(params *SetChatStickerSetParams) SetChatStickerSetOption {
		previous := params.StickerSetName
		params.StickerSetName = value

		return WithSetChatStickerSetStickerSetName(previous)
	}
}

// SetChatStickerSet calls the setChatStickerSet Telegram Bot API method.
//
// Use this method to set a new group sticker set for a supergroup.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// Use the field can_set_sticker_set optionally returned in [getChat] requests to check if the bot can use this method.
// Returns True on success.
//
// [getChat]: https://core.telegram.org/bots/api#getchat
func (c *Client) SetChatStickerSet(params *SetChatStickerSetParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setChatStickerSet", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetChatTitleParams contains parameters for Client.SetChatTitle.
type SetChatTitleParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// New chat title, 1-128 characters
	Title string `json:"title"`
}

// SetChatTitleOption configures SetChatTitleParams.
type SetChatTitleOption func(params *SetChatTitleParams) SetChatTitleOption

// Option applies one or more SetChatTitleOption values and returns the last rollback option.
func (r *SetChatTitleParams) Option(opts ...SetChatTitleOption) (previous SetChatTitleOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetChatTitleChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSetChatTitleChatID(value string) SetChatTitleOption {
	return func(params *SetChatTitleParams) SetChatTitleOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSetChatTitleChatID(previous)
	}
}

// WithSetChatTitleTitle sets the Title field.
//
// New chat title, 1-128 characters
func WithSetChatTitleTitle(value string) SetChatTitleOption {
	return func(params *SetChatTitleParams) SetChatTitleOption {
		previous := params.Title
		params.Title = value

		return WithSetChatTitleTitle(previous)
	}
}

// SetChatTitle calls the setChatTitle Telegram Bot API method.
//
// Use this method to change the title of a chat.
// Titles can't be changed for private chats.
// The bot must be an administrator in the chat for this to work and must have the appropriate administrator rights.
// Returns True on success.
func (c *Client) SetChatTitle(params *SetChatTitleParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setChatTitle", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetCustomEmojiStickerSetThumbnailParams contains parameters for Client.SetCustomEmojiStickerSetThumbnail.
type SetCustomEmojiStickerSetThumbnailParams struct {
	// Sticker set name
	Name string `json:"name"`

	// Custom emoji identifier of a sticker from the sticker set; pass an empty string to drop the thumbnail and use the first sticker as the thumbnail.
	CustomEmojiID string `json:"custom_emoji_id,omitempty"`
}

// SetCustomEmojiStickerSetThumbnailOption configures SetCustomEmojiStickerSetThumbnailParams.
type SetCustomEmojiStickerSetThumbnailOption func(params *SetCustomEmojiStickerSetThumbnailParams) SetCustomEmojiStickerSetThumbnailOption

// Option applies one or more SetCustomEmojiStickerSetThumbnailOption values and returns the last rollback option.
func (r *SetCustomEmojiStickerSetThumbnailParams) Option(opts ...SetCustomEmojiStickerSetThumbnailOption) (previous SetCustomEmojiStickerSetThumbnailOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetCustomEmojiStickerSetThumbnailName sets the Name field.
//
// Sticker set name
func WithSetCustomEmojiStickerSetThumbnailName(value string) SetCustomEmojiStickerSetThumbnailOption {
	return func(params *SetCustomEmojiStickerSetThumbnailParams) SetCustomEmojiStickerSetThumbnailOption {
		previous := params.Name
		params.Name = value

		return WithSetCustomEmojiStickerSetThumbnailName(previous)
	}
}

// WithSetCustomEmojiStickerSetThumbnailCustomEmojiID sets the CustomEmojiID field.
//
// Custom emoji identifier of a sticker from the sticker set; pass an empty string to drop the thumbnail and use the first sticker as the thumbnail.
func WithSetCustomEmojiStickerSetThumbnailCustomEmojiID(value string) SetCustomEmojiStickerSetThumbnailOption {
	return func(params *SetCustomEmojiStickerSetThumbnailParams) SetCustomEmojiStickerSetThumbnailOption {
		previous := params.CustomEmojiID
		params.CustomEmojiID = value

		return WithSetCustomEmojiStickerSetThumbnailCustomEmojiID(previous)
	}
}

// SetCustomEmojiStickerSetThumbnail calls the setCustomEmojiStickerSetThumbnail Telegram Bot API method.
//
// Use this method to set the thumbnail of a custom emoji sticker set.
// Returns True on success.
func (c *Client) SetCustomEmojiStickerSetThumbnail(params *SetCustomEmojiStickerSetThumbnailParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setCustomEmojiStickerSetThumbnail", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetGameScoreParams contains parameters for Client.SetGameScore.
type SetGameScoreParams struct {
	// User identifier
	UserID int64 `json:"user_id"`

	// New score, must be non-negative
	Score int64 `json:"score"`

	// Pass True if the high score is allowed to decrease.
	// This can be useful when fixing mistakes or banning cheaters
	Force bool `json:"force,omitempty"`

	// Pass True if the game message should not be automatically edited to include the current scoreboard
	DisableEditMessage bool `json:"disable_edit_message,omitempty"`

	// Required if inline_message_id is not specified.
	// Unique identifier for the target chat
	ChatID int64 `json:"chat_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Identifier of the sent message
	MessageID int64 `json:"message_id,omitempty"`

	// Required if chat_id and message_id are not specified.
	// Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`
}

// SetGameScoreOption configures SetGameScoreParams.
type SetGameScoreOption func(params *SetGameScoreParams) SetGameScoreOption

// Option applies one or more SetGameScoreOption values and returns the last rollback option.
func (r *SetGameScoreParams) Option(opts ...SetGameScoreOption) (previous SetGameScoreOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetGameScoreUserID sets the UserID field.
//
// User identifier
func WithSetGameScoreUserID(value int64) SetGameScoreOption {
	return func(params *SetGameScoreParams) SetGameScoreOption {
		previous := params.UserID
		params.UserID = value

		return WithSetGameScoreUserID(previous)
	}
}

// WithSetGameScoreScore sets the Score field.
//
// New score, must be non-negative
func WithSetGameScoreScore(value int64) SetGameScoreOption {
	return func(params *SetGameScoreParams) SetGameScoreOption {
		previous := params.Score
		params.Score = value

		return WithSetGameScoreScore(previous)
	}
}

// WithSetGameScoreForce sets the Force field.
//
// Pass True if the high score is allowed to decrease.
// This can be useful when fixing mistakes or banning cheaters
func WithSetGameScoreForce(value bool) SetGameScoreOption {
	return func(params *SetGameScoreParams) SetGameScoreOption {
		previous := params.Force
		params.Force = value

		return WithSetGameScoreForce(previous)
	}
}

// WithSetGameScoreDisableEditMessage sets the DisableEditMessage field.
//
// Pass True if the game message should not be automatically edited to include the current scoreboard
func WithSetGameScoreDisableEditMessage(value bool) SetGameScoreOption {
	return func(params *SetGameScoreParams) SetGameScoreOption {
		previous := params.DisableEditMessage
		params.DisableEditMessage = value

		return WithSetGameScoreDisableEditMessage(previous)
	}
}

// WithSetGameScoreChatID sets the ChatID field.
//
// Required if inline_message_id is not specified.
// Unique identifier for the target chat
func WithSetGameScoreChatID(value int64) SetGameScoreOption {
	return func(params *SetGameScoreParams) SetGameScoreOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSetGameScoreChatID(previous)
	}
}

// WithSetGameScoreMessageID sets the MessageID field.
//
// Required if inline_message_id is not specified.
// Identifier of the sent message
func WithSetGameScoreMessageID(value int64) SetGameScoreOption {
	return func(params *SetGameScoreParams) SetGameScoreOption {
		previous := params.MessageID
		params.MessageID = value

		return WithSetGameScoreMessageID(previous)
	}
}

// WithSetGameScoreInlineMessageID sets the InlineMessageID field.
//
// Required if chat_id and message_id are not specified.
// Identifier of the inline message
func WithSetGameScoreInlineMessageID(value string) SetGameScoreOption {
	return func(params *SetGameScoreParams) SetGameScoreOption {
		previous := params.InlineMessageID
		params.InlineMessageID = value

		return WithSetGameScoreInlineMessageID(previous)
	}
}

// SetGameScore calls the setGameScore Telegram Bot API method.
//
// Use this method to set the score of the specified user in a game message.
// On success, if the message is not an inline message, the [Message] is returned, otherwise True is returned.
// Returns an error, if the new score is not greater than the user's current score in the chat and force is False.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) SetGameScore(params *SetGameScoreParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setGameScore", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetMessageReactionParams contains parameters for Client.SetMessageReaction.
type SetMessageReactionParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Identifier of the target message.
	// If the message belongs to a media group, the reaction is set to the first non-deleted message in the group instead.
	MessageID int64 `json:"message_id"`

	// A JSON-serialized list of reaction types to set on the message.
	// Currently, as non-premium users, bots can set up to one reaction per message.
	// A custom emoji reaction can be used if it is either already present on the message or explicitly allowed by chat administrators.
	// Paid reactions can't be used by bots.
	Reaction []ReactionType `json:"reaction,omitempty"`

	// Pass True to set the reaction with a big animation
	IsBig bool `json:"is_big,omitempty"`
}

// SetMessageReactionOption configures SetMessageReactionParams.
type SetMessageReactionOption func(params *SetMessageReactionParams) SetMessageReactionOption

// Option applies one or more SetMessageReactionOption values and returns the last rollback option.
func (r *SetMessageReactionParams) Option(opts ...SetMessageReactionOption) (previous SetMessageReactionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetMessageReactionChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithSetMessageReactionChatID(value string) SetMessageReactionOption {
	return func(params *SetMessageReactionParams) SetMessageReactionOption {
		previous := params.ChatID
		params.ChatID = value

		return WithSetMessageReactionChatID(previous)
	}
}

// WithSetMessageReactionMessageID sets the MessageID field.
//
// Identifier of the target message.
// If the message belongs to a media group, the reaction is set to the first non-deleted message in the group instead.
func WithSetMessageReactionMessageID(value int64) SetMessageReactionOption {
	return func(params *SetMessageReactionParams) SetMessageReactionOption {
		previous := params.MessageID
		params.MessageID = value

		return WithSetMessageReactionMessageID(previous)
	}
}

// WithSetMessageReactionReaction sets the Reaction field.
//
// A JSON-serialized list of reaction types to set on the message.
// Currently, as non-premium users, bots can set up to one reaction per message.
// A custom emoji reaction can be used if it is either already present on the message or explicitly allowed by chat administrators.
// Paid reactions can't be used by bots.
func WithSetMessageReactionReaction(value []ReactionType) SetMessageReactionOption {
	return func(params *SetMessageReactionParams) SetMessageReactionOption {
		previous := params.Reaction
		params.Reaction = value

		return WithSetMessageReactionReaction(previous)
	}
}

// WithSetMessageReactionIsBig sets the IsBig field.
//
// Pass True to set the reaction with a big animation
func WithSetMessageReactionIsBig(value bool) SetMessageReactionOption {
	return func(params *SetMessageReactionParams) SetMessageReactionOption {
		previous := params.IsBig
		params.IsBig = value

		return WithSetMessageReactionIsBig(previous)
	}
}

// SetMessageReaction calls the setMessageReaction Telegram Bot API method.
//
// Use this method to change the chosen reactions on a message.
// Service messages of some types can't be reacted to.
// Automatically forwarded messages from a channel to its discussion group have the same available reactions as messages in the channel.
// Bots can't use paid reactions.
// Returns True on success.
func (c *Client) SetMessageReaction(params *SetMessageReactionParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setMessageReaction", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetMyCommandsParams contains parameters for Client.SetMyCommands.
type SetMyCommandsParams struct {
	// A JSON-serialized list of bot commands to be set as the list of the bot's commands.
	// At most 100 commands can be specified.
	Commands []BotCommand `json:"commands"`

	// A JSON-serialized object, describing scope of users for which the commands are relevant.
	// Defaults to [BotCommandScopeDefault].
	//
	// [BotCommandScopeDefault]: https://core.telegram.org/bots/api#botcommandscopedefault
	Scope *BotCommandScope `json:"scope,omitempty"`

	// A two-letter ISO 639-1 language code.
	// If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands
	LanguageCode string `json:"language_code,omitempty"`
}

// SetMyCommandsOption configures SetMyCommandsParams.
type SetMyCommandsOption func(params *SetMyCommandsParams) SetMyCommandsOption

// Option applies one or more SetMyCommandsOption values and returns the last rollback option.
func (r *SetMyCommandsParams) Option(opts ...SetMyCommandsOption) (previous SetMyCommandsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetMyCommandsCommands sets the Commands field.
//
// A JSON-serialized list of bot commands to be set as the list of the bot's commands.
// At most 100 commands can be specified.
func WithSetMyCommandsCommands(value []BotCommand) SetMyCommandsOption {
	return func(params *SetMyCommandsParams) SetMyCommandsOption {
		previous := params.Commands
		params.Commands = value

		return WithSetMyCommandsCommands(previous)
	}
}

// WithSetMyCommandsScope sets the Scope field.
//
// A JSON-serialized object, describing scope of users for which the commands are relevant.
// Defaults to [BotCommandScopeDefault].
//
// [BotCommandScopeDefault]: https://core.telegram.org/bots/api#botcommandscopedefault
func WithSetMyCommandsScope(value *BotCommandScope) SetMyCommandsOption {
	return func(params *SetMyCommandsParams) SetMyCommandsOption {
		previous := params.Scope
		params.Scope = value

		return WithSetMyCommandsScope(previous)
	}
}

// WithSetMyCommandsLanguageCode sets the LanguageCode field.
//
// A two-letter ISO 639-1 language code.
// If empty, commands will be applied to all users from the given scope, for whose language there are no dedicated commands
func WithSetMyCommandsLanguageCode(value string) SetMyCommandsOption {
	return func(params *SetMyCommandsParams) SetMyCommandsOption {
		previous := params.LanguageCode
		params.LanguageCode = value

		return WithSetMyCommandsLanguageCode(previous)
	}
}

// SetMyCommands calls the setMyCommands Telegram Bot API method.
//
// Use this method to change the list of the bot's commands.
// See [this manual] for more details about bot commands.
// Returns True on success.
//
// [this manual]: https://core.telegram.org/bots/features#commands
func (c *Client) SetMyCommands(params *SetMyCommandsParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setMyCommands", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetMyDefaultAdministratorRightsParams contains parameters for Client.SetMyDefaultAdministratorRights.
type SetMyDefaultAdministratorRightsParams struct {
	// A JSON-serialized object describing new default administrator rights.
	// If not specified, the default administrator rights will be cleared.
	Rights *ChatAdministratorRights `json:"rights,omitempty"`

	// Pass True to change the default administrator rights of the bot in channels.
	// Otherwise, the default administrator rights of the bot for groups and supergroups will be changed.
	ForChannels bool `json:"for_channels,omitempty"`
}

// SetMyDefaultAdministratorRightsOption configures SetMyDefaultAdministratorRightsParams.
type SetMyDefaultAdministratorRightsOption func(params *SetMyDefaultAdministratorRightsParams) SetMyDefaultAdministratorRightsOption

// Option applies one or more SetMyDefaultAdministratorRightsOption values and returns the last rollback option.
func (r *SetMyDefaultAdministratorRightsParams) Option(opts ...SetMyDefaultAdministratorRightsOption) (previous SetMyDefaultAdministratorRightsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetMyDefaultAdministratorRightsRights sets the Rights field.
//
// A JSON-serialized object describing new default administrator rights.
// If not specified, the default administrator rights will be cleared.
func WithSetMyDefaultAdministratorRightsRights(value *ChatAdministratorRights) SetMyDefaultAdministratorRightsOption {
	return func(params *SetMyDefaultAdministratorRightsParams) SetMyDefaultAdministratorRightsOption {
		previous := params.Rights
		params.Rights = value

		return WithSetMyDefaultAdministratorRightsRights(previous)
	}
}

// WithSetMyDefaultAdministratorRightsForChannels sets the ForChannels field.
//
// Pass True to change the default administrator rights of the bot in channels.
// Otherwise, the default administrator rights of the bot for groups and supergroups will be changed.
func WithSetMyDefaultAdministratorRightsForChannels(value bool) SetMyDefaultAdministratorRightsOption {
	return func(params *SetMyDefaultAdministratorRightsParams) SetMyDefaultAdministratorRightsOption {
		previous := params.ForChannels
		params.ForChannels = value

		return WithSetMyDefaultAdministratorRightsForChannels(previous)
	}
}

// SetMyDefaultAdministratorRights calls the setMyDefaultAdministratorRights Telegram Bot API method.
//
// Use this method to change the default administrator rights requested by the bot when it's added as an administrator to groups or channels.
// These rights will be suggested to users, but they are free to modify the list before adding the bot.
// Returns True on success.
func (c *Client) SetMyDefaultAdministratorRights(params *SetMyDefaultAdministratorRightsParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setMyDefaultAdministratorRights", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetMyDescriptionParams contains parameters for Client.SetMyDescription.
type SetMyDescriptionParams struct {
	// New bot description; 0-512 characters.
	// Pass an empty string to remove the dedicated description for the given language.
	Description string `json:"description,omitempty"`

	// A two-letter ISO 639-1 language code.
	// If empty, the description will be applied to all users for whose language there is no dedicated description.
	LanguageCode string `json:"language_code,omitempty"`
}

// SetMyDescriptionOption configures SetMyDescriptionParams.
type SetMyDescriptionOption func(params *SetMyDescriptionParams) SetMyDescriptionOption

// Option applies one or more SetMyDescriptionOption values and returns the last rollback option.
func (r *SetMyDescriptionParams) Option(opts ...SetMyDescriptionOption) (previous SetMyDescriptionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetMyDescriptionDescription sets the Description field.
//
// New bot description; 0-512 characters.
// Pass an empty string to remove the dedicated description for the given language.
func WithSetMyDescriptionDescription(value string) SetMyDescriptionOption {
	return func(params *SetMyDescriptionParams) SetMyDescriptionOption {
		previous := params.Description
		params.Description = value

		return WithSetMyDescriptionDescription(previous)
	}
}

// WithSetMyDescriptionLanguageCode sets the LanguageCode field.
//
// A two-letter ISO 639-1 language code.
// If empty, the description will be applied to all users for whose language there is no dedicated description.
func WithSetMyDescriptionLanguageCode(value string) SetMyDescriptionOption {
	return func(params *SetMyDescriptionParams) SetMyDescriptionOption {
		previous := params.LanguageCode
		params.LanguageCode = value

		return WithSetMyDescriptionLanguageCode(previous)
	}
}

// SetMyDescription calls the setMyDescription Telegram Bot API method.
//
// Use this method to change the bot's description, which is shown in the chat with the bot if the chat is empty.
// Returns True on success.
func (c *Client) SetMyDescription(params *SetMyDescriptionParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setMyDescription", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetMyNameParams contains parameters for Client.SetMyName.
type SetMyNameParams struct {
	// New bot name; 0-64 characters.
	// Pass an empty string to remove the dedicated name for the given language.
	Name string `json:"name,omitempty"`

	// A two-letter ISO 639-1 language code.
	// If empty, the name will be shown to all users for whose language there is no dedicated name.
	LanguageCode string `json:"language_code,omitempty"`
}

// SetMyNameOption configures SetMyNameParams.
type SetMyNameOption func(params *SetMyNameParams) SetMyNameOption

// Option applies one or more SetMyNameOption values and returns the last rollback option.
func (r *SetMyNameParams) Option(opts ...SetMyNameOption) (previous SetMyNameOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetMyNameName sets the Name field.
//
// New bot name; 0-64 characters.
// Pass an empty string to remove the dedicated name for the given language.
func WithSetMyNameName(value string) SetMyNameOption {
	return func(params *SetMyNameParams) SetMyNameOption {
		previous := params.Name
		params.Name = value

		return WithSetMyNameName(previous)
	}
}

// WithSetMyNameLanguageCode sets the LanguageCode field.
//
// A two-letter ISO 639-1 language code.
// If empty, the name will be shown to all users for whose language there is no dedicated name.
func WithSetMyNameLanguageCode(value string) SetMyNameOption {
	return func(params *SetMyNameParams) SetMyNameOption {
		previous := params.LanguageCode
		params.LanguageCode = value

		return WithSetMyNameLanguageCode(previous)
	}
}

// SetMyName calls the setMyName Telegram Bot API method.
//
// Use this method to change the bot's name.
// Returns True on success.
func (c *Client) SetMyName(params *SetMyNameParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setMyName", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetMyProfilePhotoParams contains parameters for Client.SetMyProfilePhoto.
type SetMyProfilePhotoParams struct {
	// The new profile photo to set
	Photo InputProfilePhoto `json:"photo"`
}

// SetMyProfilePhotoOption configures SetMyProfilePhotoParams.
type SetMyProfilePhotoOption func(params *SetMyProfilePhotoParams) SetMyProfilePhotoOption

// Option applies one or more SetMyProfilePhotoOption values and returns the last rollback option.
func (r *SetMyProfilePhotoParams) Option(opts ...SetMyProfilePhotoOption) (previous SetMyProfilePhotoOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetMyProfilePhotoPhoto sets the Photo field.
//
// The new profile photo to set
func WithSetMyProfilePhotoPhoto(value InputProfilePhoto) SetMyProfilePhotoOption {
	return func(params *SetMyProfilePhotoParams) SetMyProfilePhotoOption {
		previous := params.Photo
		params.Photo = value

		return WithSetMyProfilePhotoPhoto(previous)
	}
}

// SetMyProfilePhoto calls the setMyProfilePhoto Telegram Bot API method.
//
// Changes the profile photo of the bot.
// Returns True on success.
func (c *Client) SetMyProfilePhoto(params *SetMyProfilePhotoParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setMyProfilePhoto", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetMyShortDescriptionParams contains parameters for Client.SetMyShortDescription.
type SetMyShortDescriptionParams struct {
	// New short description for the bot; 0-120 characters.
	// Pass an empty string to remove the dedicated short description for the given language.
	ShortDescription string `json:"short_description,omitempty"`

	// A two-letter ISO 639-1 language code.
	// If empty, the short description will be applied to all users for whose language there is no dedicated short description.
	LanguageCode string `json:"language_code,omitempty"`
}

// SetMyShortDescriptionOption configures SetMyShortDescriptionParams.
type SetMyShortDescriptionOption func(params *SetMyShortDescriptionParams) SetMyShortDescriptionOption

// Option applies one or more SetMyShortDescriptionOption values and returns the last rollback option.
func (r *SetMyShortDescriptionParams) Option(opts ...SetMyShortDescriptionOption) (previous SetMyShortDescriptionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetMyShortDescriptionShortDescription sets the ShortDescription field.
//
// New short description for the bot; 0-120 characters.
// Pass an empty string to remove the dedicated short description for the given language.
func WithSetMyShortDescriptionShortDescription(value string) SetMyShortDescriptionOption {
	return func(params *SetMyShortDescriptionParams) SetMyShortDescriptionOption {
		previous := params.ShortDescription
		params.ShortDescription = value

		return WithSetMyShortDescriptionShortDescription(previous)
	}
}

// WithSetMyShortDescriptionLanguageCode sets the LanguageCode field.
//
// A two-letter ISO 639-1 language code.
// If empty, the short description will be applied to all users for whose language there is no dedicated short description.
func WithSetMyShortDescriptionLanguageCode(value string) SetMyShortDescriptionOption {
	return func(params *SetMyShortDescriptionParams) SetMyShortDescriptionOption {
		previous := params.LanguageCode
		params.LanguageCode = value

		return WithSetMyShortDescriptionLanguageCode(previous)
	}
}

// SetMyShortDescription calls the setMyShortDescription Telegram Bot API method.
//
// Use this method to change the bot's short description, which is shown on the bot's profile page and is sent together with the link when users share the bot.
// Returns True on success.
func (c *Client) SetMyShortDescription(params *SetMyShortDescriptionParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setMyShortDescription", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetPassportDataErrorsParams contains parameters for Client.SetPassportDataErrors.
type SetPassportDataErrorsParams struct {
	// User identifier
	UserID int64 `json:"user_id"`

	// A JSON-serialized array describing the errors
	Errors []PassportElementError `json:"errors"`
}

// SetPassportDataErrorsOption configures SetPassportDataErrorsParams.
type SetPassportDataErrorsOption func(params *SetPassportDataErrorsParams) SetPassportDataErrorsOption

// Option applies one or more SetPassportDataErrorsOption values and returns the last rollback option.
func (r *SetPassportDataErrorsParams) Option(opts ...SetPassportDataErrorsOption) (previous SetPassportDataErrorsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetPassportDataErrorsUserID sets the UserID field.
//
// User identifier
func WithSetPassportDataErrorsUserID(value int64) SetPassportDataErrorsOption {
	return func(params *SetPassportDataErrorsParams) SetPassportDataErrorsOption {
		previous := params.UserID
		params.UserID = value

		return WithSetPassportDataErrorsUserID(previous)
	}
}

// WithSetPassportDataErrorsErrors sets the Errors field.
//
// A JSON-serialized array describing the errors
func WithSetPassportDataErrorsErrors(value []PassportElementError) SetPassportDataErrorsOption {
	return func(params *SetPassportDataErrorsParams) SetPassportDataErrorsOption {
		previous := params.Errors
		params.Errors = value

		return WithSetPassportDataErrorsErrors(previous)
	}
}

// SetPassportDataErrors calls the setPassportDataErrors Telegram Bot API method.
//
// Informs a user that some of the Telegram Passport elements they provided contains errors.
// The user will not be able to re-submit their Passport to you until the errors are fixed (the contents of the field for which you returned the error must change).
// Returns True on success.
// Use this if the data submitted by the user doesn't satisfy the standards your service requires for any reason.
// For example, if a birthday date seems invalid, a submitted document is blurry, a scan shows evidence of tampering, etc.
// Supply some details in the error message to make sure the user knows how to correct the issues.
func (c *Client) SetPassportDataErrors(params *SetPassportDataErrorsParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setPassportDataErrors", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetStickerEmojiListParams contains parameters for Client.SetStickerEmojiList.
type SetStickerEmojiListParams struct {
	// File identifier of the sticker
	Sticker string `json:"sticker"`

	// A JSON-serialized list of 1-20 emoji associated with the sticker
	EmojiList []string `json:"emoji_list"`
}

// SetStickerEmojiListOption configures SetStickerEmojiListParams.
type SetStickerEmojiListOption func(params *SetStickerEmojiListParams) SetStickerEmojiListOption

// Option applies one or more SetStickerEmojiListOption values and returns the last rollback option.
func (r *SetStickerEmojiListParams) Option(opts ...SetStickerEmojiListOption) (previous SetStickerEmojiListOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetStickerEmojiListSticker sets the Sticker field.
//
// File identifier of the sticker
func WithSetStickerEmojiListSticker(value string) SetStickerEmojiListOption {
	return func(params *SetStickerEmojiListParams) SetStickerEmojiListOption {
		previous := params.Sticker
		params.Sticker = value

		return WithSetStickerEmojiListSticker(previous)
	}
}

// WithSetStickerEmojiListEmojiList sets the EmojiList field.
//
// A JSON-serialized list of 1-20 emoji associated with the sticker
func WithSetStickerEmojiListEmojiList(value []string) SetStickerEmojiListOption {
	return func(params *SetStickerEmojiListParams) SetStickerEmojiListOption {
		previous := params.EmojiList
		params.EmojiList = value

		return WithSetStickerEmojiListEmojiList(previous)
	}
}

// SetStickerEmojiList calls the setStickerEmojiList Telegram Bot API method.
//
// Use this method to change the list of emoji assigned to a regular or custom emoji sticker.
// The sticker must belong to a sticker set created by the bot.
// Returns True on success.
func (c *Client) SetStickerEmojiList(params *SetStickerEmojiListParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setStickerEmojiList", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetStickerKeywordsParams contains parameters for Client.SetStickerKeywords.
type SetStickerKeywordsParams struct {
	// File identifier of the sticker
	Sticker string `json:"sticker"`

	// A JSON-serialized list of 0-20 search keywords for the sticker with total length of up to 64 characters
	Keywords []string `json:"keywords,omitempty"`
}

// SetStickerKeywordsOption configures SetStickerKeywordsParams.
type SetStickerKeywordsOption func(params *SetStickerKeywordsParams) SetStickerKeywordsOption

// Option applies one or more SetStickerKeywordsOption values and returns the last rollback option.
func (r *SetStickerKeywordsParams) Option(opts ...SetStickerKeywordsOption) (previous SetStickerKeywordsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetStickerKeywordsSticker sets the Sticker field.
//
// File identifier of the sticker
func WithSetStickerKeywordsSticker(value string) SetStickerKeywordsOption {
	return func(params *SetStickerKeywordsParams) SetStickerKeywordsOption {
		previous := params.Sticker
		params.Sticker = value

		return WithSetStickerKeywordsSticker(previous)
	}
}

// WithSetStickerKeywordsKeywords sets the Keywords field.
//
// A JSON-serialized list of 0-20 search keywords for the sticker with total length of up to 64 characters
func WithSetStickerKeywordsKeywords(value []string) SetStickerKeywordsOption {
	return func(params *SetStickerKeywordsParams) SetStickerKeywordsOption {
		previous := params.Keywords
		params.Keywords = value

		return WithSetStickerKeywordsKeywords(previous)
	}
}

// SetStickerKeywords calls the setStickerKeywords Telegram Bot API method.
//
// Use this method to change search keywords assigned to a regular or custom emoji sticker.
// The sticker must belong to a sticker set created by the bot.
// Returns True on success.
func (c *Client) SetStickerKeywords(params *SetStickerKeywordsParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setStickerKeywords", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetStickerMaskPositionParams contains parameters for Client.SetStickerMaskPosition.
type SetStickerMaskPositionParams struct {
	// File identifier of the sticker
	Sticker string `json:"sticker"`

	// A JSON-serialized object with the position where the mask should be placed on faces.
	// Omit the parameter to remove the mask position.
	MaskPosition *MaskPosition `json:"mask_position,omitempty"`
}

// SetStickerMaskPositionOption configures SetStickerMaskPositionParams.
type SetStickerMaskPositionOption func(params *SetStickerMaskPositionParams) SetStickerMaskPositionOption

// Option applies one or more SetStickerMaskPositionOption values and returns the last rollback option.
func (r *SetStickerMaskPositionParams) Option(opts ...SetStickerMaskPositionOption) (previous SetStickerMaskPositionOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetStickerMaskPositionSticker sets the Sticker field.
//
// File identifier of the sticker
func WithSetStickerMaskPositionSticker(value string) SetStickerMaskPositionOption {
	return func(params *SetStickerMaskPositionParams) SetStickerMaskPositionOption {
		previous := params.Sticker
		params.Sticker = value

		return WithSetStickerMaskPositionSticker(previous)
	}
}

// WithSetStickerMaskPositionMaskPosition sets the MaskPosition field.
//
// A JSON-serialized object with the position where the mask should be placed on faces.
// Omit the parameter to remove the mask position.
func WithSetStickerMaskPositionMaskPosition(value *MaskPosition) SetStickerMaskPositionOption {
	return func(params *SetStickerMaskPositionParams) SetStickerMaskPositionOption {
		previous := params.MaskPosition
		params.MaskPosition = value

		return WithSetStickerMaskPositionMaskPosition(previous)
	}
}

// SetStickerMaskPosition calls the setStickerMaskPosition Telegram Bot API method.
//
// Use this method to change the [mask position] of a mask sticker.
// The sticker must belong to a sticker set that was created by the bot.
// Returns True on success.
//
// [mask position]: https://core.telegram.org/bots/api#maskposition
func (c *Client) SetStickerMaskPosition(params *SetStickerMaskPositionParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setStickerMaskPosition", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetStickerPositionInSetParams contains parameters for Client.SetStickerPositionInSet.
type SetStickerPositionInSetParams struct {
	// File identifier of the sticker
	Sticker string `json:"sticker"`

	// New sticker position in the set, zero-based
	Position int64 `json:"position"`
}

// SetStickerPositionInSetOption configures SetStickerPositionInSetParams.
type SetStickerPositionInSetOption func(params *SetStickerPositionInSetParams) SetStickerPositionInSetOption

// Option applies one or more SetStickerPositionInSetOption values and returns the last rollback option.
func (r *SetStickerPositionInSetParams) Option(opts ...SetStickerPositionInSetOption) (previous SetStickerPositionInSetOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetStickerPositionInSetSticker sets the Sticker field.
//
// File identifier of the sticker
func WithSetStickerPositionInSetSticker(value string) SetStickerPositionInSetOption {
	return func(params *SetStickerPositionInSetParams) SetStickerPositionInSetOption {
		previous := params.Sticker
		params.Sticker = value

		return WithSetStickerPositionInSetSticker(previous)
	}
}

// WithSetStickerPositionInSetPosition sets the Position field.
//
// New sticker position in the set, zero-based
func WithSetStickerPositionInSetPosition(value int64) SetStickerPositionInSetOption {
	return func(params *SetStickerPositionInSetParams) SetStickerPositionInSetOption {
		previous := params.Position
		params.Position = value

		return WithSetStickerPositionInSetPosition(previous)
	}
}

// SetStickerPositionInSet calls the setStickerPositionInSet Telegram Bot API method.
//
// Use this method to move a sticker in a set created by the bot to a specific position.
// Returns True on success.
func (c *Client) SetStickerPositionInSet(params *SetStickerPositionInSetParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setStickerPositionInSet", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetStickerSetThumbnailParams contains parameters for Client.SetStickerSetThumbnail.
type SetStickerSetThumbnailParams struct {
	// Sticker set name
	Name string `json:"name"`

	// User identifier of the sticker set owner
	UserID int64 `json:"user_id"`

	// A .WEBP or .PNG image with the thumbnail, must be up to 128 kilobytes in size and have a width and height of exactly 100px, or a .TGS animation with a thumbnail up to 32 kilobytes in size (see [https://core.telegram.org/stickers#animation-requirements] for animated sticker technical requirements), or a .WEBM video with the thumbnail up to 32 kilobytes in size; see [https://core.telegram.org/stickers#video-requirements] for video sticker technical requirements.
	// Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, or upload a new one using multipart/form-data.
	// [More information on Sending Files »].
	// Animated and video sticker set thumbnails can't be uploaded via HTTP URL.
	// If omitted, then the thumbnail is dropped and the first sticker is used as the thumbnail.
	//
	// [https://core.telegram.org/stickers#animation-requirements]: https://core.telegram.org/stickers#animation-requirements
	// [https://core.telegram.org/stickers#video-requirements]: https://core.telegram.org/stickers#video-requirements
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Thumbnail *InputFile `json:"thumbnail,omitempty"`

	// Format of the thumbnail, must be one of “static” for a .WEBP or .PNG image, “animated” for a .TGS animation, or “video” for a .WEBM video
	Format string `json:"format"`
}

// SetStickerSetThumbnailOption configures SetStickerSetThumbnailParams.
type SetStickerSetThumbnailOption func(params *SetStickerSetThumbnailParams) SetStickerSetThumbnailOption

// Option applies one or more SetStickerSetThumbnailOption values and returns the last rollback option.
func (r *SetStickerSetThumbnailParams) Option(opts ...SetStickerSetThumbnailOption) (previous SetStickerSetThumbnailOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetStickerSetThumbnailName sets the Name field.
//
// Sticker set name
func WithSetStickerSetThumbnailName(value string) SetStickerSetThumbnailOption {
	return func(params *SetStickerSetThumbnailParams) SetStickerSetThumbnailOption {
		previous := params.Name
		params.Name = value

		return WithSetStickerSetThumbnailName(previous)
	}
}

// WithSetStickerSetThumbnailUserID sets the UserID field.
//
// User identifier of the sticker set owner
func WithSetStickerSetThumbnailUserID(value int64) SetStickerSetThumbnailOption {
	return func(params *SetStickerSetThumbnailParams) SetStickerSetThumbnailOption {
		previous := params.UserID
		params.UserID = value

		return WithSetStickerSetThumbnailUserID(previous)
	}
}

// WithSetStickerSetThumbnailThumbnail sets the Thumbnail field.
//
// A .WEBP or .PNG image with the thumbnail, must be up to 128 kilobytes in size and have a width and height of exactly 100px, or a .TGS animation with a thumbnail up to 32 kilobytes in size (see [https://core.telegram.org/stickers#animation-requirements] for animated sticker technical requirements), or a .WEBM video with the thumbnail up to 32 kilobytes in size; see [https://core.telegram.org/stickers#video-requirements] for video sticker technical requirements.
// Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, or upload a new one using multipart/form-data.
// [More information on Sending Files »].
// Animated and video sticker set thumbnails can't be uploaded via HTTP URL.
// If omitted, then the thumbnail is dropped and the first sticker is used as the thumbnail.
//
// [https://core.telegram.org/stickers#animation-requirements]: https://core.telegram.org/stickers#animation-requirements
// [https://core.telegram.org/stickers#video-requirements]: https://core.telegram.org/stickers#video-requirements
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithSetStickerSetThumbnailThumbnail(value *InputFile) SetStickerSetThumbnailOption {
	return func(params *SetStickerSetThumbnailParams) SetStickerSetThumbnailOption {
		previous := params.Thumbnail
		params.Thumbnail = value

		return WithSetStickerSetThumbnailThumbnail(previous)
	}
}

// WithSetStickerSetThumbnailFormat sets the Format field.
//
// Format of the thumbnail, must be one of “static” for a .WEBP or .PNG image, “animated” for a .TGS animation, or “video” for a .WEBM video
func WithSetStickerSetThumbnailFormat(value string) SetStickerSetThumbnailOption {
	return func(params *SetStickerSetThumbnailParams) SetStickerSetThumbnailOption {
		previous := params.Format
		params.Format = value

		return WithSetStickerSetThumbnailFormat(previous)
	}
}

// SetStickerSetThumbnail calls the setStickerSetThumbnail Telegram Bot API method.
//
// Use this method to set the thumbnail of a regular or mask sticker set.
// The format of the thumbnail file must match the format of the stickers in the set.
// Returns True on success.
func (c *Client) SetStickerSetThumbnail(params *SetStickerSetThumbnailParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setStickerSetThumbnail", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetStickerSetTitleParams contains parameters for Client.SetStickerSetTitle.
type SetStickerSetTitleParams struct {
	// Sticker set name
	Name string `json:"name"`

	// Sticker set title, 1-64 characters
	Title string `json:"title"`
}

// SetStickerSetTitleOption configures SetStickerSetTitleParams.
type SetStickerSetTitleOption func(params *SetStickerSetTitleParams) SetStickerSetTitleOption

// Option applies one or more SetStickerSetTitleOption values and returns the last rollback option.
func (r *SetStickerSetTitleParams) Option(opts ...SetStickerSetTitleOption) (previous SetStickerSetTitleOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetStickerSetTitleName sets the Name field.
//
// Sticker set name
func WithSetStickerSetTitleName(value string) SetStickerSetTitleOption {
	return func(params *SetStickerSetTitleParams) SetStickerSetTitleOption {
		previous := params.Name
		params.Name = value

		return WithSetStickerSetTitleName(previous)
	}
}

// WithSetStickerSetTitleTitle sets the Title field.
//
// Sticker set title, 1-64 characters
func WithSetStickerSetTitleTitle(value string) SetStickerSetTitleOption {
	return func(params *SetStickerSetTitleParams) SetStickerSetTitleOption {
		previous := params.Title
		params.Title = value

		return WithSetStickerSetTitleTitle(previous)
	}
}

// SetStickerSetTitle calls the setStickerSetTitle Telegram Bot API method.
//
// Use this method to set the title of a created sticker set.
// Returns True on success.
func (c *Client) SetStickerSetTitle(params *SetStickerSetTitleParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setStickerSetTitle", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetUserEmojiStatusParams contains parameters for Client.SetUserEmojiStatus.
type SetUserEmojiStatusParams struct {
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`

	// Custom emoji identifier of the emoji status to set.
	// Pass an empty string to remove the status.
	EmojiStatusCustomEmojiID string `json:"emoji_status_custom_emoji_id,omitempty"`

	// Expiration date of the emoji status, if any
	EmojiStatusExpirationDate int64 `json:"emoji_status_expiration_date,omitempty"`
}

// SetUserEmojiStatusOption configures SetUserEmojiStatusParams.
type SetUserEmojiStatusOption func(params *SetUserEmojiStatusParams) SetUserEmojiStatusOption

// Option applies one or more SetUserEmojiStatusOption values and returns the last rollback option.
func (r *SetUserEmojiStatusParams) Option(opts ...SetUserEmojiStatusOption) (previous SetUserEmojiStatusOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetUserEmojiStatusUserID sets the UserID field.
//
// Unique identifier of the target user
func WithSetUserEmojiStatusUserID(value int64) SetUserEmojiStatusOption {
	return func(params *SetUserEmojiStatusParams) SetUserEmojiStatusOption {
		previous := params.UserID
		params.UserID = value

		return WithSetUserEmojiStatusUserID(previous)
	}
}

// WithSetUserEmojiStatusEmojiStatusCustomEmojiID sets the EmojiStatusCustomEmojiID field.
//
// Custom emoji identifier of the emoji status to set.
// Pass an empty string to remove the status.
func WithSetUserEmojiStatusEmojiStatusCustomEmojiID(value string) SetUserEmojiStatusOption {
	return func(params *SetUserEmojiStatusParams) SetUserEmojiStatusOption {
		previous := params.EmojiStatusCustomEmojiID
		params.EmojiStatusCustomEmojiID = value

		return WithSetUserEmojiStatusEmojiStatusCustomEmojiID(previous)
	}
}

// WithSetUserEmojiStatusEmojiStatusExpirationDate sets the EmojiStatusExpirationDate field.
//
// Expiration date of the emoji status, if any
func WithSetUserEmojiStatusEmojiStatusExpirationDate(value int64) SetUserEmojiStatusOption {
	return func(params *SetUserEmojiStatusParams) SetUserEmojiStatusOption {
		previous := params.EmojiStatusExpirationDate
		params.EmojiStatusExpirationDate = value

		return WithSetUserEmojiStatusEmojiStatusExpirationDate(previous)
	}
}

// SetUserEmojiStatus calls the setUserEmojiStatus Telegram Bot API method.
//
// Changes the emoji status for a given user that previously allowed the bot to manage their emoji status via the Mini App method [requestEmojiStatusAccess].
// Returns True on success.
//
// [requestEmojiStatusAccess]: https://core.telegram.org/bots/webapps#initializing-mini-apps
func (c *Client) SetUserEmojiStatus(params *SetUserEmojiStatusParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("setUserEmojiStatus", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// SetWebhookParams contains parameters for Client.SetWebhook.
type SetWebhookParams struct {
	// HTTPS URL to send updates to.
	// Use an empty string to remove webhook integration
	URL string `json:"url"`

	// Upload your public key certificate so that the root certificate in use can be checked.
	// See our [self-signed guide] for details.
	//
	// [self-signed guide]: https://core.telegram.org/bots/self-signed
	Certificate *InputFile `json:"certificate,omitempty"`

	// The fixed IP address which will be used to send webhook requests instead of the IP address resolved through DNS
	IpAddress string `json:"ip_address,omitempty"`

	// The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery, 1-100.
	// Defaults to 40.
	// Use lower values to limit the load on your bot's server, and higher values to increase your bot's throughput.
	MaxConnections int64 `json:"max_connections,omitempty"`

	// A JSON-serialized list of the update types you want your bot to receive.
	// For example, specify ["message", "edited_channel_post", "callback_query"] to only receive updates of these types.
	// See [Update] for a complete list of available update types.
	// Specify an empty list to receive all update types except chat_member, message_reaction, and message_reaction_count (default).
	// If not specified, the previous setting will be used.
	// Please note that this parameter doesn't affect updates created before the call to the setWebhook, so unwanted updates may be received for a short period of time.
	//
	// [Update]: https://core.telegram.org/bots/api#update
	AllowedUpdates []string `json:"allowed_updates,omitempty"`

	// Pass True to drop all pending updates
	DropPendingUpdates bool `json:"drop_pending_updates,omitempty"`

	// A secret token to be sent in a header “X-Telegram-Bot-Api-Secret-Token” in every webhook request, 1-256 characters.
	// Only characters A-Z, a-z, 0-9, _ and - are allowed.
	// The header is useful to ensure that the request comes from a webhook set by you.
	SecretToken string `json:"secret_token,omitempty"`
}

// SetWebhookOption configures SetWebhookParams.
type SetWebhookOption func(params *SetWebhookParams) SetWebhookOption

// Option applies one or more SetWebhookOption values and returns the last rollback option.
func (r *SetWebhookParams) Option(opts ...SetWebhookOption) (previous SetWebhookOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithSetWebhookURL sets the URL field.
//
// HTTPS URL to send updates to.
// Use an empty string to remove webhook integration
func WithSetWebhookURL(value string) SetWebhookOption {
	return func(params *SetWebhookParams) SetWebhookOption {
		previous := params.URL
		params.URL = value

		return WithSetWebhookURL(previous)
	}
}

// WithSetWebhookCertificate sets the Certificate field.
//
// Upload your public key certificate so that the root certificate in use can be checked.
// See our [self-signed guide] for details.
//
// [self-signed guide]: https://core.telegram.org/bots/self-signed
func WithSetWebhookCertificate(value *InputFile) SetWebhookOption {
	return func(params *SetWebhookParams) SetWebhookOption {
		previous := params.Certificate
		params.Certificate = value

		return WithSetWebhookCertificate(previous)
	}
}

// WithSetWebhookIpAddress sets the IpAddress field.
//
// The fixed IP address which will be used to send webhook requests instead of the IP address resolved through DNS
func WithSetWebhookIpAddress(value string) SetWebhookOption {
	return func(params *SetWebhookParams) SetWebhookOption {
		previous := params.IpAddress
		params.IpAddress = value

		return WithSetWebhookIpAddress(previous)
	}
}

// WithSetWebhookMaxConnections sets the MaxConnections field.
//
// The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery, 1-100.
// Defaults to 40.
// Use lower values to limit the load on your bot's server, and higher values to increase your bot's throughput.
func WithSetWebhookMaxConnections(value int64) SetWebhookOption {
	return func(params *SetWebhookParams) SetWebhookOption {
		previous := params.MaxConnections
		params.MaxConnections = value

		return WithSetWebhookMaxConnections(previous)
	}
}

// WithSetWebhookAllowedUpdates sets the AllowedUpdates field.
//
// A JSON-serialized list of the update types you want your bot to receive.
// For example, specify ["message", "edited_channel_post", "callback_query"] to only receive updates of these types.
// See [Update] for a complete list of available update types.
// Specify an empty list to receive all update types except chat_member, message_reaction, and message_reaction_count (default).
// If not specified, the previous setting will be used.
// Please note that this parameter doesn't affect updates created before the call to the setWebhook, so unwanted updates may be received for a short period of time.
//
// [Update]: https://core.telegram.org/bots/api#update
func WithSetWebhookAllowedUpdates(value []string) SetWebhookOption {
	return func(params *SetWebhookParams) SetWebhookOption {
		previous := params.AllowedUpdates
		params.AllowedUpdates = value

		return WithSetWebhookAllowedUpdates(previous)
	}
}

// WithSetWebhookDropPendingUpdates sets the DropPendingUpdates field.
//
// Pass True to drop all pending updates
func WithSetWebhookDropPendingUpdates(value bool) SetWebhookOption {
	return func(params *SetWebhookParams) SetWebhookOption {
		previous := params.DropPendingUpdates
		params.DropPendingUpdates = value

		return WithSetWebhookDropPendingUpdates(previous)
	}
}

// WithSetWebhookSecretToken sets the SecretToken field.
//
// A secret token to be sent in a header “X-Telegram-Bot-Api-Secret-Token” in every webhook request, 1-256 characters.
// Only characters A-Z, a-z, 0-9, _ and - are allowed.
// The header is useful to ensure that the request comes from a webhook set by you.
func WithSetWebhookSecretToken(value string) SetWebhookOption {
	return func(params *SetWebhookParams) SetWebhookOption {
		previous := params.SecretToken
		params.SecretToken = value

		return WithSetWebhookSecretToken(previous)
	}
}

// SetWebhook calls the setWebhook Telegram Bot API method.
//
// Use this method to specify a URL and receive incoming updates via an outgoing webhook.
// Whenever there is an update for the bot, we will send an HTTPS POST request to the specified URL, containing a JSON-serialized [Update].
// In case of an unsuccessful request (a request with response [HTTP status code] different from 2XY), we will repeat the request and give up after a reasonable amount of attempts.
// Returns True on success.
// If you'd like to make sure that the webhook was set by you, you can specify secret data in the parameter secret_token.
// If specified, the request will contain a header “X-Telegram-Bot-Api-Secret-Token” with the secret token as content.
//
// [Update]: https://core.telegram.org/bots/api#update
// [HTTP status code]: https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
func (c *Client) SetWebhook(params *SetWebhookParams) (ret bool, err error) {
	var bs []byte

	reader, pw := io.Pipe()
	writer := multipart.NewWriter(pw)

	go func() {
		defer pw.Close()
		defer writer.Close()

		{
			err = writer.WriteField("url", params.URL)
			if err != nil {
				return
			}
		}

		if params.Certificate != nil {
			if params.Certificate.File != nil {
				var w io.Writer
				params.Certificate.fieldName = "certificate"

				w, err = writer.CreateFormFile(
					params.Certificate.fieldName,
					params.Certificate.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Certificate.File)
				if err != nil {
					return
				}

				if closer, ok := params.Certificate.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Certificate)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("certificate")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.IpAddress != "" {
			err = writer.WriteField("ip_address", params.IpAddress)
			if err != nil {
				return
			}
		}

		if params.MaxConnections != 0 {
			v := strconv.FormatInt(params.MaxConnections, 10)
			err = writer.WriteField("max_connections", v)
			if err != nil {
				return
			}
		}

		if params.AllowedUpdates != nil {

			bs, err = json.Marshal(params.AllowedUpdates)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("allowed_updates")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		if params.DropPendingUpdates {
			v := strconv.FormatBool(params.DropPendingUpdates)
			err = writer.WriteField("drop_pending_updates", v)
			if err != nil {
				return
			}
		}

		if params.SecretToken != "" {
			err = writer.WriteField("secret_token", params.SecretToken)
			if err != nil {
				return
			}
		}

	}()

	contentType := writer.FormDataContentType()

	var result json.RawMessage

	result, err = c.Raw("setWebhook", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// StopMessageLiveLocationParams contains parameters for Client.StopMessageLiveLocation.
type StopMessageLiveLocationParams struct {
	// Unique identifier of the business connection on behalf of which the message to be edited was sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id,omitempty"`

	// Required if inline_message_id is not specified.
	// Identifier of the message with live location to stop
	MessageID int64 `json:"message_id,omitempty"`

	// Required if chat_id and message_id are not specified.
	// Identifier of the inline message
	InlineMessageID string `json:"inline_message_id,omitempty"`

	// A JSON-serialized object for a new [inline keyboard].
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// StopMessageLiveLocationOption configures StopMessageLiveLocationParams.
type StopMessageLiveLocationOption func(params *StopMessageLiveLocationParams) StopMessageLiveLocationOption

// Option applies one or more StopMessageLiveLocationOption values and returns the last rollback option.
func (r *StopMessageLiveLocationParams) Option(opts ...StopMessageLiveLocationOption) (previous StopMessageLiveLocationOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithStopMessageLiveLocationBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message to be edited was sent
func WithStopMessageLiveLocationBusinessConnectionID(value string) StopMessageLiveLocationOption {
	return func(params *StopMessageLiveLocationParams) StopMessageLiveLocationOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithStopMessageLiveLocationBusinessConnectionID(previous)
	}
}

// WithStopMessageLiveLocationChatID sets the ChatID field.
//
// Required if inline_message_id is not specified.
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithStopMessageLiveLocationChatID(value string) StopMessageLiveLocationOption {
	return func(params *StopMessageLiveLocationParams) StopMessageLiveLocationOption {
		previous := params.ChatID
		params.ChatID = value

		return WithStopMessageLiveLocationChatID(previous)
	}
}

// WithStopMessageLiveLocationMessageID sets the MessageID field.
//
// Required if inline_message_id is not specified.
// Identifier of the message with live location to stop
func WithStopMessageLiveLocationMessageID(value int64) StopMessageLiveLocationOption {
	return func(params *StopMessageLiveLocationParams) StopMessageLiveLocationOption {
		previous := params.MessageID
		params.MessageID = value

		return WithStopMessageLiveLocationMessageID(previous)
	}
}

// WithStopMessageLiveLocationInlineMessageID sets the InlineMessageID field.
//
// Required if chat_id and message_id are not specified.
// Identifier of the inline message
func WithStopMessageLiveLocationInlineMessageID(value string) StopMessageLiveLocationOption {
	return func(params *StopMessageLiveLocationParams) StopMessageLiveLocationOption {
		previous := params.InlineMessageID
		params.InlineMessageID = value

		return WithStopMessageLiveLocationInlineMessageID(previous)
	}
}

// WithStopMessageLiveLocationReplyMarkup sets the ReplyMarkup field.
//
// A JSON-serialized object for a new [inline keyboard].
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
func WithStopMessageLiveLocationReplyMarkup(value *InlineKeyboardMarkup) StopMessageLiveLocationOption {
	return func(params *StopMessageLiveLocationParams) StopMessageLiveLocationOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithStopMessageLiveLocationReplyMarkup(previous)
	}
}

// StopMessageLiveLocation calls the stopMessageLiveLocation Telegram Bot API method.
//
// Use this method to stop updating a live location message before live_period expires.
// On success, if the message is not an inline message, the edited [Message] is returned, otherwise True is returned.
//
// [Message]: https://core.telegram.org/bots/api#message
func (c *Client) StopMessageLiveLocation(params *StopMessageLiveLocationParams) (ret *Message, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("stopMessageLiveLocation", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Message)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// StopPollParams contains parameters for Client.StopPoll.
type StopPollParams struct {
	// Unique identifier of the business connection on behalf of which the message to be edited was sent
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Identifier of the original message with the poll
	MessageID int64 `json:"message_id"`

	// A JSON-serialized object for a new message [inline keyboard].
	//
	// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
	ReplyMarkup *InlineKeyboardMarkup `json:"reply_markup,omitempty"`
}

// StopPollOption configures StopPollParams.
type StopPollOption func(params *StopPollParams) StopPollOption

// Option applies one or more StopPollOption values and returns the last rollback option.
func (r *StopPollParams) Option(opts ...StopPollOption) (previous StopPollOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithStopPollBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message to be edited was sent
func WithStopPollBusinessConnectionID(value string) StopPollOption {
	return func(params *StopPollParams) StopPollOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithStopPollBusinessConnectionID(previous)
	}
}

// WithStopPollChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithStopPollChatID(value string) StopPollOption {
	return func(params *StopPollParams) StopPollOption {
		previous := params.ChatID
		params.ChatID = value

		return WithStopPollChatID(previous)
	}
}

// WithStopPollMessageID sets the MessageID field.
//
// Identifier of the original message with the poll
func WithStopPollMessageID(value int64) StopPollOption {
	return func(params *StopPollParams) StopPollOption {
		previous := params.MessageID
		params.MessageID = value

		return WithStopPollMessageID(previous)
	}
}

// WithStopPollReplyMarkup sets the ReplyMarkup field.
//
// A JSON-serialized object for a new message [inline keyboard].
//
// [inline keyboard]: https://core.telegram.org/bots/features#inline-keyboards
func WithStopPollReplyMarkup(value *InlineKeyboardMarkup) StopPollOption {
	return func(params *StopPollParams) StopPollOption {
		previous := params.ReplyMarkup
		params.ReplyMarkup = value

		return WithStopPollReplyMarkup(previous)
	}
}

// StopPoll calls the stopPoll Telegram Bot API method.
//
// Use this method to stop a poll which was sent by the bot.
// On success, the stopped [Poll] is returned.
//
// [Poll]: https://core.telegram.org/bots/api#poll
func (c *Client) StopPoll(params *StopPollParams) (ret *Poll, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("stopPoll", reader, contentType)
	if err != nil {
		return
	}

	ret = new(Poll)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// TransferBusinessAccountStarsParams contains parameters for Client.TransferBusinessAccountStars.
type TransferBusinessAccountStarsParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// Number of Telegram Stars to transfer; 1-10000
	StarCount int64 `json:"star_count"`
}

// TransferBusinessAccountStarsOption configures TransferBusinessAccountStarsParams.
type TransferBusinessAccountStarsOption func(params *TransferBusinessAccountStarsParams) TransferBusinessAccountStarsOption

// Option applies one or more TransferBusinessAccountStarsOption values and returns the last rollback option.
func (r *TransferBusinessAccountStarsParams) Option(opts ...TransferBusinessAccountStarsOption) (previous TransferBusinessAccountStarsOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithTransferBusinessAccountStarsBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithTransferBusinessAccountStarsBusinessConnectionID(value string) TransferBusinessAccountStarsOption {
	return func(params *TransferBusinessAccountStarsParams) TransferBusinessAccountStarsOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithTransferBusinessAccountStarsBusinessConnectionID(previous)
	}
}

// WithTransferBusinessAccountStarsStarCount sets the StarCount field.
//
// Number of Telegram Stars to transfer; 1-10000
func WithTransferBusinessAccountStarsStarCount(value int64) TransferBusinessAccountStarsOption {
	return func(params *TransferBusinessAccountStarsParams) TransferBusinessAccountStarsOption {
		previous := params.StarCount
		params.StarCount = value

		return WithTransferBusinessAccountStarsStarCount(previous)
	}
}

// TransferBusinessAccountStars calls the transferBusinessAccountStars Telegram Bot API method.
//
// Transfers Telegram Stars from the business account balance to the bot's balance.
// Requires the can_transfer_stars business bot right.
// Returns True on success.
func (c *Client) TransferBusinessAccountStars(params *TransferBusinessAccountStarsParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("transferBusinessAccountStars", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// TransferGiftParams contains parameters for Client.TransferGift.
type TransferGiftParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// Unique identifier of the regular gift that should be transferred
	OwnedGiftID string `json:"owned_gift_id"`

	// Unique identifier of the chat which will own the gift.
	// The chat must be active in the last 24 hours.
	NewOwnerChatID int64 `json:"new_owner_chat_id"`

	// The amount of Telegram Stars that will be paid for the transfer from the business account balance.
	// If positive, then the can_transfer_stars business bot right is required.
	StarCount int64 `json:"star_count,omitempty"`
}

// TransferGiftOption configures TransferGiftParams.
type TransferGiftOption func(params *TransferGiftParams) TransferGiftOption

// Option applies one or more TransferGiftOption values and returns the last rollback option.
func (r *TransferGiftParams) Option(opts ...TransferGiftOption) (previous TransferGiftOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithTransferGiftBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithTransferGiftBusinessConnectionID(value string) TransferGiftOption {
	return func(params *TransferGiftParams) TransferGiftOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithTransferGiftBusinessConnectionID(previous)
	}
}

// WithTransferGiftOwnedGiftID sets the OwnedGiftID field.
//
// Unique identifier of the regular gift that should be transferred
func WithTransferGiftOwnedGiftID(value string) TransferGiftOption {
	return func(params *TransferGiftParams) TransferGiftOption {
		previous := params.OwnedGiftID
		params.OwnedGiftID = value

		return WithTransferGiftOwnedGiftID(previous)
	}
}

// WithTransferGiftNewOwnerChatID sets the NewOwnerChatID field.
//
// Unique identifier of the chat which will own the gift.
// The chat must be active in the last 24 hours.
func WithTransferGiftNewOwnerChatID(value int64) TransferGiftOption {
	return func(params *TransferGiftParams) TransferGiftOption {
		previous := params.NewOwnerChatID
		params.NewOwnerChatID = value

		return WithTransferGiftNewOwnerChatID(previous)
	}
}

// WithTransferGiftStarCount sets the StarCount field.
//
// The amount of Telegram Stars that will be paid for the transfer from the business account balance.
// If positive, then the can_transfer_stars business bot right is required.
func WithTransferGiftStarCount(value int64) TransferGiftOption {
	return func(params *TransferGiftParams) TransferGiftOption {
		previous := params.StarCount
		params.StarCount = value

		return WithTransferGiftStarCount(previous)
	}
}

// TransferGift calls the transferGift Telegram Bot API method.
//
// Transfers an owned unique gift to another user.
// Requires the can_transfer_and_upgrade_gifts business bot right.
// Requires can_transfer_stars business bot right if the transfer is paid.
// Returns True on success.
func (c *Client) TransferGift(params *TransferGiftParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("transferGift", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// UnbanChatMemberParams contains parameters for Client.UnbanChatMember.
type UnbanChatMemberParams struct {
	// Unique identifier for the target group or username of the target supergroup or channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target user
	UserID int64 `json:"user_id"`

	// Do nothing if the user is not banned
	OnlyIfBanned bool `json:"only_if_banned,omitempty"`
}

// UnbanChatMemberOption configures UnbanChatMemberParams.
type UnbanChatMemberOption func(params *UnbanChatMemberParams) UnbanChatMemberOption

// Option applies one or more UnbanChatMemberOption values and returns the last rollback option.
func (r *UnbanChatMemberParams) Option(opts ...UnbanChatMemberOption) (previous UnbanChatMemberOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithUnbanChatMemberChatID sets the ChatID field.
//
// Unique identifier for the target group or username of the target supergroup or channel (in the format @channelusername)
func WithUnbanChatMemberChatID(value string) UnbanChatMemberOption {
	return func(params *UnbanChatMemberParams) UnbanChatMemberOption {
		previous := params.ChatID
		params.ChatID = value

		return WithUnbanChatMemberChatID(previous)
	}
}

// WithUnbanChatMemberUserID sets the UserID field.
//
// Unique identifier of the target user
func WithUnbanChatMemberUserID(value int64) UnbanChatMemberOption {
	return func(params *UnbanChatMemberParams) UnbanChatMemberOption {
		previous := params.UserID
		params.UserID = value

		return WithUnbanChatMemberUserID(previous)
	}
}

// WithUnbanChatMemberOnlyIfBanned sets the OnlyIfBanned field.
//
// Do nothing if the user is not banned
func WithUnbanChatMemberOnlyIfBanned(value bool) UnbanChatMemberOption {
	return func(params *UnbanChatMemberParams) UnbanChatMemberOption {
		previous := params.OnlyIfBanned
		params.OnlyIfBanned = value

		return WithUnbanChatMemberOnlyIfBanned(previous)
	}
}

// UnbanChatMember calls the unbanChatMember Telegram Bot API method.
//
// Use this method to unban a previously banned user in a supergroup or channel.
// The user will not return to the group or channel automatically, but will be able to join via link, etc.
// The bot must be an administrator for this to work.
// By default, this method guarantees that after the call the user is not a member of the chat, but will be able to join it.
// So if the user is a member of the chat they will also be removed from the chat.
// If you don't want this, use the parameter only_if_banned.
// Returns True on success.
func (c *Client) UnbanChatMember(params *UnbanChatMemberParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("unbanChatMember", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// UnbanChatSenderChatParams contains parameters for Client.UnbanChatSenderChat.
type UnbanChatSenderChatParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Unique identifier of the target sender chat
	SenderChatID int64 `json:"sender_chat_id"`
}

// UnbanChatSenderChatOption configures UnbanChatSenderChatParams.
type UnbanChatSenderChatOption func(params *UnbanChatSenderChatParams) UnbanChatSenderChatOption

// Option applies one or more UnbanChatSenderChatOption values and returns the last rollback option.
func (r *UnbanChatSenderChatParams) Option(opts ...UnbanChatSenderChatOption) (previous UnbanChatSenderChatOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithUnbanChatSenderChatChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithUnbanChatSenderChatChatID(value string) UnbanChatSenderChatOption {
	return func(params *UnbanChatSenderChatParams) UnbanChatSenderChatOption {
		previous := params.ChatID
		params.ChatID = value

		return WithUnbanChatSenderChatChatID(previous)
	}
}

// WithUnbanChatSenderChatSenderChatID sets the SenderChatID field.
//
// Unique identifier of the target sender chat
func WithUnbanChatSenderChatSenderChatID(value int64) UnbanChatSenderChatOption {
	return func(params *UnbanChatSenderChatParams) UnbanChatSenderChatOption {
		previous := params.SenderChatID
		params.SenderChatID = value

		return WithUnbanChatSenderChatSenderChatID(previous)
	}
}

// UnbanChatSenderChat calls the unbanChatSenderChat Telegram Bot API method.
//
// Use this method to unban a previously banned channel chat in a supergroup or channel.
// The bot must be an administrator for this to work and must have the appropriate administrator rights.
// Returns True on success.
func (c *Client) UnbanChatSenderChat(params *UnbanChatSenderChatParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("unbanChatSenderChat", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// UnhideGeneralForumTopicParams contains parameters for Client.UnhideGeneralForumTopic.
type UnhideGeneralForumTopicParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`
}

// UnhideGeneralForumTopicOption configures UnhideGeneralForumTopicParams.
type UnhideGeneralForumTopicOption func(params *UnhideGeneralForumTopicParams) UnhideGeneralForumTopicOption

// Option applies one or more UnhideGeneralForumTopicOption values and returns the last rollback option.
func (r *UnhideGeneralForumTopicParams) Option(opts ...UnhideGeneralForumTopicOption) (previous UnhideGeneralForumTopicOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithUnhideGeneralForumTopicChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithUnhideGeneralForumTopicChatID(value string) UnhideGeneralForumTopicOption {
	return func(params *UnhideGeneralForumTopicParams) UnhideGeneralForumTopicOption {
		previous := params.ChatID
		params.ChatID = value

		return WithUnhideGeneralForumTopicChatID(previous)
	}
}

// UnhideGeneralForumTopic calls the unhideGeneralForumTopic Telegram Bot API method.
//
// Use this method to unhide the 'General' topic in a forum supergroup chat.
// The bot must be an administrator in the chat for this to work and must have the can_manage_topics administrator rights.
// Returns True on success.
func (c *Client) UnhideGeneralForumTopic(params *UnhideGeneralForumTopicParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("unhideGeneralForumTopic", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// UnpinAllChatMessagesParams contains parameters for Client.UnpinAllChatMessages.
type UnpinAllChatMessagesParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`
}

// UnpinAllChatMessagesOption configures UnpinAllChatMessagesParams.
type UnpinAllChatMessagesOption func(params *UnpinAllChatMessagesParams) UnpinAllChatMessagesOption

// Option applies one or more UnpinAllChatMessagesOption values and returns the last rollback option.
func (r *UnpinAllChatMessagesParams) Option(opts ...UnpinAllChatMessagesOption) (previous UnpinAllChatMessagesOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithUnpinAllChatMessagesChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithUnpinAllChatMessagesChatID(value string) UnpinAllChatMessagesOption {
	return func(params *UnpinAllChatMessagesParams) UnpinAllChatMessagesOption {
		previous := params.ChatID
		params.ChatID = value

		return WithUnpinAllChatMessagesChatID(previous)
	}
}

// UnpinAllChatMessages calls the unpinAllChatMessages Telegram Bot API method.
//
// Use this method to clear the list of pinned messages in a chat.
// In private chats and channel direct messages chats, no additional rights are required to unpin all pinned messages.
// Conversely, the bot must be an administrator with the 'can_pin_messages' right or the 'can_edit_messages' right to unpin all pinned messages in groups and channels respectively.
// Returns True on success.
func (c *Client) UnpinAllChatMessages(params *UnpinAllChatMessagesParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("unpinAllChatMessages", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// UnpinAllForumTopicMessagesParams contains parameters for Client.UnpinAllForumTopicMessages.
type UnpinAllForumTopicMessagesParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`

	// Unique identifier for the target message thread of the forum topic
	MessageThreadID int64 `json:"message_thread_id"`
}

// UnpinAllForumTopicMessagesOption configures UnpinAllForumTopicMessagesParams.
type UnpinAllForumTopicMessagesOption func(params *UnpinAllForumTopicMessagesParams) UnpinAllForumTopicMessagesOption

// Option applies one or more UnpinAllForumTopicMessagesOption values and returns the last rollback option.
func (r *UnpinAllForumTopicMessagesParams) Option(opts ...UnpinAllForumTopicMessagesOption) (previous UnpinAllForumTopicMessagesOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithUnpinAllForumTopicMessagesChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithUnpinAllForumTopicMessagesChatID(value string) UnpinAllForumTopicMessagesOption {
	return func(params *UnpinAllForumTopicMessagesParams) UnpinAllForumTopicMessagesOption {
		previous := params.ChatID
		params.ChatID = value

		return WithUnpinAllForumTopicMessagesChatID(previous)
	}
}

// WithUnpinAllForumTopicMessagesMessageThreadID sets the MessageThreadID field.
//
// Unique identifier for the target message thread of the forum topic
func WithUnpinAllForumTopicMessagesMessageThreadID(value int64) UnpinAllForumTopicMessagesOption {
	return func(params *UnpinAllForumTopicMessagesParams) UnpinAllForumTopicMessagesOption {
		previous := params.MessageThreadID
		params.MessageThreadID = value

		return WithUnpinAllForumTopicMessagesMessageThreadID(previous)
	}
}

// UnpinAllForumTopicMessages calls the unpinAllForumTopicMessages Telegram Bot API method.
//
// Use this method to clear the list of pinned messages in a forum topic in a forum supergroup chat or a private chat with a user.
// In the case of a supergroup chat the bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup.
// Returns True on success.
func (c *Client) UnpinAllForumTopicMessages(params *UnpinAllForumTopicMessagesParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("unpinAllForumTopicMessages", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// UnpinAllGeneralForumTopicMessagesParams contains parameters for Client.UnpinAllGeneralForumTopicMessages.
type UnpinAllGeneralForumTopicMessagesParams struct {
	// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
	ChatID string `json:"chat_id"`
}

// UnpinAllGeneralForumTopicMessagesOption configures UnpinAllGeneralForumTopicMessagesParams.
type UnpinAllGeneralForumTopicMessagesOption func(params *UnpinAllGeneralForumTopicMessagesParams) UnpinAllGeneralForumTopicMessagesOption

// Option applies one or more UnpinAllGeneralForumTopicMessagesOption values and returns the last rollback option.
func (r *UnpinAllGeneralForumTopicMessagesParams) Option(opts ...UnpinAllGeneralForumTopicMessagesOption) (previous UnpinAllGeneralForumTopicMessagesOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithUnpinAllGeneralForumTopicMessagesChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)
func WithUnpinAllGeneralForumTopicMessagesChatID(value string) UnpinAllGeneralForumTopicMessagesOption {
	return func(params *UnpinAllGeneralForumTopicMessagesParams) UnpinAllGeneralForumTopicMessagesOption {
		previous := params.ChatID
		params.ChatID = value

		return WithUnpinAllGeneralForumTopicMessagesChatID(previous)
	}
}

// UnpinAllGeneralForumTopicMessages calls the unpinAllGeneralForumTopicMessages Telegram Bot API method.
//
// Use this method to clear the list of pinned messages in a General forum topic.
// The bot must be an administrator in the chat for this to work and must have the can_pin_messages administrator right in the supergroup.
// Returns True on success.
func (c *Client) UnpinAllGeneralForumTopicMessages(params *UnpinAllGeneralForumTopicMessagesParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("unpinAllGeneralForumTopicMessages", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// UnpinChatMessageParams contains parameters for Client.UnpinChatMessage.
type UnpinChatMessageParams struct {
	// Unique identifier of the business connection on behalf of which the message will be unpinned
	BusinessConnectionID string `json:"business_connection_id,omitempty"`

	// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
	ChatID string `json:"chat_id"`

	// Identifier of the message to unpin.
	// Required if business_connection_id is specified.
	// If not specified, the most recent pinned message (by sending date) will be unpinned.
	MessageID int64 `json:"message_id,omitempty"`
}

// UnpinChatMessageOption configures UnpinChatMessageParams.
type UnpinChatMessageOption func(params *UnpinChatMessageParams) UnpinChatMessageOption

// Option applies one or more UnpinChatMessageOption values and returns the last rollback option.
func (r *UnpinChatMessageParams) Option(opts ...UnpinChatMessageOption) (previous UnpinChatMessageOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithUnpinChatMessageBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection on behalf of which the message will be unpinned
func WithUnpinChatMessageBusinessConnectionID(value string) UnpinChatMessageOption {
	return func(params *UnpinChatMessageParams) UnpinChatMessageOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithUnpinChatMessageBusinessConnectionID(previous)
	}
}

// WithUnpinChatMessageChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername)
func WithUnpinChatMessageChatID(value string) UnpinChatMessageOption {
	return func(params *UnpinChatMessageParams) UnpinChatMessageOption {
		previous := params.ChatID
		params.ChatID = value

		return WithUnpinChatMessageChatID(previous)
	}
}

// WithUnpinChatMessageMessageID sets the MessageID field.
//
// Identifier of the message to unpin.
// Required if business_connection_id is specified.
// If not specified, the most recent pinned message (by sending date) will be unpinned.
func WithUnpinChatMessageMessageID(value int64) UnpinChatMessageOption {
	return func(params *UnpinChatMessageParams) UnpinChatMessageOption {
		previous := params.MessageID
		params.MessageID = value

		return WithUnpinChatMessageMessageID(previous)
	}
}

// UnpinChatMessage calls the unpinChatMessage Telegram Bot API method.
//
// Use this method to remove a message from the list of pinned messages in a chat.
// In private chats and channel direct messages chats, all messages can be unpinned.
// Conversely, the bot must be an administrator with the 'can_pin_messages' right or the 'can_edit_messages' right to unpin messages in groups and channels respectively.
// Returns True on success.
func (c *Client) UnpinChatMessage(params *UnpinChatMessageParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("unpinChatMessage", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// UpgradeGiftParams contains parameters for Client.UpgradeGift.
type UpgradeGiftParams struct {
	// Unique identifier of the business connection
	BusinessConnectionID string `json:"business_connection_id"`

	// Unique identifier of the regular gift that should be upgraded to a unique one
	OwnedGiftID string `json:"owned_gift_id"`

	// Pass True to keep the original gift text, sender and receiver in the upgraded gift
	KeepOriginalDetails bool `json:"keep_original_details,omitempty"`

	// The amount of Telegram Stars that will be paid for the upgrade from the business account balance.
	// If gift.prepaid_upgrade_star_count > 0, then pass 0, otherwise, the can_transfer_stars business bot right is required and gift.upgrade_star_count must be passed.
	StarCount int64 `json:"star_count,omitempty"`
}

// UpgradeGiftOption configures UpgradeGiftParams.
type UpgradeGiftOption func(params *UpgradeGiftParams) UpgradeGiftOption

// Option applies one or more UpgradeGiftOption values and returns the last rollback option.
func (r *UpgradeGiftParams) Option(opts ...UpgradeGiftOption) (previous UpgradeGiftOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithUpgradeGiftBusinessConnectionID sets the BusinessConnectionID field.
//
// Unique identifier of the business connection
func WithUpgradeGiftBusinessConnectionID(value string) UpgradeGiftOption {
	return func(params *UpgradeGiftParams) UpgradeGiftOption {
		previous := params.BusinessConnectionID
		params.BusinessConnectionID = value

		return WithUpgradeGiftBusinessConnectionID(previous)
	}
}

// WithUpgradeGiftOwnedGiftID sets the OwnedGiftID field.
//
// Unique identifier of the regular gift that should be upgraded to a unique one
func WithUpgradeGiftOwnedGiftID(value string) UpgradeGiftOption {
	return func(params *UpgradeGiftParams) UpgradeGiftOption {
		previous := params.OwnedGiftID
		params.OwnedGiftID = value

		return WithUpgradeGiftOwnedGiftID(previous)
	}
}

// WithUpgradeGiftKeepOriginalDetails sets the KeepOriginalDetails field.
//
// Pass True to keep the original gift text, sender and receiver in the upgraded gift
func WithUpgradeGiftKeepOriginalDetails(value bool) UpgradeGiftOption {
	return func(params *UpgradeGiftParams) UpgradeGiftOption {
		previous := params.KeepOriginalDetails
		params.KeepOriginalDetails = value

		return WithUpgradeGiftKeepOriginalDetails(previous)
	}
}

// WithUpgradeGiftStarCount sets the StarCount field.
//
// The amount of Telegram Stars that will be paid for the upgrade from the business account balance.
// If gift.prepaid_upgrade_star_count > 0, then pass 0, otherwise, the can_transfer_stars business bot right is required and gift.upgrade_star_count must be passed.
func WithUpgradeGiftStarCount(value int64) UpgradeGiftOption {
	return func(params *UpgradeGiftParams) UpgradeGiftOption {
		previous := params.StarCount
		params.StarCount = value

		return WithUpgradeGiftStarCount(previous)
	}
}

// UpgradeGift calls the upgradeGift Telegram Bot API method.
//
// Upgrades a given regular gift to a unique gift.
// Requires the can_transfer_and_upgrade_gifts business bot right.
// Additionally requires the can_transfer_stars business bot right if the upgrade is paid.
// Returns True on success.
func (c *Client) UpgradeGift(params *UpgradeGiftParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("upgradeGift", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// UploadStickerFileParams contains parameters for Client.UploadStickerFile.
type UploadStickerFileParams struct {
	// User identifier of sticker file owner
	UserID int64 `json:"user_id"`

	// A file with the sticker in .WEBP, .PNG, .TGS, or .WEBM format.
	// See [https://core.telegram.org/stickers] for technical requirements.
	// [More information on Sending Files »]
	//
	// [https://core.telegram.org/stickers]: https://core.telegram.org/stickers
	// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
	Sticker InputFile `json:"sticker"`

	// Format of the sticker, must be one of “static”, “animated”, “video”
	StickerFormat string `json:"sticker_format"`
}

// UploadStickerFileOption configures UploadStickerFileParams.
type UploadStickerFileOption func(params *UploadStickerFileParams) UploadStickerFileOption

// Option applies one or more UploadStickerFileOption values and returns the last rollback option.
func (r *UploadStickerFileParams) Option(opts ...UploadStickerFileOption) (previous UploadStickerFileOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithUploadStickerFileUserID sets the UserID field.
//
// User identifier of sticker file owner
func WithUploadStickerFileUserID(value int64) UploadStickerFileOption {
	return func(params *UploadStickerFileParams) UploadStickerFileOption {
		previous := params.UserID
		params.UserID = value

		return WithUploadStickerFileUserID(previous)
	}
}

// WithUploadStickerFileSticker sets the Sticker field.
//
// A file with the sticker in .WEBP, .PNG, .TGS, or .WEBM format.
// See [https://core.telegram.org/stickers] for technical requirements.
// [More information on Sending Files »]
//
// [https://core.telegram.org/stickers]: https://core.telegram.org/stickers
// [More information on Sending Files »]: https://core.telegram.org/bots/api#sending-files
func WithUploadStickerFileSticker(value InputFile) UploadStickerFileOption {
	return func(params *UploadStickerFileParams) UploadStickerFileOption {
		previous := params.Sticker
		params.Sticker = value

		return WithUploadStickerFileSticker(previous)
	}
}

// WithUploadStickerFileStickerFormat sets the StickerFormat field.
//
// Format of the sticker, must be one of “static”, “animated”, “video”
func WithUploadStickerFileStickerFormat(value string) UploadStickerFileOption {
	return func(params *UploadStickerFileParams) UploadStickerFileOption {
		previous := params.StickerFormat
		params.StickerFormat = value

		return WithUploadStickerFileStickerFormat(previous)
	}
}

// UploadStickerFile calls the uploadStickerFile Telegram Bot API method.
//
// Use this method to upload a file with a sticker for later use in the [createNewStickerSet], [addStickerToSet], or [replaceStickerInSet] methods (the file can be used multiple times).
// Returns the uploaded [File] on success.
//
// [createNewStickerSet]: https://core.telegram.org/bots/api#createnewstickerset
// [addStickerToSet]: https://core.telegram.org/bots/api#addstickertoset
// [replaceStickerInSet]: https://core.telegram.org/bots/api#replacestickerinset
// [File]: https://core.telegram.org/bots/api#file
func (c *Client) UploadStickerFile(params *UploadStickerFileParams) (ret *File, err error) {
	var bs []byte

	reader, pw := io.Pipe()
	writer := multipart.NewWriter(pw)

	go func() {
		defer pw.Close()
		defer writer.Close()

		{
			v := strconv.FormatInt(params.UserID, 10)
			err = writer.WriteField("user_id", v)
			if err != nil {
				return
			}
		}

		{
			if params.Sticker.File != nil {
				var w io.Writer
				params.Sticker.fieldName = "sticker"

				w, err = writer.CreateFormFile(
					params.Sticker.fieldName,
					params.Sticker.FileName,
				)
				if err != nil {
					return
				}

				_, err = io.Copy(w, params.Sticker.File)
				if err != nil {
					return
				}

				if closer, ok := params.Sticker.File.(io.Closer); ok {
					err = closer.Close()
					if err != nil {
						return
					}
				}
			}

			bs, err = json.Marshal(params.Sticker)
			if err != nil {
				return
			}

			var p io.Writer

			p, err = writer.CreateFormField("sticker")
			if err != nil {
				return
			}

			_, err = p.Write(bs)
			if err != nil {
				return
			}
		}

		{
			err = writer.WriteField("sticker_format", params.StickerFormat)
			if err != nil {
				return
			}
		}

	}()

	contentType := writer.FormDataContentType()

	var result json.RawMessage

	result, err = c.Raw("uploadStickerFile", reader, contentType)
	if err != nil {
		return
	}

	ret = new(File)
	ref := ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// VerifyChatParams contains parameters for Client.VerifyChat.
type VerifyChatParams struct {
	// Unique identifier for the target chat or username of the target channel (in the format @channelusername).
	// Channel direct messages chats can't be verified.
	ChatID string `json:"chat_id"`

	// Custom description for the verification; 0-70 characters.
	// Must be empty if the organization isn't allowed to provide a custom verification description.
	CustomDescription string `json:"custom_description,omitempty"`
}

// VerifyChatOption configures VerifyChatParams.
type VerifyChatOption func(params *VerifyChatParams) VerifyChatOption

// Option applies one or more VerifyChatOption values and returns the last rollback option.
func (r *VerifyChatParams) Option(opts ...VerifyChatOption) (previous VerifyChatOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithVerifyChatChatID sets the ChatID field.
//
// Unique identifier for the target chat or username of the target channel (in the format @channelusername).
// Channel direct messages chats can't be verified.
func WithVerifyChatChatID(value string) VerifyChatOption {
	return func(params *VerifyChatParams) VerifyChatOption {
		previous := params.ChatID
		params.ChatID = value

		return WithVerifyChatChatID(previous)
	}
}

// WithVerifyChatCustomDescription sets the CustomDescription field.
//
// Custom description for the verification; 0-70 characters.
// Must be empty if the organization isn't allowed to provide a custom verification description.
func WithVerifyChatCustomDescription(value string) VerifyChatOption {
	return func(params *VerifyChatParams) VerifyChatOption {
		previous := params.CustomDescription
		params.CustomDescription = value

		return WithVerifyChatCustomDescription(previous)
	}
}

// VerifyChat calls the verifyChat Telegram Bot API method.
//
// Verifies a chat [on behalf of the organization] which is represented by the bot.
// Returns True on success.
//
// [on behalf of the organization]: https://telegram.org/verify#third-party-verification
func (c *Client) VerifyChat(params *VerifyChatParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("verifyChat", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}

// VerifyUserParams contains parameters for Client.VerifyUser.
type VerifyUserParams struct {
	// Unique identifier of the target user
	UserID int64 `json:"user_id"`

	// Custom description for the verification; 0-70 characters.
	// Must be empty if the organization isn't allowed to provide a custom verification description.
	CustomDescription string `json:"custom_description,omitempty"`
}

// VerifyUserOption configures VerifyUserParams.
type VerifyUserOption func(params *VerifyUserParams) VerifyUserOption

// Option applies one or more VerifyUserOption values and returns the last rollback option.
func (r *VerifyUserParams) Option(opts ...VerifyUserOption) (previous VerifyUserOption) {
	for _, opt := range opts {
		previous = opt(r)
	}
	return previous
}

// WithVerifyUserUserID sets the UserID field.
//
// Unique identifier of the target user
func WithVerifyUserUserID(value int64) VerifyUserOption {
	return func(params *VerifyUserParams) VerifyUserOption {
		previous := params.UserID
		params.UserID = value

		return WithVerifyUserUserID(previous)
	}
}

// WithVerifyUserCustomDescription sets the CustomDescription field.
//
// Custom description for the verification; 0-70 characters.
// Must be empty if the organization isn't allowed to provide a custom verification description.
func WithVerifyUserCustomDescription(value string) VerifyUserOption {
	return func(params *VerifyUserParams) VerifyUserOption {
		previous := params.CustomDescription
		params.CustomDescription = value

		return WithVerifyUserCustomDescription(previous)
	}
}

// VerifyUser calls the verifyUser Telegram Bot API method.
//
// Verifies a user [on behalf of the organization] which is represented by the bot.
// Returns True on success.
//
// [on behalf of the organization]: https://telegram.org/verify#third-party-verification
func (c *Client) VerifyUser(params *VerifyUserParams) (ret bool, err error) {
	var bs []byte

	bs, err = json.Marshal(params)
	if err != nil {
		return
	}

	reader := bytes.NewReader(bs)
	contentType := "application/json"

	var result json.RawMessage

	result, err = c.Raw("verifyUser", reader, contentType)
	if err != nil {
		return
	}

	ref := &ret

	err = json.Unmarshal(result, ref)
	if err != nil {
		return
	}

	return ret, err
}
