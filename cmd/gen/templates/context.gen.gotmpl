// Code generated by gogram/cmd/gen; DO NOT EDIT.

package gogram

{{ $root := . }}

func (ctx *Context) findHandlerOn() handleOn {
    if ctx.update == nil {
        return 0
    }

    switch {
    {{- range .Types.Update.Fields }}
        {{- $name := toTitle .Name }}
        {{- $typ := toType .Type true }}
        {{- range (index $root.Types $typ).Fields }}
            {{- if toType .Type true | eq "User" }}
                case ctx.update.{{ $name }} != nil:
                    return handleOn{{ $name }}
                {{- break }}
            {{- end }}
        {{- end }}
    {{- end }}
    }

    return 0
}

// User returns a user associated with the current update.
func (ctx *Context) User() *User {
    if ctx.update == nil {
        return nil
    }

    switch {
    {{- range .Types.Update.Fields }}
        {{- $name := toTitle .Name }}
        {{- $typ := toType .Type true }}
        {{- range (index $root.Types $typ).Fields }}
            {{- if toType .Type true | eq "User" }}
                case ctx.update.{{ $name }} != nil:
                    return {{ if .IsRequired }}&{{ end }}ctx.update.{{ $name }}.{{ toTitle .Name }}
                {{- break }}
            {{- end }}
        {{- end }}
    {{- end }}
    }

    return nil
}

// Chat returns a chat associated with the current update.
func (ctx *Context) Chat() *Chat {
    if ctx.update == nil {
        return nil
    }

    switch {
    {{- range .Types.Update.Fields }}
        {{- $name := toTitle .Name }}
        {{- $typ := toType .Type true }}
        {{- if eq $typ "Message" }}
            case ctx.update.{{ $name }} != nil:
                return &ctx.update.{{ $name }}.Chat
        {{- else }}
            {{- range (index $root.Types $typ).Fields }}
                {{- if toType .Type true | eq "Chat" }}
                    case ctx.update.{{ $name }} != nil:
                        return {{ if .IsRequired }}&{{ end}}ctx.update.{{ $name }}.{{ toTitle .Name }}
                    {{- break }}
                {{- end }}
            {{- end }}
        {{- end }}
    {{- end }}
    }

    return nil
}

// Message returns the message associated with the current update, if any.
func (ctx *Context) Message() *Message {
    if ctx.update == nil {
        return nil
    }

    switch {
    {{- range .Types.Update.Fields }}
        {{- $name := toTitle .Name }}
        {{- $typ := toType .Type true }}
        {{- if toType .Type true | eq "Message" }}
            case ctx.update.{{ $name }} != nil:
                return ctx.update.{{ $name }}
        {{- end }}
    {{- end }}
    }

    return nil
}

// Text returns Message().Text or an empty string when no message is present.
func (ctx *Context) Text() string {
    m := ctx.Message()
    if m == nil {
        return ""
    }

    return m.Text
}

// Payload returns the substring of Text() after the first space.
func (ctx *Context) Payload() string {
    return ExtractPayload(ctx.Text())
}

{{ range .Methods }}
    {{ $method := toTitle .Name }}
    {{ $params := print $method "Params" }}
    {{ $option := print $method "Option" }}
// {{ $method }} calls Client.{{ $method }} with context-derived defaults.
// {{ .Desc }}
func (ctx *Context) {{ $method }}(
    {{- range .Params }}
        {{- if .AutoFillCode $root.Types }}
            {{- continue }}
        {{- end }}
        {{- if .IsRequired }}
            {{ toTitle .Name | toLowerFirst }} {{ toType .Type .IsRequired }},
        {{- end }}
    {{- end }}
    opts ...{{ $option }},
) error {
    params := &{{ $params }}{
        {{- range .Params }}
            {{- if $code := .AutoFillCode $root.Types }}
                {{ toTitle .Name }}: {{ $code }},
                {{- continue }}
            {{- end }}
            {{- if .IsRequired  }}
                {{ toTitle .Name }}: {{ toTitle .Name | toLowerFirst }},
            {{- end }}
        {{- end }}
    }

    params.Option(opts...)

    {{- $parseModeName := "" }}
    {{- $entitiesName := "" }}
    {{- $inputMediaName := "" }}
    {{- $inputMediasName := "" }}
    {{- range .Params }}
        {{- if toTitle .Name | eq "ParseMode" }}
            {{- $parseModeName = toTitle .Name }}
        {{- end }}
        {{- if toType .Type .IsRequired | eq "[]MessageEntity" }}
            {{- $entitiesName = toTitle .Name }}
        {{- end }}
        {{- if toType .Type .IsRequired | eq "InputMedia" }}
            {{- $inputMediaName = toTitle .Name }}
        {{- end }}
        {{- if toType .Type .IsRequired | eq "[]InputMedia" }}
            {{- $inputMediasName = toTitle .Name }}
        {{- end }}
    {{- end }}

    {{ if or $parseModeName $entitiesName $inputMediaName $inputMediasName }}
        if defaultParseMode := ctx.client.defaultParseMode; defaultParseMode != "" {
            {{- if $parseModeName }}
                if params.{{ $parseModeName }} == "" && len(params.{{ $entitiesName }}) == 0 {
                    params.{{ $parseModeName }} = defaultParseMode
                }
            {{- end }}
            {{- if $inputMediaName }}
                defaultParseModeToInputMedia(&params.{{ $inputMediaName }}, defaultParseMode)
            {{- end }}
            {{- if $inputMediasName }}
                for i := range params.{{ $inputMediasName }} {
                    defaultParseModeToInputMedia(&params.{{ $inputMediasName }}[i], defaultParseMode)
		        }
            {{- end }}
        }
    {{ end }}

    _, err := ctx.client.{{ $method }}(params)

    return err
}

{{ end }}

func defaultParseModeToInputMedia(media *InputMedia, parseMode string) {
	if media == nil {
		return
	}

    switch {
    {{- range $root.Types.InputMedia.Subtypes }}
        {{ $sub := index $root.Types . }}
        {{ $name := toTitle $sub.Name }}
    	case media.{{ $name }} != nil:
    		if media.{{ $name }}.ParseMode == "" && len(media.{{ $name }}.CaptionEntities) == 0 {
    			media.{{ $name }}.ParseMode = parseMode
    		}
    {{- end }}
	}
}
